<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Creating the colored mesh</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_287"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_139.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_141.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>4.2.10&nbsp;&nbsp;Creating the colored mesh</h3>

<p>If you think that these things we have been examining are advanced, then
you haven't seen anything. Now comes real hard-core advanced POV-Ray code,
so be prepared. This could be called <i>The really advanced section</i>.</p>

<p>We have now calculated the image into the array of colors. However, we
still have to show these color &quot;pixels&quot; on screen, that is, we have to make
POV-Ray to render our pixels so that it creates a real image.</p>

<p>There are several ways of doing this, all of them being more or less
&quot;kludges&quot; (as there is currently no way of directly creating an image map
from a group of colors). One could create colored boxes representing each
pixel, or one could output to an ascii-formatted image file (mainly PPM)
and then read it as an image map. The first one has the disavantage of
requiring huge amounts of memory and missing bilinear interpolation of the
image; the second one has the disadvantage of requiring a temporary file.</p>

<p>What we are going to do is to calculate a colored mesh2 which represents
the &quot;screen&quot;.
As colors are interpolated between the vertices of a triangle, the
bilinear interpolation comes for free (almost).</p>


</div>

<div class="divh4">
<a name="target_288"></a>
<h4>4.2.10.1&nbsp;&nbsp;The structure of the mesh</h4>

<p>Although all the triangles are located in the x-y plane and they are all
the same size, the structure of the mesh is quite complicated (so complicated
it deserves its own section here).</p>

<p>The following image shows how the triangles are arranged for a 4x3 pixels
image:</p>

  
<center><img src="images/triangles.gif" alt="Triangle arrangement for a 4x3 image"><br><font size=-1><cite>Triangle arrangement for a 4x3 image</cite></font></center>



<p>The number pairs in parentheses represent image pixel coordinates
(eg. <code>(0,0)</code> refers to the pixel at the lower left corner of
the image and <code>(3,2)</code> to the pixel at the upper right corner).
That is, the triangles will be colored as the image pixels at these
points. The colors will then be interpolated between them along the surface
of the triangles.</p>

<p>The filled and non-filled circles in the image represent the vertex points
of the triangles and the lines connecting them show how the triangles are
arranged. The smaller numbers near these circles indicate their index value
(the one which will be created inside the <code>mesh2</code>).</p>

<p>We notice two things which may seem odd: Firstly there are extra vertex
points outside the mesh, and secondly, there are extra vertex points in the
middle of each square.</p>

<p>Let's start with the vertices in the middle of the squares: We could
have just made each square with two triangles instead of four, as we have
done here. However, the color interpolation is not nice this way, as there
appears a clear diagonal line where the triangle edges go. If we make
each square with four triangles instead, then the diagonal lines are
less apparent, and the interpolation resembles a lot better a true
bilinear interpolation. And what is the color of the middle points? Of
course it's the average of the color of the four points in the corners.</p>

<p>Secondly: Yes, the extra vertex points outside the mesh are completely
obsolete and take no part in the creation of the mesh. We could perfectly
create the exact same mesh without them. However, getting rid of these
extra vertex points makes our lives more difficult when creating the
triangles, as it would make the indexing of the points more difficult.
It may not be too much work to get rid of them, but they don't take
any considerable amount of resources and they make our lives easier, so
let's just let them be (if you want to remove them, go ahead).</p>

</div>

<div class="divh4">
<a name="target_289"></a>
<h4>4.2.10.2&nbsp;&nbsp;Creating the mesh</h4>

<p>What this means is that for each pixel we create two vertex points,
one at the pixel location and one shifted by &quot;0.5&quot; in the x and y directions.
Then we specify the color for each vertex points: For the even vertex points
it's directly the color of the correspondent pixel; for the odd vertex points
it's the average of the four surrounding pixels.</p>

<p>Let's examine the creation of the mesh step by step:</p>

</div>

<div class="divh5">
<a name="target_290"></a>
<h5>4.2.10.2.1&nbsp;&nbsp;Creating the vertex points</h5>

<pre>
#default { finish { ambient 1 } }

#debug &quot;Creating colored mesh to show image...\n&quot;
mesh2
{ vertex_vectors
  { ImageWidth*ImageHeight*2,
    #declare IndY = 0;
    #while(IndY &lt; ImageHeight)
      #declare IndX = 0;
      #while(IndX &lt; ImageWidth)
        &lt;(IndX/(ImageWidth-1)-.5)*ImageWidth/ImageHeight*2,
         IndY/(ImageHeight-1)*2-1, 0&gt;,
        &lt;((IndX+.5)/(ImageWidth-1)-.5)*ImageWidth/ImageHeight*2,
         (IndY+.5)/(ImageHeight-1)*2-1, 0&gt;
        #declare IndX = IndX+1;
      #end
      #declare IndY = IndY+1;
    #end
  }
</pre>


<p>First of all we use a nice trick in POV-Ray: Since we are not using
light sources and there's nothing illuminating our mesh, what we do
is to set the ambient value of the mesh to 1. We do this by just making
it the default with the <code>#default</code> command, so we don't have
to bother later.</p>

<p>As we saw above, what we are going to do is to create two vertex points
for each pixel. Thus we know without further thinking how many vertex
vectors there will be: <code>ImageWidth*ImageHeight*2</code></p>

<p>That was the easy part; now we have to figure out how to create the
vertex points themselves. Each vertex location should correspond to the
pixel location it's representing, thus we go through each pixel index
(practically the number pairs in parentheses in the image above) and
create vertex points using these index values. The location of these
pixels and vertices are the same as we assumed when we calculated the
image itself (in the previous part). Thus the y coordinate of each vertex
point should go from -1 to 1 and similarly the x coordinate, but scaled
with the aspect ratio.</p>

<p>If you look at the creation of the first vector in the code above, you'll
see that it's almost identical to the direction vector we calculated when
creating the image.</p>

<p>The second vector should be shifted by 0.5 in both directions, and that's
exactly what is done there. The second vector definition is identical to
the first one except that the index values are shifted by 0.5. This creates
the points in the middle of the squares.</p>

<p>The index values of these points will be arranged as shown in the image
above.</p>

</div>

<div class="divh5">
<a name="target_291"></a>
<h5>4.2.10.2.2&nbsp;&nbsp;Creating the textures</h5>

<pre>
  texture_list
  { ImageWidth*ImageHeight*2,
    #declare IndY = 0;
    #while(IndY &lt; ImageHeight)
      #declare IndX = 0;
      #while(IndX &lt; ImageWidth)
        texture { pigment { rgb Image[IndX][IndY] } }
        #if(IndX &lt; ImageWidth-1 &amp; IndY &lt; ImageHeight-1)
          texture { pigment { rgb
            (Image[IndX][IndY]+Image[IndX+1][IndY]+
             Image[IndX][IndY+1]+Image[IndX+1][IndY+1])/4 } }
        #else
          texture { pigment { rgb 0 } }
        #end
        #declare IndX = IndX+1;
      #end
      #declare IndY = IndY+1;
    #end
  }
</pre>


<p>Creating the textures is very similar to creating the vertex points
(we could have done both inside the same loop, but due to the syntax
of the <code>mesh2</code> we have to do it separately).</p>

<p>So what we do is to go through all the pixels in the image and create
textures for each one. The first texture is just the pixel color itself.
The second texture is the average of the four surrounding pixels. </p>
<p class="Note"><strong>Note:</strong> we can calculate it only for the vertex points in the middle of
the squares; for the extra vertex points outside the image we just define
a dummy black texture.</p>

<p>The textures have the same index values as the vertex points.</p>

</div>

<div class="divh5">
<a name="target_292"></a>
<h5>4.2.10.2.3&nbsp;&nbsp;Creating the triangles</h5>

<p>This one is a bit trickier. Basicly we have to create four triangles
for each &quot;square&quot; between pixels. How many triangles will there be?</p>

<p>Let's examine the creation loop first:</p>

<pre>
  face_indices
  { (ImageWidth-1)*(ImageHeight-1)*4,
    #declare IndY = 0;
    #while(IndY &lt; ImageHeight-1)
      #declare IndX = 0;
      #while(IndX &lt; ImageWidth-1)

        ...

        #declare IndX = IndX+1;
      #end
      #declare IndY = IndY+1;
    #end
  }
</pre>


<p>The number of &quot;squares&quot; is one less than the number of pixels in each
direction. That is, the number of squares in the x direction will be one
less than the number of pixels in the x direction. The same for the y
direction. As we want four triangles for each square, the total number of
triangles will then be <code>(ImageWidth-1)*(ImageHeight-1)*4</code>.</p>

<p>Then to create each square we loop the amount of pixels minus one for
each direction.</p>

<p>Now in the inside of the loop we have to create the four triangles.
Let's examine the first one:</p>

<pre>
        &lt;IndX*2+  IndY    *(ImageWidth*2),
         IndX*2+2+IndY    *(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2)&gt;,
         IndX*2+  IndY    *(ImageWidth*2),
         IndX*2+2+IndY    *(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2),
</pre>

<p>This creates a triangle with a texture in each vertex. The first three
values (the indices to vertex points) are identical to the next three values
(the indices to the textures) because the index values were exactly the same
for both.</p>

<p>The <code>IndX</code> is always multiplied by 2 because we had two vertex
points for each pixel and <code>IndX</code> is basically going through the
pixels. Likewise <code>IndY</code> is always multiplied by
<code>ImageWidth*2</code> because that's how long a row of index points
is (ie. to get from one row to the next at the same x coordinate we have
to advance <code>ImageWidth*2</code> in the index values).</p>

<p>These two things are identical in all the triangles. What decides which
vertex point is chosen is the &quot;+1&quot; or &quot;+2&quot; (or &quot;+0&quot; when there's nothing).
For <code>IndX</code> &quot;+0&quot; is the current pixel, &quot;+1&quot; chooses the point in
the middle of the square and &quot;+2&quot; chooses the next pixel. For
<code>IndY</code> &quot;+1&quot; chooses the next row of pixels.</p>

<p>Thus this triangle definition creates a triangle using the vertex point
for the current pixel, the one for the next pixel and the vertex point in
the middle of the square.</p>

<p>The next triangle definition is likewise:</p>

<pre>
        &lt;IndX*2+  IndY    *(ImageWidth*2),
         IndX*2+  (IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2)&gt;,
         IndX*2+  IndY    *(ImageWidth*2),
         IndX*2+  (IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2),
</pre>


<p>This one defines the triangle using the current point, the point in the
next row and the point in the middle of the square.</p>

<p>The next two definitions define the other two triangles:</p>

<pre>
        &lt;IndX*2+  (IndY+1)*(ImageWidth*2),
         IndX*2+2+(IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2)&gt;,
         IndX*2+  (IndY+1)*(ImageWidth*2),
         IndX*2+2+(IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2),

        &lt;IndX*2+2+IndY    *(ImageWidth*2),
         IndX*2+2+(IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2)&gt;,
         IndX*2+2+IndY    *(ImageWidth*2),
         IndX*2+2+(IndY+1)*(ImageWidth*2),
         IndX*2+1+IndY    *(ImageWidth*2)
</pre>



</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_139.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_141.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
