<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Isosurface Object</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_136"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_081.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_083.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>3.6.3&nbsp;&nbsp;Isosurface Object</h3>
<a name="target_137"></a>


<p>
<center>
<table width="75%">
<tr><td>
	<em>You know you have been raytracing too long when ...</em>
</td></tr>
<tr><td>
	<em>... You find yourself wishing you'd paid attention in math class
         to all those formulae you thought you'd never have any use for
         in real life.</em>
</td></tr>
<tr><td align="right">
	<em>-- Jeff Lee</em>
</td></tr>
</table>
</center>
</p>

  <p>Isosurfaces are shapes described by mathematical functions.</p>

  <p>In contrast to the other mathematically based shapes in POV-Ray, isosurfaces
  are approximated during rendering and therefore they are sometimes more
  difficult to handle. However, they offer many interesting possibilities.</p>

  <p>Some knowledge about mathematical functions and geometry is useful,
  but not necessarily required to work with isosurfaces.</p>

</div>

<div class="divh4">
<a name="target_138"></a>
<h4>3.6.3.1&nbsp;&nbsp;simple functions</h4>

  <p>For the start we will choose a most simple function: <code>x</code>
  The value of this function is exactly the current x-coordinate.</p>

  <p>The isosurface object takes this function as a
  <a href="povdoc_161.html#target_625">user defined function</a>:</p>

<pre>
  isosurface {
    function { x }
    contained_by { box { -2, 2 } }
  }
</pre>

  
<center><img src="images/iso_01.gif" alt="Isosurface sample (function { x })"><br><font size=-1><cite>Isosurface sample (function { x })</cite></font></center>


  <p>the resulting shape is fairly simple: a box.</p>

  <p>The fact that it is a box is only caused by the container object which is
  required for an isosurface. You can either use a box or a sphere for this
  purpose.</p>

  <p>So only one side of the box is made by the function in fact.  This surface
  is where the x-coordinate is 0 since 0 is the default threshold.  There usually
  is no reason to change this, since it is the most common and most suggestive
  value, but you can specify something different by adding</p>

  <p><code>  threshold 1</code></p>

  <p>to the isosurface definition.</p>

  
<center><img src="images/iso_02.gif" alt="Isosurface sample (function { x }, threshold 1)"><br><font size=-1><cite>Isosurface sample (function { x }, threshold 1)</cite></font></center>


  <p>As you can see, the surface is now at x-coordinate 1.</p>

  <p>We can also remove the visible surfaces of the container object by adding
  the word 'open' to the isosurface definition.</p>

  
<center><img src="images/iso_03.gif" alt="Isosurface sample (function { x }, open)"><br><font size=-1><cite>Isosurface sample (function { x }, open)</cite></font></center>


  <p>For making it clearer what surfaces are the actual isosurface and what are
  caused by the container object, the color will be different in all the
  following pictures.</p>

  <p>Now we replace the used function with something different:</p>

  <p><code>  function { x+y }</code></p>

  
<center><img src="images/iso_04.gif" alt="Isosurface sample (plane function)"><br><font size=-1><cite>Isosurface sample (plane function)</cite></font></center>


  <p><code>  function { x+y+z }</code></p>

  
<center><img src="images/iso_05.gif" alt="Isosurface sample (plane function)"><br><font size=-1><cite>Isosurface sample (plane function)</cite></font></center>


  <p class="Note"><strong>Note:</strong> 'max_gradient 4' is added to the isosurface definition here,
  this will be explained later on.</p>

  <p>All these functions describe planes going through the origin.  The
  function just describes the normal vector of this plane.</p>

</div>

<div class="divh4">
<a name="target_139"></a>
<h4>3.6.3.2&nbsp;&nbsp;several surfaces</h4>

  <p>The following two functions lead to identical results:</p>

  <p><code>  function { abs(x)-1 }</code></p>
  <p><code>  function { sqrt(x*x)-1 }</code></p>

  
<center><img src="images/iso_06.gif" alt="Isosurface sample (function { abs(x)-1 }, open)"><br><font size=-1><cite>Isosurface sample (function { abs(x)-1 }, open)</cite></font></center>


  <p>You can see that there are two planes now.  The reason is that both formulas
  have the same two solutions (where the function value is 0),
  namely <code>x=-1</code> and <code>x=1</code>.</p>

  <p>We can now mix all these elements in different combinations, the results
  always consist of plane surfaces:</p>

  <p><code>  function { abs(x)-1+y }</code></p>

  
<center><img src="images/iso_07.gif" alt="Isosurface sample (combined linear functions)"><br><font size=-1><cite>Isosurface sample (combined linear functions)</cite></font></center>


  <p><code>  function { abs(x)+abs(y)+abs(z)-2 }</code></p>

  
<center><img src="images/iso_08.gif" alt="Isosurface sample (combined linear functions)"><br><font size=-1><cite>Isosurface sample (combined linear functions)</cite></font></center>



</div>

<div class="divh4">
<a name="target_140"></a>
<h4>3.6.3.3&nbsp;&nbsp;non-linear functions</h4>

  <p>Curved surfaces of many different kinds can be achieved with non-linear
  functions.</p>

  <p><code>  function { pow(x,2) + y }</code></p>

  
<center><img src="images/iso_09.gif" alt="Isosurface sample (non-linear function)"><br><font size=-1><cite>Isosurface sample (non-linear function)</cite></font></center>


  <p>You can see the parabolic shape caused by the square function.</p>

  <p>To get a cylindrical surface we can use the following function.</p>

  <p><code>  function { sqrt(pow(x,2)- + pow(z,2)) - 1 }</code></p>

  <p>In 2 dimensions it describes a circle, since it is constant in the 3rd
  dimension, we get a cylinder:</p>

  
<center><img src="images/iso_10.gif" alt="Isosurface sample (cylinder function)"><br><font size=-1><cite>Isosurface sample (cylinder function)</cite></font></center>


  <p>It is of course not difficult to change this into a cone, we just need
  to add a linear component in y-direction:</p>

  <p><code>  function { sqrt(pow(x,2) + pow(z,2)) + y }</code></p>
  
<center><img src="images/iso_11.gif" alt="Isosurface sample (cone function)"><br><font size=-1><cite>Isosurface sample (cone function)</cite></font></center>


  <p>And we of course can also make a sphere:</p>

  <p><code>  function { sqrt(pow(x,2) + pow(y,2) + pow(z,2)) - 2 }</code></p>
  
<center><img src="images/iso_12.gif" alt="Isosurface sample (sphere function)"><br><font size=-1><cite>Isosurface sample (sphere function)</cite></font></center>


  <p>The <code>2</code> specifies the radius here.</p>


</div>

<div class="divh4">
<a name="target_141"></a>
<h4>3.6.3.4&nbsp;&nbsp;internal functions</h4>

  <p>There are a lot of internal functions available in POV-Ray. For example
  a sphere could also be generated with <code>function { f_sphere(x, y, z, 2) }</code>
  These functions are declared in the <code>functions.inc</code> include file.
  Most of them are more complicated and it's usually faster to use them instead of a
  hand coded equivalent. See the
  <a href="#target_141">complete list</a> for details.</p>

  <p>The following makes a torus just like POV-Ray's torus object:</p>

<pre>
  #include &quot;functions.inc&quot;

  isosurface {
    function { f_torus(x, y, z, 1.6, 0.4) }
    contained_by { box { -2, 2 } }
  }
</pre>

  
<center><img src="images/iso_13.gif" alt="Isosurface sample (torus function)"><br><font size=-1><cite>Isosurface sample (torus function)</cite></font></center>


  <p>The 4th and 5th parameter are the major and minor radius,
  just like the corresponding values in the <code>torus{}</code> object.</p>

  <p>The parameters x, y and z are required, because it is a declared function.
  You can also declare functions yourself like it is explained in the
  <a href="povdoc_161.html#target_631">reference section</a>.</p>


</div>

<div class="divh4">
<a name="target_142"></a>
<h4>3.6.3.5&nbsp;&nbsp;Combining isosurface functions</h4>

  <p>We can also simulate some Constructive Solid Geometry with isosurface functions.  If
  you don't know about CSG we suggest you have a look at
  <a href="povdoc_062.html#target_99">&quot;What is CSG?&quot;</a> or the corresponding
  part of the <a href="povdoc_192.html#target_905">reference section</a> first.</p>

  <p>We will take two functions: a cylinder and a rotated box:</p>

<pre>
  #declare fn_A = function { sqrt(pow(y,2) + pow(z,2)) - 0.8 }
  #declare fn_B = function { abs(x)+abs(y)-1 }
</pre>

  <p>If we combine them the following way, we get a &quot;merge&quot;:</p>

  <p><code>function { min(fn_A(x, y, z), fn_B(x, y, z)) }</code></p>

  
<center><img src="images/iso_14.gif" alt="Isosurface sample (merge)"><br><font size=-1><cite>Isosurface sample (merge)</cite></font></center>



  <p>An &quot;intersection&quot; can be obtained by using
  <code>max()</code> instead of <code>min()</code>:</p>

  <p><code>function { max(fn_A(x, y, z), fn_B(x, y, z)) }</code></p>

  
<center><img src="images/iso_15.gif" alt="Isosurface sample (intersection)"><br><font size=-1><cite>Isosurface sample (intersection)</cite></font></center>


  <p>Of course also &quot;difference&quot; is possible, we just have to
  add a minus (-) before the second function:</p>

  <p><code>function { max(fn_A(x, y, z), -fn_B(x, y, z)) }</code></p>

  
<center><img src="images/iso_16.gif" alt="Isosurface sample (difference)"><br><font size=-1><cite>Isosurface sample (difference)</cite></font></center>


  <p>Apart from basic CSG you can also obtain smooth transits between the
  different surfaces (like with the <a href="povdoc_080.html#target_132">blob object</a>)</p>

<pre>
  #declare Blob_threshold=0.01;

  isosurface {
    function {
      (1+Blob_threshold)
      -pow(Blob_threshold, fn_A(x,y,z))
      -pow(Blob_threshold, fn_B(x,y,z))
    }
    max_gradient 4
    contained_by { box { -2, 2 } }
  }
</pre>

  
<center><img src="images/iso_17.gif" alt="Isosurface sample (blob)"><br><font size=-1><cite>Isosurface sample (blob)</cite></font></center>


  <p>The <code>Blob_threshold</code> value influences the smoothness of
  the transit between the shapes.  a lower value leads to sharper edges.</p>

</div>

<div class="divh4">
<a name="target_143"></a>
<h4>3.6.3.6&nbsp;&nbsp;noise and pigment functions</h4>

  <p>Some of the <a href="#target_141">internal functions</a>
  have a random or noise-like structure</p>

  <p>Together with the pigment functions they are one of the most powerful tools
  for designing isosurfaces.  We can add real surface displacement to the objects
  rather than only normal perturbation known from the
  <a href="povdoc_207.html#target_1021">normal{} statement</a>.</p>

  <p>The relevant internal functions are:</p>

  <ul>
    <li><code>f_noise3d(x,y,z)</code><br>
    uses the <a href="povdoc_217.html#target_1153">noise generator</a> specified in
    <code>global_settings{}</code> and generates structures like the bozo pattern.</li>

    <li><code>f_noise_generator(x,y,z, noise_generator)</code><br>
    generates noise with a specified noise generator.</li>


    <li><code>f_ridged_mf(x,y,z, H, Lacunarity, Octaves, Offset, Gain, noise_generator)</code><br>
    generates a ridged multifractal pattern.</li>

    <li><code>f_ridge(x,y,z, Lambda, Octaves, Omega, Offset, Ridge, noise_generator)</code><br>
    generates another noise with ridges.</li>

    <li><code>f_hetero_mf(x,y,z, H, Lacunarity, Octaves, Offset, T, noise_generator)</code><br>
    generates heterogenic multifractal noise.</li>
  </ul>

  <p>Using pure noise3d as a function results in the following picture:</p>

  <p><code>  function { f_noise3d(x, y, z)-0.5 }</code></p>

  
<center><img src="images/iso_18.gif" alt="Isosurface sample (noise3d)"><br><font size=-1><cite>Isosurface sample (noise3d)</cite></font></center>


  <p class="Note"><strong>Note:</strong> the <code>-0.5</code> is only there to make it match to the used
  threshold value of 0, the <code>f_noise3d</code> function returns values between
  0 and 1.</p>

  <p>With this and the other functions you can generate objects similar to
  heightfields, having the advantage that a high resolution can be achieved
  without high memory requirements.</p>

  <p><code>  function { x+f_noise3d(0, y, z) }</code></p>

  
<center><img src="images/iso_19.gif" alt="Isosurface sample (noise3d 'heightfield')"><br><font size=-1><cite>Isosurface sample (noise3d 'heightfield')</cite></font></center>


  <p>The noise function can of course also be subtracted which results in an
  'inverted' version:</p>

  <p><code>  function { x-f_noise3d(0, y, z) }</code></p>

  
<center><img src="images/iso_20.gif" alt="Isosurface sample (noise3d 'heightfield' inverted)"><br><font size=-1><cite>Isosurface sample (noise3d 'heightfield' inverted)</cite></font></center>


  <p>In the last two pictures we added the noise function to a plane function.
  The x-parameter was set to 0 so the noise function is constant in x-direction.
  This way we achieve the typical heightfield structure.</p>

  <p>Of course we can also add noise to any other function.  If the noise function
  is very strong this can result in several separated surfaces.</p>

  <p><code>  function { f_sphere(x, y, z, 1.2)-f_noise3d(x, y, z) }</code></p>

  
<center><img src="images/iso_21.gif" alt="Isosurface sample (noise3d on sphere)"><br><font size=-1><cite>Isosurface sample (noise3d on sphere)</cite></font></center>


  <p>This is a noise function applied to a sphere surface, we can influence
  the intensity of the noise by multiplying it with a factor and change the
  scale by multiplying the coordinate parameters:</p>

  <p><code>  function { f_sphere(x, y, z, 1.6)-f_noise3d(x*5, y*5, z*5)*0.5 }</code></p>

  
<center><img src="images/iso_22.gif" alt="Isosurface sample (noise3d on sphere scaled)"><br><font size=-1><cite>Isosurface sample (noise3d on sphere scaled)</cite></font></center>


  <p>As alternative to noise functions we can also use any pigment in a function:</p>

<pre>
  #declare fn_Pigm=function {
    pigment {
      agate
      color_map {
        [0 color rgb 0]
        [1 color rgb 1]
      }
    }
  }
</pre>

  <p>This function is a vector function returning a (color) vector.  For use in
  isosurface functions we have to specify the component to use (for details see the
  <a href="povdoc_190.html#target_871">reference section</a>).</p>

  <p><code>  function { f_sphere(x, y, z, 1.6)-fn_Pigm(x/2, y/2, z/2).gray*0.5 }</code></p>

  
<center><img src="images/iso_23.gif" alt="Isosurface sample (pigment function)"><br><font size=-1><cite>Isosurface sample (pigment function)</cite></font></center>


  <p>There are quite a lot of things possible with pigment functions, but you
  probably have recognized that this renders quite slow.</p>


</div>

<div class="divh4">
<a name="target_144"></a>
<h4>3.6.3.7&nbsp;&nbsp;accuracy, max_gradient, etc.</h4>

 <p>To optimize the approximation of the isosurface and to get maximum
rendering speed it is important to adapt certain values (see also
<a href="povdoc_190.html#target_893">&quot;Improving Isosurface Speed&quot;</a>
in the reference section).</p>

<p><code>accuracy</code></p>

<p>The accuracy value influences how accurate the surface geometry is calculated.
Lower values lead to a more precise, but slower result.
The default value of <code>0.001</code> is fairly low. We used this value in all the
previous samples, but often you can raise this quite a
lot and thereby make things faster.</p>

<p><code>max_gradient</code></p>

<p>For finding the actual surface it is important for POV-Ray to know the
maximum gradient of the function, meaning how fast the function value changes.
We can specify a value with the <code>max_gradient</code> keyword.  Lower
max_gradient values lead to faster rendering, but if the specified value is
below the actual maximum gradient of the function, there can be holes or
other artefacts in the surface.</p>

<p>For the same reason functions with infinite gradient should not be used.
This applies for pigment functions with brick or checker pattern for example.
You should also be careful when using <code>select()</code> in isosurface
functions because of this.</p>

<p>If the real maximum gradient differs too much from the specified value
POV-Ray prints a warning together with the found maximum gradient.
It is usually sufficient to use this number for the <code>max_gradient</code>
parameter to get fast and correct results.</p>

<p>POV-Ray can also dynamically change the <code>max_gradient</code> when you
specify <code>evaluate</code> with 3 parameters the isosurface definition.
Concerning the details on this and other things see the
<a href="povdoc_190.html#target_858">reference section</a>.</p>

</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_081.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_083.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
