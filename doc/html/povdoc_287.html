<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>shapes.inc</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_1530"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_286.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_288.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>7.13.1&nbsp;&nbsp;shapes.inc</h3>

<a name="target_1531"></a>

<p><code>Isect(Pt, Dir, Obj, OPt)</code> and <code>IsectN(Pt, Dir, Obj, OPt, ONorm)</code><br>
These macros are interfaces to the trace() function. Isect() only returns the intersection point, 
IsectN() returns the surface normal as well. These macros return the point and normal information
through their parameters, and true or false depending on whether an intersection was found:<br>
If an intersection is found, they return true and set OPt to the intersection point, and ONorm 
to the normal. Otherwise they return false, and do not modify OPt or ONorm.<br>
	Parameters:
	<ul>
		<li><code>Pt</code> = The origin (starting point) of the ray.</li>
		<li><code>Dir</code> = The direction of the ray.</li>
		<li><code>Obj</code> = The object to test for intersection with.</li>
		<li><code>OPt</code> = A declared variable, the macro will set this to the intersection point.</li>
		<li><code>ONorm</code> = A declared variable, the macro will set this to the surface normal at the intersection point.</li>
	</ul>
</p>

<a name="target_1532"></a>

<p><code>Extents(Obj, Min, Max)</code>.	This macro is a shortcut for calling both min_extent() 
and max_extent() to get the corners of the bounding box of an object. It returns these values 
through the Min and Max parameters.<br>
	Parameters:
	<ul>
		<li><code>Obj</code> = The object you are getting the extents of.</li>
		<li><code>Min</code> = A declared variable, the macro will set this to the min_extent of the object.</li>
		<li><code>Max</code> = A declared variable, the macro will set this to the max_extent of the object.</li>
	</ul>
</p>

<a name="target_1533"></a>

<p><code>Center_Object(Object, Axis)</code>. A shortcut for using the Center_Trans() macro with an
 object.<br>
	Parameters:
	<ul>
		<li><code>Object</code> = The object to be centered.</li>
		<li><code>Axis</code> = See Center_Trans() in the transforms.inc documentation.</li>
	</ul>
</p>

<a name="target_1534"></a>

<p><code>Align_Object(Object, Axis, Pt)</code>. A shortcut for using the <a href="povdoc_307.html#target_1594">Align_Trans()</a> macro with an object.<br>
	Parameters:
	<ul>
		<li><code>Object</code> = The object to be aligned.</li>
		<li><code>Axis</code> = See Align_Trans() in the transforms.inc documentation.</li>
		<li><code>Point</code> = The point to which to align the bounding box of the object. </li>
	</ul>
</p>

<a name="target_1535"></a>

<p><code>Bevelled_Text(Font, String, Cuts, BevelAng, BevelDepth, Depth, Offset, UseMerge)</code>. This macro
 attempts to &quot;bevel&quot; the front edges of a text object. It accomplishes this by making an
 intersection of multiple copies of the text object, each sheared in a different direction. The
 results are no perfect, but may be entirely acceptable for some purposes. Warning: the object
 generated may render considerably more slowly than an ordinary text object.<br>
	Parameters:
	<ul>
		<li><code>Font</code> = A string specifying the font to use.</li>
		<li><code>String</code> = The text string the object is generated from.</li>
		<li><code>Cuts</code> = The number of intersections to use in bevelling the text. 
           More cuts give smoother results, but take more memory and are slower rendering.</li>
		<li><code>BevelAng</code> = The angle of the bevelled edge.</li>
		<li><code>BevelDepth</code> = The thickness of the bevelled portion.</li>
		<li><code>Depth</code> = The total thickness of the resulting text object.</li>
		<li><code>Offset</code> = The offset parameter for the text object. The z value 
          of this vector will be ignored, because the front faces of all the letters need 
          to be coplanar for the bevelling to work.</li>
		<li><code>UseMerge</code> = Switch between merge (1) and union (0).</li>
	</ul>
</p>

<a name="target_1536"></a>

<p><code>Text_Space(Font, String, Size, Spacing)</code>. Computes the width of a text string,
 including &quot;white space&quot;, it returns the advance widths of all n letters. Text_Space
 gives the space a text, or a glyph, occupies in regard to its surroundings.<br>
	Parameters:
	<ul>
		<li><code>Font</code> = A string specifying the font to use.</li>
		<li><code>String</code> = The text string the object is generated from.</li>
		<li><code>Size</code> = A scaling value.</li>
 		<li><code>Spacing</code> = The amount of space to add between the characters.</li>
	</ul>
</p>

<a name="target_1537"></a>

<p><code>Text_Width(Font, String, Size, Spacing)</code>. Computes the width of a text
string, it returns the advance widths of the first n-1 letters, plus the glyph width
of the last letter.  Text_Width gives the &quot;fysical&quot; width of the text and if you use only 
one letter the &quot;fysical&quot; width of one glyph.
<br>
	Parameters:
	<ul>
		<li><code>Font</code> = A string specifying the font to use.</li>
		<li><code>String</code> = The text string the object is generated from.</li>
		<li><code>Size</code> = A scaling value.</li>
 		<li><code>Spacing</code> = The amount of space to add between the characters.</li>
	</ul>
</p>

<p><code>Align_Left, Align_Right, Align_Center</code>. These constants are used by the
 <code>Circle_Text()</code> macro.
</p>

<a name="target_1538"></a>

<p><code>Circle_Text(Font, String, Size, Spacing, Depth, Radius, Inverted, Justification, Angle)</code>. Creates a text object with the bottom (or top) of the character cells aligned with all or part of a circle.
This macro should be used inside an <code>object{...}</code> block.<br>
		Parameters:
		<ul>
			<li><code>Font</code> = A string specifying the font to use.</li>
			<li><code>String</code> = The text string the object is generated from.</li>
			<li><code>Size</code> = A scaling value.</li>
			<li><code>Spacing</code> = The amount of space to add between the characters.</li>
			<li><code>Depth</code> = The thickness of the text object.</li>
			<li><code>Radius</code> = The radius of the circle the letters are aligned to.</li>
			<li><code>Inverted</code> = Controls what part of the text faces &quot;outside&quot;. 
                If this parameter is nonzero, the tops of the letters will point toward the center 
                of the circle.  Otherwise, the bottoms of the letters will do so.</li>
			<li><code>Justification</code> = Align_Left, Align_Right, or Align_Center.</li>
			<li><code>Angle</code> = The point on the circle from which rendering will begin. The +x
                direction is 0 and the +y direction is 90 (i.e. the angle increases
                anti-clockwise).</li>
		</ul>
</p>


<a name="target_1539"></a>

<p><code>Wedge(Angle)</code>. This macro creates an infinite wedge shape, an intersection of two planes. It is mainly useful in CSG, for example to obtain a specific arc of a torus. The edge of the wedge is positioned along the y axis, and one side is fixed to the zy plane, the other side rotates clockwise around the y axis.<br>
		Parameters:
		<ul>
			<li><code>Angle</code> = The angle, in degrees, between the sides of the wedge shape.</li>
		</ul>
</p>

<a name="target_1540"></a>

<p><code>Spheroid(Center, Radius)</code>. This macro creates an unevenly scaled sphere. Radius is a vector where each component is the radius along that axis.<br>
		Parameters:
		<ul>
			<li><code>Center</code> = Center of the spheroid.</li>
			<li><code>Radius</code> = A vector specifying the radii of the spheroid.</li>
		</ul>
</p>

<a name="target_1541"></a>

<p><code>Supertorus(MajorRadius, MinorRadius, MajorControl, MinorControl, Accuracy, MaxGradient)</code>. This macro creates an isosurface of the torus equivalent of a superellipsoid. If you specify a MaxGradient of less than 1, evaluate will be used. You will have to adjust MaxGradient to fit the parameters you choose, a squarer supertorus will have a higher gradient. You may want to use the function alone in your own isosurface.<br>
		Parameters:
		<ul>
			<li><code>MajorRadius, MinorRadius</code> = Base radii for the torus.</li>
			<li><code>MajorControl, MinorControl</code> = Controls for the roundness of the supertorus. Use numbers in the range [0, 1].</li>
			<li><code>Accuracy</code> = The accuracy parameter.</li>
			<li><code>MaxGradient</code> = The max_gradient parameter.</li>
		</ul>
</p>

<a name="target_1542"></a>

<p><code>Supercone(EndA, A, B, EndB, C, D)</code>. This macro creates an object similar to a cone, 
but where the end points are ellipses. The actual object is an intersection of a quartic with a 
cylinder.<br>
		Parameters:
		<ul>
			<li><code>EndA</code> = Center of end A.</li>
			<li><code>A, B</code> = Controls for the radii of end A.</li>
			<li><code>EndB</code> = Center of end B.</li>
			<li><code>C, D</code> = Controls for the radii of end B.</li>
		</ul>
</p>

<a name="target_1543"></a>

<p><code>Connect_Spheres(PtA, RadiusA, PtB, RadiusB)</code>. This macro creates a cone that
 will smoothly join two spheres. It creates only the cone object, however, you will have to
 supply the spheres yourself or use the Round_Cone2() macro instead.<br>
		Parameters:
		<ul>
			<li><code>PtA</code> = Center of sphere A.</li>
			<li><code>RadiusA</code> = Radius of sphere A.</li>
			<li><code>PtB</code> = Center of sphere B.</li>
			<li><code>RadiusB</code> = Radius of sphere B.</li>
		</ul>
</p>

<a name="target_1544"></a>

<P><code>Wire_Box_Union(PtA, PtB, Radius),<br>
Wire_Box_Merge(PtA, PtB, Radius),<br>
Wire_Box(PtA, PtB, Radius, UseMerge)</code>.	Creates a wire-frame box from cylinders and spheres.
 The resulting object will fit entirely within a box object with the same corner points.<br>
		Parameters:
		<ul>
			<li><code>PtA</code> = Lower-left-front corner of box.</li>
			<li><code>PtB</code> = Upper-right-back corner of box.</li>
			<li><code>Radius</code> = The radius of the cylinders and spheres composing the object.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1545"></a>

<p><code>Round_Box_Union(PtA, PtB, EdgeRadius),<br>
Round_Box_Merge(PtA, PtB, EdgeRadius),<br>
Round_Box(PtA, PtB, EdgeRadius, UseMerge)</code>. Creates a box with rounded edges from boxes, 
cylinders and spheres. The resulting object will fit entirely within a box object with the 
same corner points. The result is slightly different from a superellipsoid, which has no 
truely flat areas.<br>
		Parameters:
		<ul>
			<li><code>PtA</code> = Lower-left-front corner of box.</li>
			<li><code>PtB</code> = Upper-right-back corner of box.</li>
			<li><code>EdgeRadius</code> = The radius of the edges of the box.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1546"></a>

<p><code>Round_Cylinder_Union(PtA, PtB, Radius, EdgeRadius),<br>
Round_Cylinder_Merge(PtA, PtB, Radius, EdgeRadius),<br>
Round_Cylinder(PtA, PtB, Radius, EdgeRadius, UseMerge)</code>. Creates a cylinder with rounded 
edges from cylinders and tori. The resulting object will fit entirely within a cylinder 
object with the same end points and radius. The result is slightly different from a 
superellipsoid, which has no truely flat areas.<br>
		Parameters:
		<ul>
			<li><code>PtA, PtB</code> = The end points of the cylinder.</li>
			<li><code>Radius</code> = The radius of the cylinder.</li>
			<li><code>EdgeRadius</code> = The radius of the edges of the cylinder.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1547"></a>

<p><code>Round_Cone_Union(PtA, RadiusA, PtB, RadiusB, EdgeRadius),<br>
Round_Cone_Merge(PtA, RadiusA, PtB, RadiusB, EdgeRadius),<br>
Round_Cone(PtA, RadiusA, PtB, RadiusB, EdgeRadius, UseMerge)</code> Creates a cone with rounded 
edges from cones and tori. The resulting object will fit entirely within a cone object with 
the same end points and radii.<br>
		Parameters:
		<ul>
			<li><code>PtA, PtB</code> = The end points of the cone.</li>
			<li><code>RadiusA, RadiusB</code> = The radii of the cone.</li>
			<li><code>EdgeRadius</code> = The radius of the edges of the cone.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1548"></a>

<p><code>Round_Cone2_Union(PtA, RadiusA, PtB, RadiusB),<br>
Round_Cone2_Merge(PtA, RadiusA, PtB, RadiusB),<br>
Round_Cone2(PtA, RadiusA, PtB, RadiusB, UseMerge)</code>. Creates a cone with rounded edges
 from a cone and two spheres. The resulting object will not fit entirely within a cone object
 with the same end points and radii because of the spherical caps. The end points are not used
 for the conical portion, but for the spheres, a suitable cone is then generated to smoothly
 join them.<br>
		Parameters:
		<ul>
			<li><code>PtA, PtB</code> = The centers of the sphere caps.</li>
			<li><code>RadiusA, RadiusB</code> = The radii of the sphere caps.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1549"></a>

<p><code>Round_Cone3_Union(PtA, RadiusA, PtB, RadiusB),<br>
Round_Cone3_Merge(PtA, RadiusA, PtB, RadiusB)<br>
Round_Cone3(PtA, RadiusA, PtB, RadiusB, UseMerge)</code>. Like Round_Cone2(), this creates a
 cone with rounded edges from a cone and two spheres, and the resulting object will not fit
 entirely within a cone object with the same end points and radii because of the spherical
 caps. The difference is that this macro takes the end points of the conical portion and moves 
 the spheres to be flush with the surface, instead of putting the spheres at the end points and
 generating a cone to join them.<br>
		Parameters:
		<ul>
			<li><code>PtA, PtB</code> = The end points of the cone.</li>
			<li><code>RadiusA, RadiusB</code> = The radii of the cone.</li>
			<li><code>UseMerge</code> = Whether or not to use a merge.</li>
		</ul>
</p>

<a name="target_1550"></a>

<p><code>Quad(A, B, C, D)</code> and <code>Smooth_Quad(A, NA, B, NB, C, NC, D, ND)</code>. These macros
 create &quot;quads&quot;, 4-sided polygonal objects, using triangle pairs.<br>
		Parameters:
		<ul>
			<li><code>A, B, C, D</code> = Vertices of the quad.</li>
			<li><code>NA, NB, NC, ND</code> = Vertex normals of the quad.</li>
		</ul>
</p>


</div>

<div class="divh4">
<a name="target_1551"></a>
<h4>7.13.1.1&nbsp;&nbsp;The HF Macros</h4>

<p>There are several HF macros in shapes.inc, which generate meshes in various
shapes. All the HF macros have these things in common: </p>
<ul>
  <li>The HF macros do not directly use an image for input, but evaluate a user-defined function. The macros deform the surface based on the function values.</li>
  <li>The macros can either write to a file to be included later, or create an object
directly. If you want to output to a file, simply specify a filename. If you
want to create an object directly, specify &quot;&quot; as the file name (an empty
string).</li>
  <li>The function values used for the heights will be taken from the square
that goes from  &lt;0,0,0&gt; to &lt;1,1,0&gt; if UV height mapping is on.
Otherwise the function values will be taken from the points where the surface is (before the deformation).</li>
  <li>The texture you apply to the shape will be evaluated in the square
that goes from &lt;0,0,0&gt; to &lt;1,1,0&gt; if UV texture mapping is on. Otherwise the texture is evaluated at the points where the surface is (after the
deformation.</li>
</ul>
<p>The usage of the different HF macros is
described below.</p>

<a name="target_1552"></a>

<p><code>HF_Square (Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, MnExt, MxExt)</code>. This macro
generates a mesh in the form of a square height field, similar to the
built-in height_field primitive. Also see the general description of the HF
macros above.<br>

Parameters:
		<ul>
			<li><code>Function</code> = The function to use for deforming the height field.</li>
      <li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
      <li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
			<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
			<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
			<li><code>FileName</code> = The name of the output file.</li>
			<li><code>MnExt</code> = Lower-left-front corner of a box containing the height field.</li>
			<li><code>MxExt</code> = Upper-right-back corner of a box containing the height field.</li>
		</ul>
</p>

<a name="target_1553"></a>

<p><code>HF_Sphere(Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, Center, Radius, Depth)</code>. 
This macro generates a mesh in the form of a spherical height field. When
UV-mapping is used, the UV square will be wrapped around the sphere starting
at +x and going anti-clockwise around the y axis. Also see the general
description of the HF macros above.
Parameters:
		<ul>
			<li><code>Function</code> = The function to use for deforming the height field.</li>
      <li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
      <li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
			<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
			<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
			<li><code>FileName</code> = The name of the output file.</li>
      <li><code>Center</code> = The center of the height field before being displaced, the displacement can, and most likely will, make the object off-center.</li>
			<li><code>Radius</code> = The starting radius of the sphere, before being displaced.</li>
			<li><code>Depth</code> = The depth of the height field.</li>
		</ul>
</p>

<a name="target_1554"></a>

<p><code>HF_Cylinder(Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, EndA, EndB, Radius,Depth)</code>. 
This macro generates a mesh in the form of an open-ended cylindrical
height field. When UV-mapping is used, the UV square will be wrapped around
the cylinder. Also see the general description of the HF macros above.<br>
Parameters:
		<ul>
			<li><code>Function</code> = The function to use for deforming the height field.</li>
      <li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
      <li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
			<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
			<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
			<li><code>FileName</code> = The name of the output file.</li>
         <li><code>EndA, EndB</code> = The end points of the cylinder.</li>
			<li><code>Radius</code> = The (pre-displacement) radius of the cylinder.</li>
			<li><code>Depth</code> = The depth of the height field.</li>
		</ul>
</p>

<a name="target_1555"></a>

<p><code>HF_Torus (Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, Major, Minor, Depth)</code>. This
macro generates a mesh in the form of a torus-shaped height field. When
UV-mapping is used, the UV square is wrapped around similar to spherical or
cylindrical mapping. However the top and bottom edges of the map wrap over
and under the torus where they meet each other on the inner rim. Also see
the general description of the HF macros above.<br>
Parameters:
   <ul>
      <li><code>Function</code> = The function to use for deforming the height field.</li>
      <li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
      <li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
      <li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
      <li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
      <li><code>FileName</code> = The name of the output file.</li>
      <li><code>Major</code> = The major radius of the torus.</li>
      <li><code>Minor</code> = The minor radius of the torus.</li>
   </ul>
</p>



</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_286.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_288.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
