<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Ray-sphere intersection</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_273"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_136.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_138.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>4.2.7&nbsp;&nbsp;Ray-sphere intersection</h3>

<pre>
#macro calcRaySphereIntersection(P, D, sphereInd)
  #local V = P-Coord[sphereInd][0];
  #local R = Coord[sphereInd][1].x;

  #local DV = vdot(D, V);
  #local D2 = vdot(D, D);
  #local SQ = DV*DV-D2*(vdot(V, V)-R*R);
  #if(SQ &lt; 0) #local Result = -1;
  #else
    #local SQ = sqrt(SQ);
    #local T1 = (-DV+SQ)/D2;
    #local T2 = (-DV-SQ)/D2;
    #local Result = (T1&lt;T2 ? T1 : T2);
  #end
  Result
#end
</pre>


<p>This is the core of the whole raytracing process.</p>

<p>First let's see how a macro works (if you know it, just skip the
following section):</p>

</div>

<div class="divh4">
<a name="target_274"></a>
<h4>4.2.7.1&nbsp;&nbsp;Inner workings of a #macro</h4>

<p>A macro works like a substitution command (similar to the #define macros
in the C programming language). The body of the macro is in practice inserted in the place where
the macro is called. For example you can use a macro like this:</p>

<pre>
#macro UnitSphere()
  sphere { 0,1 }
#end

object { UnitSphere() pigment { rgb 1 } }
</pre>


<p>The result of this code is, in effect, as if you had written:</p>

<pre>
object { sphere { 0,1 } pigment { rgb 1 } }
</pre>


<p>Of course there's no reason in making this, as you could have just #declared
the <code>UnitSphere</code> as a sphere of radius 1. However, the power of
macros kick in when you start using macro parameters. For example:</p>

<pre>
#macro Sphere(Radius)
  sphere { 0, Radius }
#end

object { Sphere(3) pigment { rgb 1 } }
</pre>


<p>Now you can use the macro <code>Sphere</code> to create a sphere with
the specified radius. Of course this doesn't make much sense either, as
you could just write the sphere primitive directly because it's so short,
but this example is intentionally short to show how it works; the macros
become very handy when they create something much more complicated than
just a sphere.</p>

<p>There's one important difference between POV-Ray macros and real
substitution macros: Any <code>#local</code> statement inside the macro
definition will be parsed at the visibility level of the macro only, that
is, it will have no effect on the environment where the macro was called
from. The following example shows what I'm talking about:</p>

<pre>
#macro Sphere(Radius)
  #local Color = &lt;1,1,1&gt;;
  sphere { 0, Radius pigment { rgb Color } }
#end

#declare Color = &lt;1,0,0&gt;;
object { Sphere(3) }
   // 'Color' is still &lt;1,0,0&gt; here, 
   // thus the following box will be red:
box { -1,1 pigment { rgb Color } }
</pre>


<p>In the example above, although the macro creates a local identifier
called <code>Color</code> and there's an identifier with the same name
at global level, the local definition doesn't affect the global one.
Also even if there wasn't any global definition of <code>Color</code>,
the one inside the macro is not seen outside it.</p>

<p>There's one important exception to this, and this is one of the most
powerful features of macros (thanks to this they can be used as if they
were functions): If an identifier (be it local or global) appears alone
in the body of a macro (usually at the end), its value will be passed
outside the macro (as if it was a return value). The following example
shows how this works:</p>

<pre>
#macro Factorial(N)
  #local Result = 1;
  #local Ind = 2;
  #while(Ind &lt;= N)
    #local Result = Result*Ind;
    #local Ind = Ind+1;
  #end
  Result
#end

#declare Value = Factorial(5);
</pre>


<p>Although the identifier <code>Result</code> is local to the macro, its
value is passed as if it was a return value because of the last line of
the macro (where <code>Result</code> appears alone) and thus the identifier
<code>Value</code> will be set to the factorial of 5.</p>

</div>

<div class="divh4">
<a name="target_275"></a>
<h4>4.2.7.2&nbsp;&nbsp;The ray-sphere intersection macro</h4>

<p>Here is again the macro at the beginning of the page so that you don't
have to scroll so much in order to see it:</p>

<pre>
#macro calcRaySphereIntersection(P, D, sphereInd)
  #local V = P-Coord[sphereInd][0];
  #local R = Coord[sphereInd][1].x;

  #local DV = vdot(D, V);
  #local D2 = vdot(D, D);
  #local SQ = DV*DV-D2*(vdot(V, V)-R*R);
  #if(SQ &lt; 0) #local Result = -1;
  #else
    #local SQ = sqrt(SQ);
    #local T1 = (-DV+SQ)/D2;
    #local T2 = (-DV-SQ)/D2;
    #local Result = (T1&lt;T2 ? T1 : T2);
  #end
  Result
#end
</pre>


<p>The idea behind this macro is that it takes a starting point (ie. the
starting point of the ray) a direction vector (the direction where the
ray is shot) and an index to the sphere definition array defined previously.
The macro returns a factor value; this value expresses how much we have to
multiply the direction vector in order to hit the sphere.</p>

<p>This means that if the ray hits the specified sphere, the intersection
point will be located at:<br>
<code>StartingPoint + Result*Direction</code></p>

<p>The return value can be negative, which means that the intersection
point was actually behind the starting point. A negative value will be
just ignored, as if the ray didn't hit anything. We can use this to make
a little trick (which may seem obvious when said, but not so obvious when
you have to figure it out for yourself): If the ray actually doesn't hit
the sphere, we return just a negative value (doesn't really matter which).</p>

<p>And how does the macro do it? What's the theory behind those
complicated-looking mathematical expressions?</p>

<p>I'll use a syntax similar to POV-Ray syntax to express mathematical
formulas here since that's probably the easiest way of doing it.</p>

<p>Let's use the following letters:</p>

<p>
<code>P</code> = Starting point of the ray<br>
<code>D</code> = Direction of the ray<br>
<code>C</code> = Center of the sphere<br>
<code>R</code> = Radius of the sphere
</p>

<p>The theory behind the macro is that we have to see what is the value
<code>T</code> for which holds that:</p>

<p><code>vlength(P+T*D-C) = R</code></p>

<p>This means: The length of the vector between the center of the sphere
(<code>C</code>) and the intersection point (<code>P+T*D</code>) is equal
to the radius (<code>R</code>).</p>

<p>If we use an additional letter so that:</p>

<p><code>V = P-C</code></p>

<p>then the formula is reduced to:</p>

<p><code>vlength(T*D+V) = R</code></p>

<p>which makes our life easier. This formula can be opened as:</p>

<p><code>(T*D<sub>x</sub>+V<sub>x</sub>)<sup>2</sup> + 
(T*D<sub>y</sub>+V<sub>y</sub>)<sup>2</sup> + 
(T*D<sub>z</sub>+V<sub>z</sub>)<sup>2</sup> - R<sup>2</sup> = 0</code></p>

<p>Solving <code>T</code> from that is rather trivial math. We get a
2nd order polynomial which has two solutions (I'll use the &quot;&#183;&quot; symbol
to represent the dot-product of two vectors):</p>

<p><code>T = (-D&#183;V &#177; sqrt((D&#183;V)<sup>2</sup> - D<sup>2</sup>(V<sup>2</sup>-R<sup>2</sup>))) / D<sup>2</sup></code></p>

<p class="Note"><strong>Note:</strong> <code>D<sup>2</sup></code> means actually
<code>D&#183;D</code>)</p>

<p>When the discriminant (ie. the expression inside the square root) is
negative, the ray does not hit the sphere and thus we can return a negative
value (the macro returns -1). We must check this in order to avoid the
<i>square root of a negative number</i> error; as it has a very logical
meaning in this case, the checking is natural.</p>

<p>If the value is positive, there are two
solutions (or just one if the value is zero, but that doesn't really
matter here), which corresponds to the two intersection points of the
ray with the sphere.</p>

<p>As we get two values, we have to return the one which is smaller (the
closest intersection). This is what this portion of the code does:</p>

<pre>
    #local Result = (T1&lt;T2 ? T1 : T2);
</pre>


<p class="Note"><strong>Note:</strong> this is an incomplete algorithm: If one value is negative
and the other positive (this happens when the starting point is inside
the sphere), we would have to return the positive one. The way it is now
results in that we will not see the inner surface of the sphere if we
put the camera inside one.</p>

<p>For our simple scene this is enough as we don't put our camera inside
a sphere nor we have transparent spheres. We could add a check there
which looks if one of the values is positive and the other negative and
returns the positive one. However, this has an odd and very annoying
result (you can try it if you want). This is most probably caused by
the inaccuracy of floating point numbers and happens when calculating
reflections (the starting point is exactly on the surface of the sphere).
We could correct these
problems by using epsilon values to get rid of accuracy problems, but
in our simple scene this will not be necessary. </p>


</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_136.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_138.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
