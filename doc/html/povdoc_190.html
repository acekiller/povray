<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Isosurface Object</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_857"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_189.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_191.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>6.5.4&nbsp;&nbsp;Isosurface Object</h3>

<p>An isosurface is a very versatile object. Mathematically its surface is defined by
a function. If there is a way to describe a surface with a function, it can also be rendered
as an isosurface object.
<br>This object also allows for real deformations and surface displacements.</p>

<p> All points which are tested against a defined function and equal a required threshold value,
belong to the object's surface.
It is obvious that POV-Ray couldn't test all points in infinite space, since it would take forever.
To speed things up, points are sampled within a defined area and within a specified accuracy
range. Then the surface is created by interpolation between the matching points.
This means that an isosurface is an approximation (accuracy depending on the
settings) of the exact location of the function's surface. But for the vast majority
of scenes this is more than accurate enough.</p>

</div>

<div class="divh4">
<a name="target_858"></a>
<h4>6.5.4.1&nbsp;&nbsp;Isosurface Syntax</h4>

<p>The syntax for the isosurface is:</p>

<pre>
isosurface {
  function { FUNCTION_ITEMS }
  [contained_by { SPHERE | BOX }]
  [threshold FLOAT_VALUE]
  [accuracy FLOAT_VALUE]
  [max_gradient FLOAT_VALUE]
  [evaluate P0, P1, P2]
  [open]
  [max_trace INTEGER] | [all_intersections]
  [OBJECT_MODIFIERS...]
}
</pre>

<p>
Isosurface default values:
<a name="target_859"></a>
<pre>
contained_by : box{-1,1}
threshold    : 0.0
accuracy     : 0.001
max_gradient : 1.1
</pre>
</p>

<p><code>function { ... }</code> This must be specified and be the first item of the
<code>isosurface</code> statement. Here you place all the mathematical functions that
will describe the surface.</p>

<a name="target_860"></a>

<a name="target_861"></a>
<p><code>contained_by { ... }</code> The <code>contained_by</code> 'object' limits the
area where POV-Ray samples for the surface of the function. This container can either be a
sphere or a box, both of which use the standard POV-Ray syntax. If not specified a
<code>box {&lt;-1,-1,-1&gt;, &lt;1,1,1&gt;}</code> will be used as default.</p>
<pre>
contained_by { sphere { CENTER, RADIUS } }
contained_by { box { CORNER1, CORNER2 } }
</pre>

<a name="target_862"></a>

<p><code>threshold</code> This specifies how much strength, or substance to give the
<code>isosurface</code>. The surface appears where the <code>function</code> value
equals the <code>threshold</code> value. The default threshold is 0.</p>
<pre>function = threshold</pre>

<a name="target_863"></a>

<p><code>accuracy</code> The isosurface finding method is a recursive subdivision method.
This subdivision goes on until the length of the interval where POV-Ray finds a surface
point is less than the specified <code>accuracy</code>. The default value is 0.001.
<br>Smaller values produces more accurate surfaces, but it takes longer to render.

<a name="target_864"></a>

<a name="target_865"></a>
<p><code>max_gradient</code> POV-Ray can find the first intersecting point between a ray and
the <code>isosurface</code> of any continuous function if the maximum gradient of the function
is known.  Therefore you can specify a <code>max_gradient</code> for the function.
The default value is 1.1.  When the <code>max_gradient</code> used to find the
intersecting point is too high, the render slows down considerably. When it is too
low, artefacts or holes may appear on the isosurface. When it is way too low, the surface
doesn't show at all.  While rendering the isosurface POV-Ray records the found gradient values
and prints a warning if these values are higher or much lower than the specified
<code>max_gradient</code>:

<pre>
Warning: The maximum gradient found was 5.257, but max_gradient of
the isosurface was set to 5.000. The isosurface may contain holes!
Adjust max_gradient to get a proper rendering of the isosurface.
</pre>

<pre>
Warning: The maximum gradient found was 5.257, but max_gradient of
the isosurface was set to 7.000. Adjust max_gradient to
get a faster rendering of the isosurface.
</pre>

For best performance you should specify a value close to the real maximum gradient.</p>

<a name="target_866"></a>

<a name="target_867"></a>
<p><code>evaluate</code> POV-Ray can also dynamically adapt the used max_gradient.
To activate this technique you have to specify the <code>evaluate</code> keyword
followed by three parameters:</p>
<ul>
 <li>&nbsp;&nbsp;P0: the minimum max_gradient in the estimation process,</li>
 <li>&nbsp;&nbsp;P1: an over-estimating factor. This means that the max_gradient is 
 multiplied by the P1 parameter.</li>
 <li>&nbsp;&nbsp;P2: an attenuation parameter (1 or less)</li>
</ul>
<p>In this case POV-Ray starts with the <code>max_gradient</code> value <code>P0</code>
and dynamically changes it during the render using <code>P1</code> and <code>P2</code>.
In the evaluation process, the P1 and P2 parameters are used in
quadratic functions. This means that over-estimation increases more
rapidly with higher values and attenuation more rapidly with lower
values. Also with dynamic <code>max_gradient</code>, there can be artefacts and holes.</p>

<p>If you are unsure what values to use, start a render without <code>evaluate</code> to get a value for <code>max_gradient</code>. Now you can use it with <code>evaluate</code> like this:
  <ul>
    <li>P0 : found max_gradient * min_factor<br>
    'min_factor' being a float between 0 and 1 to reduce the
    <code>max_gradient</code> to a 'minimum max_gradient'. The ideal value for P0
    would be the average of the found max_gradients, but we do not
    have access to that information.<br>
    A good starting point is 0.6 for the min_factor</li>
    <li>P1 : sqrt(found max_gradient/(found max_gradient * min_factor))<br>
    'min_factor' being the same as used in P0
    this will give an over-estimation factor of more than 1, based
    on your minimum max_gradient and the found max_gradient.</li>
    <li>P2 : 1 or less<br>
    0.7 is a good starting point.</li>
  </ul>
  When there are artifacts / holes in the isosurface, increase the min_factor and / or P2 a bit.
  Example: when the first run gives a found max_gradient of 356, start with
  <pre>
  #declare Min_factor= 0.6;
  isosurface {
     ...
     evaluate 356*Min_factor,  sqrt(356/(356*Min_factor)),  0.7
     //evaluate 213.6, 1.29, 0.7
     ...
   }
</pre>

This method is only an approximation of what happens internally, but it
gives faster rendering speeds with the majority of isosurfaces.</p>

<a name="target_868"></a>

<p><code>open</code> When the isosurface isn't fully contained within the contained_by object,
there will be a cross section. Where this happens, you will see the surface of the container.
With the <code>open</code> keyword, these cross section surfaces are removed. The inside of the isosurface
becomes visible.</p>
<p class="Note"><strong>Note:</strong> that <code>open</code> slows down the render speed.
Also, it is not recommended to use it with CSG operations.</p>

<a name="target_869"></a>

<a name="target_870"></a>

<p><code>max_trace</code> Isosurfaces can be used in CSG shapes since they are solid finite objects
 - if not finite by themselves, they are through the cross section with the container.
<br>By default POV-Ray searches only for the first surface which the ray intersects. But when using an
<code>isosurface</code> in CSG operations, the other surfaces must also be found. Therefore, 
the keyword <code>max_trace</code> must be added to the <code>isosurface</code> statement. 
It must be followed by an integer value. To check for all surfaces, use the keyword <code>all_intersections</code> instead.
<br>With <code>all_intersections</code> POV-Ray keeps looking until all surfaces are found.
With a <code>max_trace</code> it only checks until that number is reached.</p>

</div>

<div class="divh4">
<a name="target_871"></a>
<h4>6.5.4.2&nbsp;&nbsp;Functions in Isosurface</h4>

<p>The functions used to define the isosurface are written in the <code>function{...}</code> block.</p>

<p>Allowed are:</p>
<p>User defined functions (like equations). All float expressions and operators (see section
&quot;<a href="povdoc_161.html#target_624">User-Defined Functions</a>&quot;) which are legal
in POV-Ray, can be used.
<br>With the equation of a sphere &quot;<code>x^2+y^2+z^2 = Threshold</code>&quot; we get:</p>
<pre>
isosurface {
function {pow(x,2) + pow(y,2) + pow(z,2)}
  threshold Threshold
  ...
}
</pre>

<p>Functions can be declared first (see section &quot;<a href="povdoc_161.html#target_624">Declaring Functions</a>&quot;) and
then used in the isosurface.</p>
<pre>
#declare Sphere = function {pow(x,2) + pow(y,2) + pow(z,2)}
isosurface {
  function { Sphere(x,y,z) }
  threshold Threshold
  ...
}
</pre>

<p>By default a function takes three parameters (x,y,z) and you do not have to explicitly specify
 the parameter names when declaring it. 
<br>When <em>using</em> the identifier, the parameters <em>must</em> be specified.
<br>On the other hand, if you need more or less than three parameters when declaring a function, you also have
to explicitly specify the parameter names.
<pre>
#declare Sphere = function(x,y,z,Radius) {
    pow(x,2) + pow(y,2) + pow(z,2) - pow(Radius,2) 
}
isosurface {
  function { Sphere(x,y,z,1) }
  ...
}
</pre>

<p>To make it easier for you, POV-Ray has a large amount of pre-defined functions. These are mainly algebraic surfaces
but there is also a mesh function and noise3d function. See section &quot;<a href="povdoc_082.html#target_141">Internal Functions</a>&quot;
for a complete list and some explanation on the parameters to use. These internal functions
can be included through the <code>functions.inc</code> include file.
<br>For the internal paraboloid shape, use:</p>
<pre>
#include &quot;functions.inc&quot;
isosurface {
  function  { f_paraboloid(x,y,z, -1) }
  ...
}
</pre>

<p>Since pigments can be declared as functions, they can also be used in isosurfaces. They <em>must</em> be
declared first. When using the identifier, you have to specify which component of the color vector should be used.
To do this, the dot notation is used:  <code>Function(x,y,z).red</code></p>
<pre>
#declare FBozo = function { 
    pigment { bozo color_map { [0 rgb 0] [1 rgb 1] }}
}
isosurface {
  function  { FBozo(x,y,z).gray }
  ...
}
</pre>

<p>A color vector has five components. Supported dot types to access these components are:
<ul>
 <li>F( ).<code>x</code> | F( ).<code>u</code> | F( ).<code>red</code>
  <ul><li>to get the red value of the color vector</li>
  </ul></li>
 <li>F( ).<code>y</code> | F( ).<code>v</code> | F( ).<code>green</code>
  <ul><li>to get the green value of the color vector</li>
  </ul></li>
 <li>F( ).<code>z</code> | F( ).<code>blue</code>
  <ul><li>to get the blue value of the color vector</li>
  </ul></li>
 <li>F( ).<code>filter</code> | F( ).<code>t</code>
  <ul><li>to get the filter value of the color vector</li>
  </ul></li>
 <li>F( ).<code>transmit</code>
  <ul><li>to get the transmit value of the color vector</li>
  </ul></li>
 <li>F( ).<code>gray</code>
 <ul>
  <li>to get the gray value of the color vector</li>
  <li>gray value = Red*29.7% + Green*58.9% + Blue*11.4%</li>
 </ul></li>
 <li>F( ).<code>hf</code>
 <ul>
  <li>to get the height_field value of the color vector</li>
  <li>hf value = (Red + Green/255)*0.996093  </li>
  <li>the .hf operator is experimental and will generate a warning.</li>
 </ul></li>
</ul>
</p>

<p>Conditional directives are allowed</p>
<pre>
#declare Rough = yes;
#include &quot;functions.inc&quot;
isosurface {
  function { y #if(Rough=1)-f_noise3d(x/0.5,y/0.3,z/0.4)*0.8 #end }
  ...
}
</pre>

<p>Loops can also be used in functions:</p>
<pre>
#include &quot;functions.inc&quot;
#declare Thr = 1/1000;
#declare Ang = radians(45);
#declare Offset = 1.5;
#declare Scale = 1.2;
#declare TrSph = function { f_sphere(x-Offset,y,z,0.7*Scale) }

function {
  (1-Thr)
  #declare A = 0;
  #while (A&lt;8)
  -pow(Thr, TrSph(x*cos(A*Ang) + y*sin(A*Ang),
                  y*cos(A*Ang) -x*sin(A*Ang), z) )
    #declare A=A+1;
  #end
}
</pre>

<p>Of course functions can be combined and parameters can be substituted. Learn more
about it in the next sections</p>

</div>

<div class="divh4">
<a name="target_872"></a>
<h4>6.5.4.3&nbsp;&nbsp;Transformations on Functions</h4>

<p>Transforming an isosurface object is done like transforming any POV-Ray object.
Simply use the object modifiers (scale, translate, rotate, ...).</p>

<p>However, when you want to transform functions within the contained_by object, you have to substitute
parameters in the functions.</p>

<p>The results <em>seem</em> inverted to what you would normally expect. Here is an explanation:
<br>Take a Sphere(x,y,z). We know it sits at the origin because x=0. When we want it at x=2 (translating
2 units to the right) we need to write the second equation in the same form: x-2=0
<br>Now that both equations equal 0, we can replace parameter x with x-2
<br>So our Sphere(x-2, y,z) moves two units to the <em>right</em>.</p>
<p>Let's scale our Sphere 0.5 in the y direction. Default size is y=1 (one unit). We want y=0.5.
<br>To get this equation in the same form as the first one, we have to multiply both sides by
two. y*2 = 0.5*2, which gives y*2=1
<br>Now we can replace the y parameter in our sphere: Sphere(x, y*2, z). This squishes the y-size of the
sphere by half.
<br>Well, this is the general idea of substitutions.</p>

<p>Here's an overview of some useful substitutions:
<br>Using a declared object P(x,y,z)</p>

</div>

<div class="divh5">
<a name="target_873"></a>
<h5>6.5.4.3.1&nbsp;&nbsp;Functions, Scale</h5>
<a name="target_874"></a>
<p>scale x : replace &quot;<code>x</code>&quot; with &quot;<code>x/scale</code>&quot; (idem other parameters)</p>
<pre>scale x*2   gives    P(x/2,y,z)</pre>

</div>

<div class="divh5">
<a name="target_875"></a>
<h5>6.5.4.3.2&nbsp;&nbsp;Scale Infinitely</h5>
<p>scale x infinitely : replace &quot;<code>x</code>&quot; with &quot;<code>0</code>&quot; (idem other parameters)</p>
<pre>scale y infinitely   gives    P(x,0,z)</pre>

</div>

<div class="divh5">
<a name="target_876"></a>
<h5>6.5.4.3.3&nbsp;&nbsp;Functions, Translate</h5>
<p>translate x : replace &quot;<code>x</code>&quot; with &quot;<code>x - translation</code>&quot; (idem other parameters)</p>
<pre>translate z*3   gives    P(x,y,z-3)</pre>

</div>

<div class="divh5">
<a name="target_877"></a>
<h5>6.5.4.3.4&nbsp;&nbsp;Functions, Shear</h5>
<p>shear in XY-plane : replace &quot;<code>x</code>&quot; with &quot;<code>x +  y*tan(radians(Angle))</code>&quot; (idem other parameters)</p>
<pre>shear 45 degrees left   gives    P(x+y*tan(radians(45)), y, z)</pre>

</div>

<div class="divh5">
<a name="target_878"></a>
<h5>6.5.4.3.5&nbsp;&nbsp;Functions, Rotate</h5>
<p class="Note"><strong>Note:</strong> these rotation substitutions work like normal POV-rotations: they already compensate for the inverse working</p>
<p>rotate around X
<br>: replace &quot;<code>y</code>&quot; with &quot;<code>z*sin(radians(Angle)) + y*cos(radians(Angle))</code>&quot;
<br>: replace &quot;<code>z</code>&quot; with &quot;<code>z*cos(radians(Angle)) - y*sin(radians(Angle))</code>&quot;</p>

<p>rotate around Y
<br>: replace &quot;<code>x</code>&quot; with &quot;<code>x*cos(radians(Angle)) - z*sin(radians(Angle))</code>&quot;
<br>: replace &quot;<code>z</code>&quot; with &quot;<code>x*sin(radians(Angle)) + z*cos(radians(Angle))</code>&quot;</p>

<p>rotate around Z
<br>: replace &quot;<code>x</code>&quot; with &quot;<code>x*cos(radians(Angle)) + y*sin(radians(Angle))</code>&quot;
<br>: replace &quot;<code>y</code>&quot; with &quot;<code>-x*sin(radians(Angle)) + y*cos(radians(Angle)) </code>&quot;</p>
<pre>
  rotate z*75   gives:
  P(x*cos(radians(75)) + y*sin(radians(75)),
    -x*sin(radians(75)) + y*cos(radians(75)), z)
 </pre>

</div>

<div class="divh5">
<a name="target_879"></a>
<h5>6.5.4.3.6&nbsp;&nbsp;Functions, Flip</h5>
<p>flip X - Y : replace &quot;<code>x</code>&quot; with &quot;<code>y</code>&quot;  and replace &quot;<code>y</code>&quot; with &quot;<code>-x</code>&quot;</p>
<p>flip Y - Z : replace &quot;<code>y</code>&quot; with &quot;<code>z</code>&quot;  and replace &quot;<code>z</code>&quot; with &quot;<code>-y</code>&quot;</p>
<p>flip X - Z : replace &quot;<code>x</code>&quot; with &quot;<code>-z</code>&quot;  and replace &quot;<code>z</code>&quot; with &quot;<code>x</code>&quot;</p>
<pre>flip x and y   gives    P(y, -x, z)</pre>

</div>

<div class="divh5">
<a name="target_880"></a>
<h5>6.5.4.3.7&nbsp;&nbsp;Functions, Twist</h5>
<p>twist N turns/unit around <code>X</code>
<br>: replace &quot;<code>y</code>&quot; with &quot;<code>z*sin(x*2*pi*N) + y*cos(x*2*pi*N)</code>&quot;
<br>: replace &quot;<code>z</code>&quot; with &quot;<code>z*cos(x*2*pi*N) - y*sin(x*2*pi*N)</code>&quot;</p>

</div>

<div class="divh4">
<a name="target_881"></a>
<h4>6.5.4.4&nbsp;&nbsp;Combining Functions</h4>

<p>CSG operations can be performed on isosurface objects since they are solid 
finite objects - if not finite by themselves, they are through the cross 
section with the container. This is done in the usual way.</p>

<p>However, when CSG-like operations on functions within the contained_by 
object are needed, functions have to be combined with the appropriate 
operators to do so.</p>

<p>Here's an overview of some useful combinations of functions:</p>

</div>

<div class="divh5">
<a name="target_882"></a>
<h5>6.5.4.4.1&nbsp;&nbsp;Functions, Merge</h5>
<a name="target_883"></a>

<p>A merge can be obtained with &quot;<code>min(A, B, ...)</code>&quot;
<pre>
function{min(Function_A(x,y,z),Function_B(x,y,z))}
function{min(Function_A(x,y,z),Function_B(x,y,z),Function_C(x,y,z))}
</pre>
</p>

</div>

<div class="divh5">
<a name="target_884"></a>
<h5>6.5.4.4.2&nbsp;&nbsp;Functions, Intersection</h5>
<a name="target_885"></a>
<p>A way to do this : using &quot;<code>max(A,B,...)</code>&quot;
<pre>
function{max(Function_A(x,y,z),Function_B(x,y,z))}
function{max(Function_A(x,y,z),Function_B(x,y,z),Function_C(x,y,z))}
</pre></p>

</div>

<div class="divh5">
<a name="target_886"></a>
<h5>6.5.4.4.3&nbsp;&nbsp;Functions, Difference</h5>
<a name="target_887"></a>
<p>A way to do this are: using &quot;<code>max(A, -(B-2*Threshold))</code>&quot;
<pre>
function{max( Function_A(x,y,z), -(Function_B(x,y,z) -2*Threshold))}
threshold Threshold
</pre>
If you are using the default threshold (=0) you don't need to subtract the 2*Threshold, since 2*0=0</p>

</div>

<div class="divh5">
<a name="target_888"></a>
<h5>6.5.4.4.4&nbsp;&nbsp;Functions, Blob</h5>
<a name="target_889"></a>
<p>Two possible ways to do this are:
<ol>
  <li>&nbsp;&nbsp;using &quot;<code>(A*B)- Blob_threshold</code>&quot;</li>
  <li>&nbsp;&nbsp;using &quot;<code>(1+Blob_threshold) -Blob_threshold^A -Blob_threshold^B</code>&quot;</li>
</ol>
<pre>
function{ (Function_A(x,y,z) * Function_B(x,y,z)) -Blob_threshold)}
function{
  (1+Blob_threshold)
  -pow(Blob_threshold, Function_A(x,y,z))
  -pow(Blob_threshold, Function_B(x,y,z))
}
</pre></p>

</div>

<div class="divh5">
<a name="target_890"></a>
<h5>6.5.4.4.5&nbsp;&nbsp;Functions, Negative Blob</h5>
<p>use &quot;<code>A +(Blob_threshold ^(B + Strength)^(C + Strength))</code>&quot;
<pre>
function{Function_A + pow(Blob_threshold,(Function_B + Strength))}
</pre></p>

</div>

<div class="divh5">
<a name="target_891"></a>
<h5>6.5.4.4.6&nbsp;&nbsp;Functions, Blend</h5>
<a name="target_892"></a>
<p>use &quot;<code>A + B&quot; or &quot;A - B</code>&quot;
<br>This produces a kind of blend of the two functions.
<pre>
  function { Function_A +  Function_B }
</pre></p>

</div>

<div class="divh4">
<a name="target_893"></a>
<h4>6.5.4.5&nbsp;&nbsp;Improving Isosurface Speed</h4>

<p>Rendering speed of isosurfaces can vary considerably depending on the used 
settings. Usually they render quite fast when the settings are optimized. 
Here are some rules to keep in mind when designing isosurfaces:</p>

</div>

<div class="divh5">
<a name="target_894"></a>
<h5>6.5.4.5.1&nbsp;&nbsp;Using Accuracy</h5>
<a name="target_895"></a>
Setting <code>accuracy 0.1</code> (default value is 0.001) is a good value to start 
with. You will not see a difference on isosurfaces with a gradually changing 
surface but it will render more than two times faster. <br>A higher <code>accuracy </code>
can be needed when the surface has sudden changes or a higher frequency of 
changes on parts that face the camera (and when the <code>accuracy</code> of these details 
matter). You may possibly need a higher <code>accuracy</code> when doing a trace on the 
isosurface or when the surface should match the function very closely. 
<br>But usually the <code>accuracy</code> can be set lower than the default with no 
noticeable differences on the isosurface.</p>

</div>

<div class="divh5">
<a name="target_896"></a>
<h5>6.5.4.5.2&nbsp;&nbsp;Container</h5>
Make sure your <code>contained_by</code> 'object' fits as tightly as possible. An 
oversized container can sky-rocket the render time. <br>When the container 
has a lot of empty space around the actual isosurface, POV-Ray has to do a lot of 
superfluous sampling: especially with complex functions this can become very 
time consuming. On top of this, the <code>max_gradient</code> needed to get a proper 
surface will also increase rapidly (almost proportional to the oversize!). 
<br>You could use a transparent copy of the container (using exactly the same 
transformations) to check how it fits. Getting the <code>min_extent</code> and <code>max_extent</code> 
of the <code>isosurface</code> isn't useful because it only gives the extent of the 
container and not of the actual isosurface.</p>

</div>

<div class="divh5">
<a name="target_897"></a>
<h5>6.5.4.5.3&nbsp;&nbsp;Maximum Gradient</h5>
<p>It is important to specify a correct <code>max_gradient</code> value.  When it is
set too high, it slows down rendering. On the other hand, when set too low, the
surface may not render properly, showing artefacts or holes.  So, find the real
maximum gradient and <em>use</em> it.  POV-Ray will warn you when a bad
<code>max_gradient</code> is used.  It is usually safe to use the measured value
printed in the warning as new max_gradient value but it <em>can</em> happen that
this value is insufficient.</p>

<p>When you use <code>evaluate</code>, POV-Ray uses a dynamic calculation method for
the <code>max_gradient</code> value.  This can help to achieve a faster rendering than
with a correct <code>max_gradient</code> in some situations.  Optimizing the
<code>evaluate</code> parameters always means balancing between artefacts and
slow calculation.  It requires a lot of patience and some experience to find the
best values.</p>

</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_189.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_191.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
