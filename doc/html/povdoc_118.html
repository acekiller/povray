<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>The Clock Variable: Key To It All</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_243"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_117.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_119.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>3.12.1&nbsp;&nbsp;The Clock Variable: Key To It All</h3>

  <p>POV-Ray supports an automatically declared floating point variable
  identified as <code><a href="povdoc_158.html#target_539">clock</a></code> (all lower case). This is the key to making
  image files that can be automated. In command line operations, the clock
  variable is set using the <code>+k</code> switch. For example, <code>
  +k3.4</code> from the command line would set the value of clock to 3.4. The
  same could be accomplished from the INI file using <code>Clock=3.4</code> in
  an INI file.</p><p>
   If we don't set clock for anything, and the animation loop is not used
  (as will be described a little later) the clock variable is still there -
  it's just set for the default value of 0.0, so it is possible to set up
  some POV code for the purpose of animation, and still render it as a still
  picture during the object/world creation stage of our project.</p><p>
   The simplest example of using this to our advantage would be having an
  object which is travelling at a constant rate, say, along the x-axis. We
  would have the statement</p>
<pre>
  translate &lt;clock, 0, 0&gt;
</pre>

  <p>in our object's declaration, and then have the animation loop assign
  progressively higher values to clock. And that's fine, as long as only
  one element or aspect of our scene is changing, but what happens when we want
  to control multiple changes in the same scene simultaneously?</p><p>
   The secret here is to use normalized clock values, and then make other
  variables in your scene proportional to clock. That is, when we set up our
  clock, (we're getting to that, patience!) have it run from 0.0 to 1.0,
  and then use that as a multiplier to some other values. That way, the other
  values can be whatever we need them to be, and clock can be the same 0 to 1
  value for every application. Let's look at a (relatively) simple
  example</p>
<pre>
  #include &quot;colors.inc&quot;
  camera {
    location &lt;0, 3, -6&gt;
    look_at &lt;0, 0, 0&gt;
  }
  light_source { &lt;20, 20, -20&gt; color White }
  plane {
    y, 0
    pigment { checker color White color Black }
  }
  sphere {
    &lt;0, 0, 0&gt; , 1
    pigment {
      gradient x
      color_map {
        [0.0 Blue  ]
        [0.5 Blue  ]
        [0.5 White ]
        [1.0 White ]
      }
      scale .25
    }
    rotate &lt;0, 0, -clock*360&gt;
    translate &lt;-pi, 1, 0&gt;
    translate &lt;2*pi*clock, 0, 0&gt;
  }
</pre>

  <p>Assuming that a series of frames is run with the clock progressively going
  from 0.0 to 1.0, the above code will produce a striped ball which rolls from
  left to right across the screen. We have two goals here:</p>
  <ol>
    <li>Translate the ball from point A to point B, and,</li>
    <li>Rotate the ball in exactly the right proportion to its linear movement to
        imply that it is rolling -- not gliding -- to its final position.</li>
  </ol>
  <p>Taking the second goal first, we start with the sphere at the origin,
  because anywhere else and rotation will cause it to orbit the origin instead
  of rotating. Throughout the course of the animation, the ball will turn one
  complete 360 degree turn. Therefore, we used the formula, <code>360*clock</code>
  to determine the rotation in each frame. Since clock runs 0 to 1, the rotation
  of the sphere runs from 0 degrees through 360.</p><p>
   Then we used the first translation to put the sphere at its initial starting
  point. Remember, we couldn't have just declared it there, or it would
  have orbited the origin, so before we can meet our other goal (translation),
  we have to compensate by putting the sphere back where it would have been at
  the start. After that, we re-translate the sphere by a clock relative
  distance, causing it to move relative to the starting point. We've chosen
  the formula of 2*pi* r*clock (the widest circumference of the sphere times
  current clock value) so that it will appear to move a distance equal to the
  circumference of the sphere in the same time that it rotates a complete 360
  degrees. In this way, we've synchronized the rotation of the sphere to
  its translation, making it appear to be smoothly rolling along the plane.</p><p>
   Besides allowing us to coordinate multiple aspects of change over time more
  cleanly, mathematically speaking, the other good reason for using normalized
  clock values is that it will not matter whether we are doing a ten frame
  animated GIF, or a three hundred frame AVI. Values of the clock are
  proportioned to the number of frames, so that same POV code will work without
  regard to how long the frame sequence is. Our rolling ball will still travel
  the exact same amount no matter how many frames our animation ends up
  with.</p>

</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_117.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_119.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
