<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>The Trace macro</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_276"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_137.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_139.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>4.2.8&nbsp;&nbsp;The Trace macro</h3>

<pre>
#macro Trace(P, D, recLev)
</pre>


<p>If the ray-sphere intersection macro was the core of the raytracer, then
the Trace-macro is practically everything else, the &quot;body&quot; of the raytracer.</p>

<p>The Trace-macro is a macro which takes the starting point of a ray, the
direction of the ray and a recursion count (which should always be 1 when
calling the macro from outside; 1 could be its default value if POV-Ray
supported default values for macro parameters). It calculates and returns a
color for that ray.</p>

<p>This is the macro we call for each pixel we want to calculate. That is,
the starting point of the ray is our camera location and the direction is
the direction of the ray starting from there and going through the &quot;pixel&quot;
we are calculating. The macro returns the color of that pixel.</p>

<p>What the macro does is to see which sphere (if any) does the ray hit
and then calculates the lighting for that intersection point (which includes
calculating reflection), and returns the color.</p>

<p>The Trace-macro is <i>recursive</i>, meaning that it calls itself. More
specifically, it calls itself when it wants to calculate the ray reflected
from the surface of a sphere. The <code>recLev</code> value is used to stop
this recursion when the maximum recursion level is reached (ie. it calculates
the reflection only if <code>recLev &lt; MaxRecLev</code>).</p>

<p>Let's examine this relatively long macro part by part:</p>

</div>

<div class="divh4">
<a name="target_277"></a>
<h4>4.2.8.1&nbsp;&nbsp;Calculating the closest intersection</h4>

<pre>
  #local minT = MaxDist;
  #local closest = ObjAmnt;

  // Find closest intersection:
  #local Ind = 0;
  #while(Ind &lt; ObjAmnt)
    #local T = calcRaySphereIntersection(P, D, Ind);
    #if(T&gt;0 &amp; T&lt;minT) 
      #local minT = T;
      #local closest = Ind;
    #end
    #local Ind = Ind+1;
  #end
</pre>


<p>A ray can hit several spheres and we need the closest intersection point
(and to know which sphere does it belong to). One could think that calculating
the closest intersection is rather complicated, needing things like sorting
all the intersection points and such. However, it's quite simple, as seen
in the code above.</p>

<p>If we remember from the previous part, the ray-sphere intersection macro
returns a factor value which tells us how much do we have to multiply the
direction vector in order to get the intersection point. What we do is just
to call the ray-sphere intersection macro for each sphere and take the
smallest returned value (which is greater than zero).</p>

<p>First we initialize the <code>minT</code> identifier, which will hold
this smallest value to something big (this is where we need the
<code>MaxDist</code> value, although modifying this code to work around this
limitation is trivial and left to the user). Then we go through all the
spheres and call the ray-sphere intersection macro for each one. Then we
look if the returned value was greater than 0 and smaller than
<code>minT</code>, and if so, we assign the value to <code>minT</code>. When
the loop ends, we have the smallest intersection point in it.</p>

<p class="Note"><strong>Note:</strong> we also assign the index to the sphere which the closest
intersection belongs to in the <code>closest</code> identifier.</p>

<p>Here we use a small trick, and it's related to its initial value:
<code>ObjAmnt</code>. Why did we initialize it to that? The purpose of it
was to initialize it to some value which isn't a legal index to a sphere
(<code>ObjAmnt</code> is not a legal index as the indices go from 0 to
<code>ObjAmnt-1</code>); a negative value would have worked as well, it
really doesn't matter. If the ray doesn't hit any sphere, then this identifier
is not changed and so we can see it afterwards.</p>


</div>

<div class="divh4">
<a name="target_278"></a>
<h4>4.2.8.2&nbsp;&nbsp;If the ray doesn't hit anything</h4>

<pre>
  // If not found, return background color:
  #if(closest = ObjAmnt)
    #local Pixel = BGColor;
</pre>


<p>If the ray didn't hit any sphere, what we do is just to return the
bacground color (defined by the <code>BGColor</code> identifier).</p>


</div>

<div class="divh4">
<a name="target_279"></a>
<h4>4.2.8.3&nbsp;&nbsp;Calculating the color of the pixel</h4>

<p>Now comes one of the most interesting parts of the raytracing process:
How do we calculate the color of the intersection point?</p>

</div>

<div class="divh5">
<a name="target_280"></a>
<h5>4.2.8.3.1&nbsp;&nbsp;Initializing color calculations</h5>

<p>First we have to pre-calculate a couple of things:</p>

<pre>
  #else
    // Else calculate the color of the intersection point:
    #local IP = P+minT*D;
    #local R = Coord[closest][1].x;
    #local Normal = (IP-Coord[closest][0])/R;

    #local V = P-IP;
    #local Refl = 2*Normal*(vdot(Normal, V)) - V;
</pre>


<p>Naturally we need the intersection point itself (needed to calculate the
normal vector and as the starting point of the reflected ray). This is
calculated into the <code>IP</code> identifier with the formula which I
have been repeating a few times during this tutorial.</p>

<p>Then we need the normal vector of the surface at the intersection point.
A normal vector is a vector perpendicular (ie. at 90 degrees) to the surface.
For a sphere this is very easy to calculate: It's just the vector from the
center of the sphere to the intersection point.</p>
<p class="Note"><strong>Note:</strong> we normalize it
(ie. convert it into a unit vector, ie. a vector of length 1) by dividing
it by the radius of the sphere. The normal vector needs to be normalized for
lighting calculation.</p>

<p>Now a tricky one: We need the direction of the reflected ray. This
vector is of course needed to calculate the reflected ray, but it's also
needed for specular lighting.</p>

<p>This is calculated into the <code>Refl</code> identifier in the code
above. What we do is to take the vector from the intersection point to
the starting point (<code>P-IP</code>) and &quot;mirror&quot; it with respect to
the normal vector. The formula for &quot;mirroring&quot; a vector <code>V</code> with
respect to a unit vector (let's call it <code>Axis</code>) is:</p>

<p><code>MirroredV = 2*Axis*(Axis&#183;V) - V</code></p>

<p>(We could look at the theory behind this formula in more detail, but let's
not go too deep into math in this tutorial, shall we?)</p>

</div>

<div class="divh5">
<a name="target_281"></a>
<h5>4.2.8.3.2&nbsp;&nbsp;Going through the light sources</h5>

<pre>
    // Lighting:
    #local Pixel = AmbientLight;
    #local Ind = 0;
    #while(Ind &lt; LightAmnt)
      #local L = LVect[Ind][0];
</pre>


<p>Now we can calculate the lighting of the intersection point. For this
we need to go through all the light sources.</p>
<p class="Note"><strong>Note:</strong> <code>L</code>contains the direction vector which
points towards the light source, not its location.</p>

<p>We also initialize the color to be returned (<code>Pixel</code>) with
the ambient light value (given in the global settings part). The goal is to
add colors to this (the colors come from diffuse and specular lighting, and
reflection).</p>


</div>

<div class="divh5">
<a name="target_282"></a>
<h5>4.2.8.3.3&nbsp;&nbsp;Shadow test</h5>

<p>The very first thing to do for calculating the lighting for a light source
is to see if the light source is illuminating the intersection point in the
first place (this is one of the nicest features of raytracing: shadow
calculations are laughably easy to do):</p>

<pre>
      // Shadowtest:
      #local Shadowed = false;
      #local Ind2 = 0;
      #while(Ind2 &lt; ObjAmnt)
        #if(Ind2!=closest &amp; calcRaySphereIntersection(IP,L,nd2)&gt;0)
          #local Shadowed = true;
          #local Ind2 = ObjAmnt;
        #end
        #local Ind2 = Ind2+1;
      #end
</pre>


<p>What we do is to go through all the spheres (we skip the current sphere
although it's not necessary, but a little optimization is still a little
optimization), take the intersection point as starting point and the
light direction as the direction vector and see if the ray-sphere intersection
test returns a positive value for any of them (and quit the loop immediately
when one is found, as we don't need to check the rest anymore).</p>

<p>The result of the shadow test is put into the <code>Shadowed</code>
identifier as a boolean value (<code>true</code> if the point is shadowed).</p>

</div>

<div class="divh5">
<a name="target_283"></a>
<h5>4.2.8.3.4&nbsp;&nbsp;Diffuse lighting</h5>

<p>The diffuse component of lighting is generated when a light ray hits
a surface and it's reflected equally to all directions. The brightest part
of the surface is where the normal vector points directly in the direction
of the light. The lighting diminishes in relation to the cosine of the
angle between the normal vector and the light vector.</p>

<pre>
      #if(!Shadowed)
        // Diffuse:
        #local Factor = vdot(Normal, L);
        #if(Factor &gt; 0)
          #local Pixel = 
             Pixel + LVect[Ind][1]*Coord[closest][2]*Factor;
        #end
</pre>


<p>The code for diffuse lighting is suprisingly short.</p>

<p>There's an extremely nice trick in mathematics to get the cosine of the
angle between two unit vectors: It's their dot-product.</p>

<p>What we do is to calculate the dot-product of the normal vector and the
light vector (both have been normalized previously). If the dot-product
is negative it means that the normal vector points in the opposite direction
than the light vector. Thus we are only interested in positive values.</p>

<p>Thus, we add to the pixel color the color of the light source multiplied
by the color of the surface of the sphere multiplied by the dot-product.
This gives us the diffuse component of the lighting.</p>

</div>

<div class="divh5">
<a name="target_284"></a>
<h5>4.2.8.3.5&nbsp;&nbsp;Specular lighting</h5>

<p>The specular component of lighting comes from the fact that most surfaces
do not reflect light equally to all directions, but they reflect more light
to the &quot;reflected ray&quot; direction, that is, the surface has some mirror
properties. The brightest part of the surface is where the reflected ray
points in the direction of the light.</p>

<p>Photorealistic lighting is a very complicated issue and there are lots
of different lighting models out there, which try to simulate real-world
lighting more or less accurately. For our simple raytracer we just use
a simple Phong lighting model, which suffices more than enough.</p>

<pre>
        // Specular:
        #local Factor = vdot(vnormalize(Refl), L);
        #if(Factor &gt; 0)
          #local Pixel = Pixel + LVect[Ind][1]*
                         pow(Factor, Coord[closest][3].x)*
                         Coord[closest][3].y;
        #end
</pre>


<p>The calculation is similar to the diffuse lighting with the following
differences:</p>

<ul>
 <li>We don't use the normal vector, but the reflected vector.</li>
 <li>The color of the surface is not taken into account (a very simple
     Phong lighting model).</li>
 <li>We don't take the dot-product as is, but we raise it to a power given
     in the scene definition (&quot;phong size&quot;).</li>
 <li>We use a brightness factor given in the scene definition to multiply
     the color (&quot;phong amount&quot;).</li>
</ul>

<p>Thus, the color we add to the pixel color is the color of the light
source multiplied by the dot-product (which is raised to the given power)
and by the given brightness amount.</p>

<p>Then we close the code blocks:</p>

<pre>
      #end // if(!Shadowed)
      #local Ind = Ind+1;
    #end // while(Ind &lt; LightAmnt)
</pre>



</div>

<div class="divh5">
<a name="target_285"></a>
<h5>4.2.8.3.6&nbsp;&nbsp;Reflection Calculation</h5>

<pre>
    // Reflection:
    #if(recLev &lt; MaxRecLev &amp; Coord[closest][1].y &gt; 0)
      #local Pixel = 
        Pixel + Trace(IP, Refl, recLev+1)*Coord[closest][1].y;
    #end
</pre>


<p>Another nice aspect of raytracing is that reflection is very easy to 
calculate.</p>

<p>Here we check that the recursion level has not reached the limit and 
that the sphere has a reflection component defined. If both are so, we 
add the reflected component (the color of the reflected ray multiplied 
by the reflection factor) to the pixel color.</p>

<p>This is where the recursive call happens (the macro calls itself). The 
recursion level (recLev) is increased by one for the next call so that 
somewhere down the line, the series of Trace() calls will know to stop 
(preventing a ray from bouncing back and forth forever between two 
mirrors). This is basically how the max_trace_level global setting works 
in POV-Ray.</p>

<p>Finally, we close the code blocks and return the pixel color from the 
macro:</p>

<pre>
  #end // else

  Pixel
#end
</pre>


</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_137.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_139.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
