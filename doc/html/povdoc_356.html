<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>CSG speed.</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_1678"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_355.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_357.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>9.4.3&nbsp;&nbsp;CSG speed.</h3>

<p><i>&quot;How do the different kinds of CSG objects compare in speed? How can I
speed them up?&quot;</i>

</p><p>There is a lot of misinformation about CSG speed out there. A
very common allegation is that &quot;merge is always slower than union&quot;. This statement
is not true. Merge is sometimes slower than union, but in some cases it's
even faster. For example, consider the following code:

<pre>
global_settings { max_trace_level 40 }
camera { location -z*8 look_at 0 angle 35 }
light_source { &lt;100,100,-100&gt; 1 }
merge
{ #declare Ind=0;
  #while(Ind&lt;20)
    sphere { z*Ind,2 pigment { rgbt .9 } }
    #declare Ind=Ind+1;
  #end
}
</pre>

</p><p>There are 20 semitransparent merged spheres there. A test render took 64
seconds. Substituting 'merge' with 'union' took 352 seconds to render
(5.5 times longer). The difference in speed is very notable.

</p><p>So why is 'merge' so much faster than 'union' in this case? Well, the
answer is probably that the number of visible surfaces play a very important
role in the rendering speed. When the spheres are unioned there are 18
inner surfaces, while when merged, those inner surfaces are gone. POV-Ray has
to calculate lighting and shading for each one of those surfaces and that
makes it so slow. When the spheres are merged, there's no need to perform
lighting and shading calculations for those 18 surfaces.

</p><p>So is 'merge' always faster than 'union'? No. If you have completely
non-transparent objects, then 'merge' is slightly slower than 'union', and
in that case you should always use 'union' instead. It makes no sense
using 'merge' with non-transparent objects.

</p><p>Another common allegation is &quot;difference is very slow; much slower
than union&quot;. This can also be proven as a false statement. Consider
the following example:

<pre>
camera { location -z*12 look_at 0 angle 35 }
light_source { &lt;100,100,-100&gt; 1 }
difference
{ sphere { 0,2 }
  sphere { &lt;-1,0,-1&gt;,2 }
  sphere { &lt;1,0,-1&gt;,2 }
  pigment { rgb &lt;1,0,0&gt; }
}
</pre>

</p><p>This scene took 42 seconds to render, while substituting the 'difference' with a 'union' took 59 seconds (1.4 times longer).

</p><p>The crucial thing here is the size of the surfaces on screen. The larger
the size, the slower to render (because POV-Ray has to do more lighting and
shading calculations).

</p><p>But the second statement is much closer to the truth than the first one:
differences are usually slow to render, specially when the member objects
of the difference are very much bigger than the resulting CSG object.
This is because POV-Ray's automatic bounding is not perfect. A few words
about bounding:

</p><p>Suppose you have hundreds of objects (like spheres or whatever) forming
a bigger CSG object, but this object is rather small on screen (like a
little house for example). It would be really slow to test ray-object
intersection for each one of those objects for each pixel of the screen.
This is speeded up by bounding the CSG object with a bounding shape (such
as a box). Ray-object intersections are first tested for this bounding box,
and it is tested for the objects inside the box only if it hits the box. This
speeds rendering considerably since the tests are performed only in the
area of the screen where the CSG object is located and nowhere else.

</p><p>Since it's rather easy to automatically calculate a proper bounding
box for a given object, POV-Ray does this and thus you don't have to
do it by yourself.

</p><p>But this automatic bounding is not perfect. There are situations where
a perfect automatic bounding is very hard to calculate. One situation is
the difference and the intersection CSG operations. POV-Ray does what it
can, but sometimes it makes a pretty poor job. This can be specially seen
when the resulting CSG object is very small compared to the CSG member
objects. For example:

<pre>
intersection
{ sphere { &lt;-1000,0,0&gt;,1001 }
  sphere { &lt;1000,0,0&gt;,1001 }
}
</pre>

</p><p>(This is the same as making a difference with the second sphere inversed)

</p><p>In this example the member objects extend from &lt;-2001,-1001,-1001&gt;
to &lt;2001,1001,1001&gt; although the resulting CSG object is a pretty
small lens-shaped object which is only 2 units wide in the x direction and
perhaps 10 or 20 or something wide in the y and z directions. As you can see,
it's very difficult to calculate the actual dimensions of the object (but
not impossible).

</p><p>In this type of cases POV-Ray makes a huge bounding box which is useless.
You should bound this kind of objects by hand (specially when the it has
lots of member objects). This can be done with the bounded_by keyword.

</p><p>Here is an example:

<pre>
camera { location -z*80 look_at 0 angle 35 }
light_source { &lt;100,200,-150&gt; 1 }
#declare test =
difference
{ union
  { cylinder {&lt;-2, -20, 0&gt;, &lt;-2, 20, 0&gt;, 1}
    cylinder {&lt;2, -20, 0&gt;, &lt;2, 20, 0&gt;, 1}
  }
  box {&lt;-10, 1, -10&gt;, &lt;10, 30, 10&gt;}
  box {&lt;-10, -1, -10&gt;, &lt;10, -30, 10&gt;}
  pigment {rgb &lt;1, .5, .5&gt;}
  bounded_by { box {&lt;-3.1, -1.1, -1.1&gt;, &lt;3.1, 1.1, 1.1&gt;} }
}

#declare copy = 0;
#while (copy &lt; 40)
  object {test translate -20*x translate copy*x}
  #declare copy = copy + 3;
#end
</pre>

</p><p>This took 51 seconds to render. Commenting out the 'bounded_by' line increased the rendering time to 231 seconds (4.5 times slower).
</p>


<!-- ================================================================== -->

<a name="3dnow" class="ExternalLink">
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_355.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_357.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
