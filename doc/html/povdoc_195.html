<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Object Modifiers</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_969"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_194.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_196.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>6.5.9&nbsp;&nbsp;Object Modifiers</h3>

  <p>A variety of modifiers may be attached to objects. The following items may
  be applied to any object:</p>
<pre>
OBJECT_MODIFIER:
   clipped_by { UNTEXTURED_SOLID_OBJECT... } |
   clipped_by { bounded_by }                 |
   bounded_by { UNTEXTURED_SOLID_OBJECT... } |
   bounded_by { clipped_by }                 |
   no_shadow                  |
   no_image [ Bool ]          |
   no_reflection [ Bool ]     |
   inverse                    |
   sturm [ Bool ]             |
   hierarchy [ Bool ]         |
   double_illuminate [ Bool ] |
   hollow  [ Bool ]           |
   interior { INTERIOR_ITEMS... }                        |
   material { [MATERIAL_IDENTIFIER][MATERIAL_ITEMS...] } |
   texture { TEXTURE_BODY }   |
   interior_texture { TEXTURE_BODY } |
   pigment { PIGMENT_BODY }   |
   normal { NORMAL_BODY }     |
   finish { FINISH_ITEMS... } |
   photons { PHOTON_ITEMS...}
   TRANSFORMATION
</pre>


  <p>Transformations such as translate, rotate and scale have already been
  discussed. The modifiers &quot;Textures&quot; and its parts
  &quot;Pigment&quot;, &quot;Normal&quot;, and &quot;Finish&quot; as well as
  &quot;Interior&quot;, and &quot;Media&quot; (which is part of interior) are
  each in major chapters of their own below. In the sub-sections below we cover
  several other important modifiers: <code>clipped_by</code>,
  <code>bounded_by</code>, <code>material</code>, <code>inverse</code>, 
  <code>hollow</code>, <code>no_shadow</code>, <code>no_image</code>,
  <code>no_reflection</code>, <code>double_illuminate</code> and
  <code>sturm</code>. Although the examples below use object statements and
  object identifiers, these modifiers may be used on any type of object such as
  sphere, box etc.</p>

</div>

<div class="divh4">
<a name="target_970"></a>
<h4>6.5.9.1&nbsp;&nbsp;Clipped_By</h4>

  <p>The <code>clipped_by</code> statement is technically an object modifier
  but it provides a type of CSG similar to CSG intersection. The syntax is:</p>
<pre>
CLIPPED_BY:
    clipped_by { UNTEXTURED_SOLID_OBJECT... } |
    clipped_by { bounded_by }
</pre>

  <p>Where <em>UNTEXTURED_SOLID_OBJECT</em> is one or more solid objects which
  have had no texture applied. For example:</p>
<pre>
  object {
    My_Thing
    clipped_by{plane{y,0}}
  }
</pre>

  <p>Every part of the object <code>My_Thing</code> that is inside the plane is
  retained while the remaining part is clipped off and discarded. In an <code>
  intersection</code> object the hole is closed off. With <code>
  clipped_by</code> it leaves an opening. For example the following figure
  shows object <code>A</code> being clipped by object <code>B</code>.</p>

   
<center><img src="images/clipobj.gif" alt="An object clipped by another object"><br><font size=-1><cite>An object clipped by another object</cite></font></center>


  <p>You may use <code>clipped_by</code> to slice off portions of any shape. In
  many cases it will also result in faster rendering times than other methods
  of altering a shape. Occasionally you will want to use the <code>
  clipped_by</code> and <code>bounded_by</code> options with the same object.
  The following shortcut saves typing and uses less memory.</p>
<pre>
  object {
    My_Thing
    bounded_by { box { &lt;0,0,0&gt;, &lt;1,1,1&gt; } }
    clipped_by { bounded_by }
  }
</pre>

  <p>This tells POV-Ray to use the same box as a clip that was used as a
  bound.</p>

</div>

<div class="divh4">
<a name="target_971"></a>
<h4>6.5.9.2&nbsp;&nbsp;Bounded_By</h4>

  <p>The calculations necessary to test if a ray hits an object can be quite
  time consuming. Each ray has to be tested against every object in the scene.
  POV-Ray attempts to speed up the process by building a set of invisible
  boxes, called bounding boxes, which cluster the objects together. This way a
  ray that travels in one part of the scene doesn't have to be tested
  against objects in another, far away part of the scene. When a large number
  of objects are present the boxes are nested inside each other. POV-Ray can
  use bounding boxes on any finite object and even some clipped or bounded
  quadrics. However infinite objects (such as a planes, quartic, cubic and
  poly) cannot be automatically bound. CSG objects are automatically bound if
  they contain finite (and in some cases even infinite) objects. This works by
  applying the CSG set operations to the bounding boxes of all objects used
  inside the CSG object. For difference and intersection operations this will
  hardly ever lead to an optimal bounding box. It's sometimes better
  (depending on the complexity of the CSG object) to have you place a bounding
  shape yourself using a <code> bounded_by</code> statement.</p><p>
   Normally bounding shapes are not necessary but there are cases where they
  can be used to speed up the rendering of complex objects. Bounding shapes
  tell the ray-tracer that the object is totally enclosed by a simple shape.
  When tracing rays, the ray is first tested against the simple bounding shape.
  If it strikes the bounding shape the ray is further tested against the more
  complicated object inside. Otherwise the entire complex shape is skipped,
  which greatly speeds rendering. The syntax is:</p>
<pre>
BOUNDED_BY:
    bounded_by { UNTEXTURED_SOLID_OBJECT... } |
    bounded_by { clipped_by }
</pre>

  <p>Where <em>UNTEXTURED_SOLID_OBJECT</em> is one or more solid objects which
  have had no texture applied. For example:</p>
<pre>
  intersection {
    sphere { &lt;0,0,0&gt;, 2 }
    plane  { &lt;0,1,0&gt;, 0 }
    plane  { &lt;1,0,0&gt;, 0 }
    bounded_by { sphere { &lt;0,0,0&gt;, 2 } }
  }
</pre>

  <p>The best bounding shape is a sphere or a box since these shapes are highly
  optimized, although, any shape may be used. If the bounding shape is itself a
  finite shape which responds to bounding slabs then the object which it
  encloses will also be used in the slab system.</p><p>
   While it may a good idea to manually add a <code>bounded_by</code> to
  intersection, difference and merge, it is best to <em>never</em> bound a
  union. If a union has no <code> bounded_by</code> POV-Ray can internally
  split apart the components of a union and apply automatic bounding slabs to
  any of its finite parts. Note that some utilities such as <code>
  raw2pov</code> may be able to generate bounds more efficiently than
  POV-Ray's current system. However most unions you create yourself can be
  easily bounded by the automatic system. For technical reasons POV-Ray cannot
  split a merge object. It is maybe best to hand bound a merge, especially if
  it is very complex.</p>
  <p class="Note"><strong>Note:</strong> if bounding shape is too small or positioned incorrectly it may
  clip the object in undefined ways or the object may not appear at all. To do
  true clipping, use <code>clipped_by</code> as explained in the previous
  section. Occasionally you will want to use the <code>clipped_by</code> and
  <code>bounded_by</code> options with the same object. The following shortcut
  saves typing and uses less memory.</p>
<pre>
  object {
    My_Thing
    clipped_by{ box { &lt;0,0,0&gt;,&lt;1,1,1 &gt; }}
    bounded_by{ clipped_by }
  }
</pre>

  <p>This tells POV-Ray to use the same box as a bound that was used as a
  clip.</p>

</div>

<div class="divh4">
<a name="target_972"></a>
<h4>6.5.9.3&nbsp;&nbsp;Material</h4>

  <p>One of the changes in POV-Ray 3.1 was the removal of several items from <code>
  texture { finish{</code>...<code>} }</code> and to move them to the new <code>
  interior</code> statement. The <code><a href="povdoc_209.html#target_1069">halo</a></code> statement, formerly part of
  <code><a href="povdoc_205.html#target_1001">texture</a></code>, is now renamed <code><a href="povdoc_218.html#target_1185">media</a></code> and made a part of
  the <code><a href="povdoc_196.html#target_980">interior</a></code>.</p><p>
   This split was deliberate and purposeful (see
  &quot;<a href="povdoc_197.html#target_983">Why are Interior and Media Necessary?</a>&quot;)
  however beta testers pointed out that it made it difficult to 
  entirely describe the surface properties and interior of an object in one 
  statement that can be referenced by a single identifier in a texture 
  library.</p><p>
   The result is that we created a &quot;wrapper&quot; around <code> 
  texture</code> and <code> interior</code> which we call <code>material</code>.</p><p>
   The syntax is:</p>
<pre>
MATERIAL:
    material { [MATERIAL_IDENTIFIER][MATERIAL_ITEMS...] }
MATERIAL_ITEMS:
    TEXTURE | INTERIOR_TEXTURE | INTERIOR | TRANSFORMATIONS
</pre>

  <p>For example:</p>
<pre>
#declare MyGlass=material{ texture{ Glass_T } interior{ Glass_I }}
object { MyObject material{ MyGlass}}
</pre>

  <p>Internally, the &quot;material&quot; isn't attached to the object. The
  material is just a container that brings the texture and interior to the
  object. It is the texture and interior itself that is attached to the object.
  Users should still consider texture and interior as separate items attached
  to the object.</p><p>
   The material is just a &quot;bucket&quot; to carry them. If the object
  already has a texture, then the material texture is layered over it. If the object
  already has an interior, the material interior fully replaces it and the old
  interior is destroyed. Transformations inside the material affect only the
  textures and interiors which are inside the <code> material{}</code> wrapper
  and only those textures or interiors specified are affected. For example:</p>
<pre>
  object {
    MyObject
    material {
      texture { MyTexture }
      scale 4         //affects texture but not object or interior
      interior { MyInterior }
      translate 5*x   //affects texture and interior, not object
    }
  }
</pre>

  <p class="Note"><strong>Note:</strong> The <code>material</code> statement has nothing to do with the
  <code><a href="povdoc_210.html#target_1076">material_map</a></code> statement. A <code>material_map</code> is <em>
  not</em> a way to create patterned material. See &quot;<a href="povdoc_210.html#target_1075">Material Maps</a>&quot;
  for explanation of this unrelated, yet similarly named, older feature.</p>

</div>

<div class="divh4">
<a name="target_973"></a>
<h4>6.5.9.4&nbsp;&nbsp;Inverse</h4>

  <p>When using <a href="povdoc_192.html#target_906">CSG</a> it is often useful to invert an object so that it'll be
  inside-out. The appearance of the object is not changed, just the way that
  POV-Ray perceives it. When the <code><a href="#target_973">inverse</a></code> keyword is used the <em>
  inside</em> of the shape is flipped to become the <em>outside</em> and vice
  versa. For example:</p>
<pre>
  object { MyObject inverse }
</pre>

  <p>The inside/outside distinction is also important when attaching
  <code><a href="povdoc_196.html#target_980">interior</a></code> to an object especially if
  <code><a href="povdoc_218.html#target_1185">media</a></code> is also used. Atmospheric media 
  and fog also do not work as expected if your camera is inside an object. 
  Using <code>inverse</code> is useful to correct that problem.</p>

</div>

<div class="divh4">
<a name="target_974"></a>
<h4>6.5.9.5&nbsp;&nbsp;Hollow</h4>

  <p>POV-Ray by default assumes that objects are made of a solid material that
  completely fills the interior of an object. By adding the <code>
  hollow</code> keyword to the object you can make it hollow, also see the 
  <a href="povdoc_198.html#target_984">&quot;Empty and Solid Objects&quot;</a> chapter. That is very
  useful if you want atmospheric effects to exist inside an object. It is even
  required for objects containing an interior media. The keyword may optionally
  be followed by a float expression which is interpreted as a boolean value.
  For example <code>hollow off</code> may be used to force it off. When the
  keyword is specified alone, it is the same as <code>hollow on</code>. 
  By default <code>hollow</code> is <code>off</code> when not specified.</p><p>
   In order to get a hollow CSG object you just have to make the top level
  object hollow. All children will assume the same <code> hollow</code> state
  except when their state is explicitly set. The following example will set both
  spheres inside the union hollow</p>
<pre>
  union {
    sphere { -0.5*x, 1 }
    sphere {  0.5*x, 1 }
    hollow
  }
</pre>

  <p>while the next example will only set the second sphere hollow because the
  first sphere was explicitly set to be not hollow.</p>
<pre>
  union {
    sphere { -0.5*x, 1 hollow off }
    sphere {  0.5*x, 1 }
    hollow on
  }
</pre>

</div>

<div class="divh4">
<a name="target_975"></a>
<h4>6.5.9.6&nbsp;&nbsp;No_Shadow</h4>

  <p>You may specify the <code>no_shadow</code> keyword in an object to make
  that object cast no shadow. This is useful for special effects and for
  creating the illusion that a light source actually is visible. This keyword
  was necessary in earlier versions of POV-Ray which did not have the <code>
  looks_like</code> statement. Now it is useful for creating things like laser
  beams or other unreal effects. During test rendering it speeds things up if
  <code>no_shadow</code> is applied.</p><p>
  Simply attach the keyword as follows:</p>
<pre>
  object {
    My_Thing
    no_shadow
  }
</pre>


</div>

<div class="divh4">
<a name="target_976"></a>
<h4>6.5.9.7&nbsp;&nbsp;No_Image, No_Reflection</h4>
<a name="target_977"></a>


Syntax:
<pre>
  OBJECT {
    [OBJECT_ITEMS...]
    no_image
    no_reflection
  }
</pre>
<p>These two keywords are very similar in usage and function to the
<code>no_shadow</code> keyword, and control an object's visibility.
<br>You can use any combination of the three with your object.</p>
<p>When <code>no_image</code> is used, the object will not be seen by
the camera, either directly or through transparent/refractive objects. However,
it will still cast shadows, and show up in reflections (unless <code>no_reflection
</code> and/or <code>no_shadow</code> is used also).</p>

<p>When <code>no_reflection</code> is used, the object will not show up in
reflections. It will be seen by the camera (and through transparent/refractive objects)
and cast shadows, unless <code>no_image</code> and/or <code>no_shadow
</code> is used.</p>

<p>Using these three keywords you can produce interesting effects like a sphere
casting a rectangular shadow, a cube that shows up as a cone in mirrors,
etc.</p>

</div>

<div class="divh4">
<a name="target_978"></a>
<h4>6.5.9.8&nbsp;&nbsp;Double_Illuminate</h4>

<p>Syntax:</p>
<pre>
  OBJECT {
    [OBJECT_ITEMS...]
    double_illuminate
  }
</pre>

<p>A surface has two sides; usually, only the side facing the light source is illuminated,
the other side remains in shadow. When <code>double_illuminate</code> is used,
the other side is also illuminated.
<br>This is useful for simulating effects like translucency (as in a lamp shade, sheet of paper, etc).</p>

<p class="Note"><strong>Note:</strong> <code>double_illuminate</code> only illuminates both sides of the same
surface, so on a sphere, for example, you will not see the effect unless the
sphere is either partially transparent, or if the camera is inside and the light source
outside of the sphere (or vise versa).</p>


</div>

<div class="divh4">
<a name="target_979"></a>
<h4>6.5.9.9&nbsp;&nbsp;Sturm</h4>

  <p>Some of POV-Ray's objects allow you to choose between a fast but
  sometimes inaccurate root solver and a slower but more accurate one. This is
  the case for all objects that involve the solution of a cubic or quartic
  polynomial. There are analytic mathematical solutions for those polynomials
  that can be used.</p><p>
   Lower order polynomials are trivial to solve while higher order polynomials
  require iterative algorithms to solve them. One of those algorithms is the
  Sturmian root solver. For example:</p>
<pre>
  blob {
    threshold .65
    sphere { &lt;.5,0,0&gt;, .8, 1 }
    sphere { &lt;-.5,0,0&gt;,.8, 1 }
    sturm
  }

</pre>

  <p>The keyword may optionally be followed by a float expression which is
  interpreted as a boolean value. For example <code>sturm off</code> may be
  used to force it off. When the keyword is specified alone, it is the same as
  <code>sturm on</code>. By default <code>sturm</code> is <code>off</code> when not specified.</p><p>
  The following list shows all objects for which the Sturmian root solver can
  be used.</p>
  <ul>
    <li>blob</li>
    <li>cubic</li>
    <li>lathe (only with quadratic splines)</li>
    <li>poly</li>
    <li>prism (only with cubic splines)</li>
    <li>quartic</li>
    <li>sor</li>
  </ul>

</div>
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_194.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_196.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
