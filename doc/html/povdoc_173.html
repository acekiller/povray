<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>User Defined Macros</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_693"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_172.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_174.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>6.2.8&nbsp;&nbsp;User Defined Macros</h3>

<a name="target_694"></a>

  <p>POV-Ray 3.1 introduced user defined macros with parameters. This feature,
  along with the ability to declare <code>#local</code> variables, turned the
  POV-Ray Language into a fully functional programming language. Consequently,
  it is now possible to write scene generation tools in POV-Ray's own language
  that previously required external utilities.</p>

</div>

<div class="divh4">
<a name="target_695"></a>
<h4>6.2.8.1&nbsp;&nbsp;The #macro Directive</h4>

  <p>The syntax for declaring a macro is:</p>
<pre>
MACRO_DEFINITION:
#macro IDENTIFIER ([PARAM_IDENT] [, PARAM_IDENT]... ) TOKENS... #end
</pre>

  <p>Where <em>IDENTIFIER</em> is the name of the macro and <em>
  PARAM_IDENT</em>s are a list of zero or more formal parameter identifiers
  separated by commas and enclosed by parentheses. The parentheses are required
  even if no parameters are specified.</p><p>
   The <em>TOKENS</em> are any number of POV-Ray keyword, identifiers, or
  punctuation marks which are the <em> body</em> of the macro. The body of the
  macro may contain almost any POV-Ray syntax items you desire. It is
  terminated by the <code>#end</code> directive.</p> 
  <p class="Note"><strong>Note:</strong> any conditional directives such as <code> #if</code>...<code>#end</code>, <code>
  #while</code>...<code>#end</code>, etc. must be fully nested inside or
  outside the macro so that the corresponding <code>#end</code> directives
  pair-up properly.</p><p>
   A macro must be declared before it is invoked. All macro names are global in
  scope and permanent in duration. You may redefine a macro by another <code>
  #macro</code> directive with the same name. The previous definition is lost.
  Macro names respond to <code> #ifdef</code>, <code> #ifndef</code>, and
  <code>#undef</code> directives. See
  &quot;<a href="povdoc_171.html#target_683">The #ifdef and #ifndef Directives</a>&quot;
  and &quot;<a href="povdoc_167.html#target_666">Destroying Identifiers with #undef</a>&quot;.</p>

</div>

<div class="divh4">
<a name="target_696"></a>
<h4>6.2.8.2&nbsp;&nbsp;Invoking Macros</h4>

  <p>You invoke the macro by specifying the macro name followed by a list of
  zero or more actual parameters enclosed in parentheses and separated by
  commas. The number of actual parameters must match the number of formal
  parameters in the definition. The parentheses are required even if no
  parameters are specified. The syntax is:</p>
<pre>
MACRO_INVOCATION:
    MACRO_IDENTIFIER ( [ACTUAL_PARAM] [, ACTUAL_PARAM]... )
ACTUAL_PARAM:
    IDENTIFIER | RVALUE
</pre>

  <p>An <em>RVALUE</em> is any value that can legally appear to the right of an
  equals sign in a <code>#declare</code> or <code>#local</code> declaration.
  See &quot;<a href="povdoc_167.html#target_661">Declaring identifiers</a>&quot; for information on <em> RVALUE</em>s.
  When the macro is invoked, a new local symbol table is created. The actual
  parameters are assigned to formal parameter identifiers as local, temporary
  variables. POV-Ray jumps to the body of the macro and continues parsing until
  the matching <code>#end</code> directive is reached. There, the local
  variables created by the parameters are destroyed as well as any local
  identifiers expressly created in the body of the macro. It then resumes
  parsing at the point where the macro was invoked. It is as though the body of
  the macro was cut and pasted into the scene at the point where the macro was
  invoked.</p>
  <p class="Note"><strong>Note:</strong> it is possible to invoke a macro that was declared in another file.
  This is quite normal and in fact is how many &quot;plug-ins&quot; work (such as
  the popular Lens Flare macro). However, be aware that calling a macro that was
  declared in a file different from the one that it is being called from involves
  more overhead than calling one in the same file.</p>
  <p>This is because POV-Ray does
  not tokenize and store its language. Calling a macro in another file therefore
  requires that the other file be opened and closed for each call. Normally, this
  overhead is inconsequential; however, if you are calling the macro many thousands
  of times, it can cause significant delays. A future version of the POV-Ray
  language will remove this problem.</p><p>
  Here is a simple macro that creates a window frame object when you specify
  the inner and outer dimensions.</p>
<pre>
#macro Make_Frame(OuterWidth,OuterHeight,InnerWidth,
                  InnerHeight,Depth)
  #local Horz = (OuterHeight-InnerHeight)/2;
  #local Vert = (OuterWidth-InnerWidth)/2;
  difference {
    box{
	  &lt;0,0,0&gt;,&lt;OuterWidth,OuterHeight,Depth&gt;
	}
    box{
	  &lt;Vert,Horz,-0.1&gt;,
      &lt;OuterWidth-Vert,OuterHeight-Horz,Depth+0.1&gt;
	}
  }
#end
Make_Frame(8,10,7,9,1) //invoke the macro
</pre>

  <p>In this example, the macro has five float parameters. The actual
  parameters (the values 8, 10, 7, 9, and 1) are assigned to the five
  identifiers in the <code>#macro</code> formal parameter list. It is as though
  you had used the following five lines of code.</p>
<pre>
 #local OuterWidth = 8;
 #local OuterHeight = 10;
 #local InnerWidth, = 7;
 #local InnerHeight = 9;
 #local Depth = 1;
</pre>

  <p>These five identifiers are stored in the same symbol table as any other
  local identifier such as <code>Horz</code> or <code>Vert</code> in this
  example. The parameters and local variables are all destroyed when the <code>
  #end</code> statement is reached. See &quot;<a href="povdoc_167.html#target_664">Identifier Name Collisions</a>&quot;
  for a detailed discussion of how local identifiers, parameters, and global
  identifiers work when a local identifier has the same name as a previously
  declared identifier.</p>

</div>

<div class="divh4">
<a name="target_697"></a>
<h4>6.2.8.3&nbsp;&nbsp;Are POV-Ray Macros a Function or a Macro?</h4>

  <p>POV-Ray macros are a strange mix of macros and functions. In traditional
  computer programming languages, a macro works entirely by token substitution.
  The body of the routine is inserted into the invocation point by simply
  copying the tokens and parsing them as if they had been cut and pasted in
  place. Such cut-and-paste substitution is often called <em>macro
  substitution</em> because it is what macros are all about. In this respect,
  POV-Ray macros are exactly like traditional macros in that they use macro
  substitution for the body of the macro. However traditional macros also use
  this cut-and-paste substitution strategy for parameters but POV-Ray does
  not.</p><p>
  Suppose you have a macro in the C programming language <code>
  Typical_Cmac(Param)</code> and you invoke it as <code>Typical_Cmac(else
  A=B)</code>. Anywhere that <code>Param</code> appears in the macro body, the
  four tokens <code>else</code>, <code>A</code>, <code>=</code>, and <code>
  B</code> are substituted into the program code using a cut-and-paste
  operation. No type checking is performed because anything is legal. The
  ability to pass an arbitrary group of tokens via a macro parameter is a
  powerful (and sadly often abused) feature of traditional macros.</p><p>
  After careful deliberation, we have decided against this type of parameters
  for our macros. The reason is that POV-Ray uses commas more frequently in its
  syntax than do most programming languages. Suppose you create a macro that is
  designed to operate on one vector and two floats. It might be defined <code>
  OurMac(V,F1,F2)</code>. If you allow arbitrary strings of tokens and invoke a
  macro such as <code>OurMac(&lt;1,2,3&gt;,4,5)</code> then it is impossible to
  tell if this is a vector and two floats or if its 5 parameters with the two
  tokens <code>&lt;</code> and <code>1</code> as the first parameter. If we
  design the macro to accept 5 parameters then we cannot invoke it like this...
  <code>OurMac(MyVector,4,5)</code>.</p><p>
  Function parameters in traditional programming languages do not use token
  substitution to pass values. They create temporary, local variables to store
  parameters that are either constant values or identifier references which are
  in effect a pointer to a variable. POV-Ray macros use this function-like
  system for passing parameters to its macros. In our example <code>
  OurMac(&lt;1,2,3&gt;,4,5)</code>, POV-Ray sees the <code>&lt;</code> and
  knows it must be the start of a vector. It parses the whole vector expression
  and assigns it to the first parameter exactly as though you had used the
  statement <code>#local V=&lt;1,2,3&gt;;</code>.</p><p>
   Although we say that POV-Ray parameters are more like traditional function
  parameters than macro parameters, there still is one difference. Most
  languages require you to declare the type of each parameter in the definition
  before you use it but POV-Ray does not. This should be no surprise because
  most languages require you to declare the type of any identifier before you
  use it but POV-Ray does not. This means that if you pass the wrong type value
  in a POV-Ray macro parameter, it may not generate an error until you
  reference the identifier in the macro body. No type checking is performed as
  the parameter is passed. So in this very limited respect, POV-Ray parameters
  are somewhat macro-like but are mostly function-like.</p>

</div>

<div class="divh4">
<a name="target_698"></a>
<h4>6.2.8.4&nbsp;&nbsp;Returning a Value Like a Function</h4>

  <p>POV-Ray macros have a variety of uses. Like most macros, they provide a
  parameterized way to insert arbitrary code into a scene file. However most
  POV-Ray macros will be used like functions or procedures in a traditional
  programming language. Macros are designed to fill all
  of these roles.</p><p>
   When the body of a macro consists of statements that create an entire item
  such as an object, texture, etc. then the macro acts like a function which
  returns a single value. The <code>Make_Frame</code> macro example in the
  section &quot;<a href="#target_696">Invoking Macros</a>&quot; above is such a macro which returns a
  value that is an object. Here are some examples of how you might invoke
  it.</p>
<pre>
 union {  //make a union of two objects
   object{ Make_Frame(8,10,7,9,1) translate  20*x}
   object{ Make_Frame(8,10,7,9,1) translate -20*x}
 }
 #declare BigFrame = object{ Make_Frame(8,10,7,9,1)}
 #declare SmallFrame = object{ Make_Frame(5,4,4,3,0.5)}
</pre>

  <p>Because no type checking is performed on parameters and because the
  expression syntax for floats, vectors, and colors is identical, you can
  create clever macros which work on all three. See the sample scene <code>
  MACRO3.POV</code> which includes this macro to interpolate values.</p>
<pre>
// Define the macro.  Parameters are:
//   T:  Middle value of time
//   T1: Initial time
//   T2: Final time
//   P1: Initial position (may be float, vector or color)
//   P2: Final position (may be float, vector or color)
//   Result is a value between P1 and P2 in the same proportion
//    as T is between T1 and T2.
#macro Interpolate(T,T1,T2,P1,P2)
   (P1+(T1+T/(T2-T1))*(P2-P1))
#end
</pre>

  <p>You might invoke it with <code>P1</code> and <code>P2</code> as floats,
  vectors, or colors as follows.</p>
<pre>
sphere{
  Interpolate(I,0,15,&lt;2,3,4&gt;,&lt;9,8,7&gt;), //center location is vector
  Interpolate(I,0,15,3.0,5.5)          //radius is float
  pigment {
    color Interpolate(I,0,15,rgb&lt;1,1,0&gt;,rgb&lt;0,1,1&gt;)
  }
}
</pre>

  <p>As the float value <code>I</code> varies from 0 to 15, the location,
  radius, and color of the sphere vary accordingly.</p><p>
   There is a danger in using macros as functions. In a traditional programming
  language function, the result to be returned is actually assigned to a
  temporary variable and the invoking code treats it as a variable of a given
  type. However macro substitution may result in invalid or undesired syntax.
  The definition of the macro <code>Interpolate</code> above has an
  outermost set of parentheses. If those parentheses are omitted, it will not
  matter in the examples above, but what if you do this...</p>
<pre>
 #declare Value = Interpolate(I,0,15,3.0,5.5)*15;
</pre>

  <p>The end result is as if you had done...</p>
<pre>
 #declare Value = P1+(T1+T/(T2-T1))*(P2-P1) * 15;
</pre>

  <p>which is syntactically legal but not mathematically correct because the
  <code>P1</code> term is not multiplied. The parentheses in the original
  example solves this problem. The end result is as if you had done...</p>
<pre>
 #declare Value = (P1+(T1+T/(T2-T1))*(P2-P1)) * 15;
</pre>

  <p>which is correct.</p>

</div>

<div class="divh4">
<a name="target_699"></a>
<h4>6.2.8.5&nbsp;&nbsp;Returning Values Via Parameters</h4>

  <p>Sometimes it is necessary to have a macro return more than one value or
  you may simply prefer to return a value via a parameter as is typical in
  traditional programming language procedures. POV-Ray macros are capable of
  returning values this way. The syntax for POV-Ray macro parameters says that
  the actual parameter may be an <em>IDENTIFIER</em> or an <em> RVALUE</em>.
  Values may only be returned via a parameter if the parameter is an <em>
  IDENTIFIER</em>. Parameters that are <em>RVALUES</em> are constant values
  that cannot return information. An <em>RVALUE</em> is anything that legally
  may appear to the right of an equals sign in a <code> #declare</code> or
  <code>#local</code> directive. For example consider the following trivial
  macro which rotates an object about the x-axis.</p>
<pre>
 #macro Turn_Me(Stuff,Degrees)
   #declare Stuff = object{Stuff rotate x*Degrees}
 #end
</pre>

  <p>This attempts to re-declare the identifier <code>Stuff</code> as the
  rotated version of the object. However the macro might be invoked with <code>
  Turn_Me(box{0,1},30)</code> which uses a box object as an <em> RVALUE</em>
  parameter. This won't work because the box is not an identifier. You can
  however do this</p>
<pre>
   #declare MyObject=box{0,1}
   Turn_Me(MyObject,30)
</pre>

  <p>The identifier <code>MyObject</code> now contains the rotated box.</p><p>
   See &quot;<a href="povdoc_167.html#target_664">Identifier Name Collisions</a>&quot; for a detailed discussion of how
  local identifiers, parameters, and global identifiers work when a local
  identifier has the same name as a previously declared identifier.</p><p>
   While it is obvious that <code>MyObject</code> is an identifier and <code>
  box{0,1}</code> is not, it should be noted that <code>
  Turn_Me(object{MyObject},30)</code> will not work because <code>
  object{MyObject}</code> is considered an object statement and is not a <em>
  pure</em> identifier. This mistake is more likely to be made with float
  identifiers versus float expressions. Consider these examples.</p>
<pre>
  #declare Value=5.0;
  MyMacro(Value)     //MyMacro can change the value of Value but...
  MyMacro(+Value)    //This version and the rest are not lone
  MyMacro(Value+0.0) // identifiers. They are float expressions
  MyMacro(Value*1.0) // which cannot be changed.
</pre>

  <p>Although all four invocations of <code>MyMacro</code> are passed the value
  5.0, only the first may modify the value of the identifier.</p>


</div>
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_172.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_174.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
