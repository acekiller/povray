<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Pattern Modifiers</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_1143"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_216.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_218.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>6.7.12&nbsp;&nbsp;Pattern Modifiers</h3>

<a name="target_1144"></a>

  <p>Pattern modifiers are statements or parameters which modify how a pattern
  is evaluated or tells what to do with the pattern. The complete syntax
  is:</p>
<pre>
PATTERN_MODIFIER:
    BLEND_MAP_MODIFIER | AGATE_MODIFIER | DENSITY_FILE_MODIFIER |
    QUILTED_MODIFIER | BRICK_MODIFIER | SLOPE_MODIFIER |
    noise_generator Number| turbulence &lt;Amount&gt; |
    octaves Count | omega Amount | lambda Amount |
    warp { [WARP_ITEMS...] } | TRANSFORMATION
BLEND_MAP_MODIFIER:
    frequency Amount | phase Amount | ramp_wave | triangle_wave |
    sine_wave | scallop_wave | cubic_wave | poly_wave [Exponent]
AGATE_MODIFIER:
    agate_turb Value
BRICK_MODIFIER:
    brick_size Size | mortar Size 
DENSITY_FILE_MODIFIER:
    interpolate Type
SLOPE_MODIFIERS:
	&lt;Altitude&gt; 
	&lt;Lo_slope,Hi_slope&gt;
    &lt;Lo_alt,	Hi_alt&gt;
QUILTED_MODIFIER:
    control0 Value | control1 Value
PIGMENT_MODIFIER:
    PATTERN_MODIFIER | COLOR_LIST | PIGMENT_LIST |
    color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
    pigment_map{ PIGMENT_MAP_BODY } | quick_color COLOR |
    quick_colour COLOR
COLOR NORMAL_MODIFIER:
    PATTERN_MODIFIER | NORMAL_LIST |
    normal_map { NORMAL_MAP_BODY } | slope_map{ SLOPE_MAP_BODY } |
    bump_size Amount
TEXTURE_PATTERN_MODIFIER:
    PATTERN_MODIFIER | TEXTURE_LIST |
    texture_map{ TEXTURE_MAP_BODY }
DENSITY_MODIFIER:
    PATTERN_MODIFIER | DENSITY_LIST | COLOR_LIST |
    color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
    density_map { DENSITY_MAP_BODY }
</pre>

<p>
Default values for pattern modifiers:
<a name="target_1145"></a>
<pre>
dist_exp        : 0
falloff         : 2.0
frequency       : 1.0
lambda          : 2.0
major_radius    : 1
map_type        : 0
noise_generator : 2
octaves         : 6
omega           : 0.5  
orientation     : &lt;0,0,1&gt;
phase           : 0.0
poly_wave       : 1.0
strength        : 1.0
turbulence      : &lt;0,0,0&gt;
</pre>
</p>

  <p>The modifiers <em>PIGMENT_LIST</em>, <code>quick_color</code>, and <code>
  pigment_map</code> apply only to pigments. See section &quot;<a href="povdoc_206.html#target_1002">Pigment</a>&quot;
  for details on these pigment-specific pattern modifiers.</p><p>
   The modifiers <em> COLOR_LIST</em> and <code>color_map</code> apply only to

  pigments and densities. See sections &quot;<a href="povdoc_206.html#target_1002">Pigment</a>&quot; and
  &quot;<a href="povdoc_221.html#target_1202">Density</a>&quot; for details on these pigment-specific pattern
  modifiers.</p><p>
   The modifiers <em> NORMAL_LIST</em>, <code>bump_size</code>, <code>
  slope_map</code> and <code> normal_map</code> apply only to normals. See
  section &quot;<a href="povdoc_207.html#target_1021">Normal</a>&quot; for details on these normal-specific pattern
  modifiers.</p><p>
   The <em>TEXTURE_LIST</em> and <code>texture_map</code> modifiers can only be
  used with patterned textures. See section &quot;<a href="povdoc_210.html#target_1071">Texture Maps</a>&quot; for
  details.</p><p>
   The <em> DENSITY_LIST</em> and <code> density_map</code> modifiers only work
  with <code>media{density{..}}</code> statements. See &quot;<a href="povdoc_221.html#target_1202">Density</a>&quot; for
  details.</p><p>
   The <code>agate_turb</code> modifier can only be used with the <code>
  agate</code> pattern. See &quot;<a href="povdoc_216.html#target_1090">Agate</a>&quot; for details.</p><p>
   The <code> brick_size</code> and <code>mortar</code> modifiers can only be
  used with the <code> brick</code> pattern. See &quot;<a href="povdoc_216.html#target_1095">Brick</a>&quot; for
  details.</p><p>
   The <code> control0</code> and <code>control1</code> modifiers can only be
  used with the <code>quilted</code> pattern. See &quot;<a href="povdoc_216.html#target_1129">Quilted</a>&quot; for
  details.</p><p>
   The <code> interpolate</code> modifier can only be used with the <code>
  density_file</code> pattern. See &quot;<a href="povdoc_216.html#target_1102">Density_File</a>&quot; for details.</p><p>
   The general purpose pattern modifiers in the following sections can be used
  with <code>pigment</code>, <code>normal</code>, <code>texture</code>, or
  <code> density</code> patterns.</p>

</div>

<div class="divh4">
<a name="target_1146"></a>
<h4>6.7.12.1&nbsp;&nbsp;Transforming Patterns</h4>

  <p>The most common pattern modifiers are the transformation modifiers <code>
  translate</code>, <code>rotate</code>, <code>scale</code>, <code>
  transform</code>, and <code>matrix</code>. For details on these commands see
  section &quot;<a href="povdoc_175.html#target_701">Transformations</a>&quot;.</p><p>
   These modifiers may be placed inside pigment, normal, texture, and density
  statements to change the position, size and orientation of the patterns.</p><p>
   Transformations are performed in the order in which you specify them.
  However in general the order of transformations relative to other pattern
  modifiers such as <code> turbulence</code>, <code> color_map</code> and other
  maps is not important. For example scaling before or after turbulence makes
  no difference. The turbulence is done first, then the scaling regardless of
  which is specified first. However the order in which transformations are
  performed relative to <code>warp</code> statements is important. See
  &quot;Warps&quot; for details.</p>

</div>

<div class="divh4">
<a name="target_1147"></a>
<h4>6.7.12.2&nbsp;&nbsp;Frequency and Phase</h4>

<a name="target_1148"></a>

  <p>The <code>frequency</code> and <code>phase</code> modifiers act as a type
  of scale and translate modifiers for various blend maps. They only have
  effect when blend maps are used. Blend maps are <code> color_map</code>,
  <code>pigment_map</code>, <code>normal_map</code>, <code> slope_map</code>,
  <code>density_map</code>, and <code>texture_map</code>. This discussion uses
  a color map as an example but the same principles apply to the other blend
  map types.</p><p>
   The <code>frequency</code> keyword adjusts the number of times that a color
  map repeats over one cycle of a pattern. For example <code> gradient</code>
  covers color map values 0 to 1 over the range from x=0 to x=1. By adding
  <code>frequency 2.0</code> the color map repeats twice over that same range.
  The same effect can be achieved using <code>scale 0.5*x</code> so the
  frequency keyword isn't that useful for patterns like gradient.</p><p>
   However the radial pattern wraps the color map around the +y-axis once. If
  you wanted two copies of the map (or 3 or 10 or 100) you'd have to build
  a bigger map. Adding <code> frequency 2.0</code> causes the color map to be
  used twice per revolution. Try this:</p>
<pre>
  pigment {
    radial
    color_map{[0.5 color Red][0.5 color White]}
    frequency 6
  }
</pre>

  <p>The result is six sets of red and white radial stripes evenly spaced
  around the object.</p><p>
   The float after <code>frequency</code> can be any value. Values greater than
  1.0 causes more than one copy of the map to be used. Values from 0.0 to 1.0
  cause a fraction of the map to be used. Negative values reverses the map.</p><p>
   The <code>phase</code> value causes the map entries to be shifted so that
  the map starts and ends at a different place. In the example above if you
  render successive frames at <code>phase 0</code> then <code>phase 0.1</code>,
  <code>phase 0.2</code>, etc. you could create an animation that rotates the
  stripes. The same effect can be easily achieved by rotating the <code>
  radial</code> pigment using <code> rotate y*Angle</code> but there are other
  uses where phase can be handy.</p><p>
   Sometimes you create a great looking gradient or wood color map but you want
  the grain slightly adjusted in or out. You could re-order the color map
  entries but that's a pain. A phase adjustment will shift everything but
  keep the same scale. Try animating a <code>mandel</code> pigment for a color
  palette rotation effect.</p><p>
  These values work by applying the following formula</p><p>
   <em> New_Value = fmod ( Old_Value * Frequency + Phase, 1.0 ). </em></p><p>
  The <code>frequency</code> and <code>phase</code> modifiers have no
  effect on block patterns <code> checker</code>, <code>brick</code>, and
  <code> hexagon</code> nor do they effect <code>image_map</code>, <code>
  bump_map</code> or <code> material_map</code>. They also have no effect in
  normal statements when used with <code>bumps</code>, <code>dents</code>,
  <code>quilted</code> or <code> wrinkles</code> because these normal patterns
  cannot use <code> normal_map</code> or <code>slope_map</code>.</p><p>
   They can be used with normal patterns <code>ripples</code> and <code>
  waves</code> even though these two patterns cannot use <code>
  normal_map</code> or <code>slope_map</code> either. When used with <code>
  ripples</code> or <code>waves</code>, <code> frequency</code> adjusts the
  space between features and <code>phase</code> can be adjusted from 0.0 to 1.0
  to cause the ripples or waves to move relative to their center for animating
  the features.</p>

</div>

<div class="divh4">
<a name="target_1149"></a>
<h4>6.7.12.3&nbsp;&nbsp;Waveforms</h4>

<a name="target_1150"></a>

  <p>POV-Ray allows you to apply various wave forms to the pattern function
  before applying it to a blend map. Blend maps are <code>color_map</code>,
  <code>pigment_map</code>, <code>normal_map</code>, <code>slope_map</code>,
  <code>density_map</code>, and <code>texture_map</code>.</p><p>
   Most of the patterns which use a blend map, use the entries in the map in
  order from 0.0 to 1.0. The effect can most easily be seen when these patterns
  are used as normal patterns with no maps. Patterns such as <code>
  gradient</code> or <code> onion</code> generate a groove or slot that looks
  like a ramp that drops off sharply. This is called a <code>ramp_wave</code>
  wave type and it is the default wave type for most patterns. However the
  <code>wood</code> and <code> marble</code> patterns use the map from 0.0 to
  1.0 and then reverses it and runs it from 1.0 to 0.0. The result is a wave
  form which slopes upwards to a peak, then slopes down again in a <code>
  triangle_wave</code>. In earlier versions of POV-Ray there was no way to
  change the wave types. You could simulate a triangle wave on a ramp wave
  pattern by duplicating the map entries in reverse, however there was no way
  to use a ramp wave on wood or marble.</p><p>
   Now any pattern that takes a map can have the default wave type overridden.
  For example:</p>
<pre>
  pigment { wood color_map { MyMap } ramp_wave }
</pre>

<a name="target_1151"></a>

  <p>Also available are <code>sine_wave</code>, <code>scallop_wave</code>,
  <code>cubic_wave</code> and <code>poly_wave</code> types. These types are of
  most use in normal patterns as a type of built-in slope map. The <code>
  sine_wave</code> takes the zig-zag of a ramp wave and turns it into a gentle
  rolling wave with smooth transitions. The <code>scallop_wave</code> uses the
  absolute value of the sine wave which looks like corduroy when scaled small
  or like a stack of cylinders when scaled larger. The <code> cubic_wave</code>
  is a gentle cubic curve from 0.0 to 1.0 with zero slope at the start and end.
  The <code>poly_wave</code> is an exponential function. It is followed by an
  optional float value which specifies exponent. For example <code>poly_wave
  2</code> starts low and climbs rapidly at the end while <code>poly_wave
  0.5</code> climbs rapidly at first and levels off at the end. If no float
  value is specified, the default is 1.0 which produces a linear function
  identical to <code>ramp_wave</code>.</p><p>
   Although any of these wave types can be used for pigments, normals,
  textures, or density the effect of many of the wave types are not as
  noticeable on pigments, textures, or density as they are for normals.</p><p>
   Wave type modifiers have no effect on block patterns <code> checker</code>,
  <code>brick</code>, <code>object</code> and <code>hexagon</code> nor do they effect <code>
  image_map</code>, <code>bump_map</code> or <code> material_map</code>. They
  also have no effect in normal statements when used with <code>bumps</code>,
  <code>dents</code>, <code>quilted</code>, <code> ripples</code>, <code>
  waves</code>, or <code>wrinkles</code> because these normal patterns cannot
  use <code>normal_map</code> or <code> slope_map</code>.</p>

</div>

<div class="divh4">
<a name="target_1152"></a>
<h4>6.7.12.4&nbsp;&nbsp;Noise Generators</h4>
<a name="target_1153"></a>

  <p> There are three noise generators implemented. Changing the <code>noise_generator</code> will change 
   the appearence of noise based patterns, like bozo and granite.</p>
  <ul>
  <li><code>noise_generator 1</code> the noise that was used in POV_Ray 3.1</li>
  <li><code>noise_generator 2</code> 'range corrected' version of the old noise, it does not show 
  the plateaus seen with <code>noise_generator 1</code> </li>
  <li><code>noise_generator 3</code> generates Perlin noise</li>
  </ul>
  <p>The default is <code>noise_generator 2</code></P>
  <p class="Note"><strong>Note:</strong> The noise_generator can also be set in <code>global_settings</code></p>

</div>

<div class="divh4">
<a name="target_1154"></a>
<h4>6.7.12.5&nbsp;&nbsp;Turbulence</h4>

<p>The <code>turbulence</code> pattern modifier is still supported for compatibility
   issues, but it's better nowadays to use the <code><a href="#target_1168">warp {turbulence}</a></code> feature,
   which doesn't have turbulence's limitation in transformation order
   (turbulence is always applied first, before any scale, translate or
    rotate, whatever the order you specify). For a detailed discussion see
<a href="#target_1166">'Turbulence versus Turbulence Warp'</a></p>
<p> The old-style turbulence is handled slightly differently when used with the
 agate, marble, spiral1, spiral2, and wood textures.</p>


</div>

<div class="divh4">
<a name="target_1155"></a>
<h4>6.7.12.6&nbsp;&nbsp;Warps</h4>

<a name="target_1156"></a>

  <p>The <code>warp</code> statement is a pattern modifier that is similar to
  turbulence. Turbulence works by taking the pattern evaluation point and
  pushing it about in a series of random steps. However warps push the point in
  very well-defined, non-random, geometric ways. The <code>warp</code>
  statement also overcomes some limitations of traditional turbulence and
  transformations by giving the user more control over the order in which
  turbulence, transformation and warp modifiers are applied to the pattern.</p><p>
  Currently there are seven types of warps but the syntax was designed to allow
  future expansion. The turbulence warp provides an alternative way to
  specify turbulence. The others modify the pattern in geometric ways.</p><p>
  The syntax for using a <code>warp</code> statement is:</p>
<pre>
WARP:
    warp { WARP_ITEM }
WARP_ITEM:
    repeat &lt;Direction&gt; [REPEAT_ITEMS...] |
    black_hole &lt;Location&gt;, Radius [BLACK_HOLE_ITEMS...] | 
    turbulence &lt;Amount&gt; [TURB_ITEMS...]
    cylindrical  [ orientation VECTOR | dist_exp FLOAT ]
    spherical  [ orientation VECTOR | dist_exp FLOAT ]
    toroidal  [ orientation VECTOR | dist_exp FLOAT |
                major_radius FLOAT ]
    planar [ VECTOR , FLOAT ]
REPEAT_ITEMS:
    offset &lt;Amount&gt; | 
    flip &lt;Axis&gt;
BLACK_HOLE_ITEMS:
    strength Strength | falloff Amount | inverse |
    repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
TURB_ITEMS:
    octaves Count | omega Amount | lambda Amount
</pre>

  <p>You may have as many separate warp statements as you like in each pattern.
  The placement of warp statements relative to other modifiers such as <code>
  color_map</code> or <code>turbulence</code> is not important. However
  placement of warp statements relative to each other and to transformations is
  significant. Multiple warps and transformations are evaluated in the order in
  which you specify them. For example if you translate, then warp or warp, then
  translate, the results can be different.</p>

</div>

<div class="divh5">
<a name="target_1157"></a>
<h5>6.7.12.6.1&nbsp;&nbsp;Black Hole Warp</h5>

<a name="target_1158"></a>

<a name="target_1159"></a>

<a name="target_1160"></a>

  <p>A <code>black_hole</code> warp is so named because of its similarity to
  real black holes. Just like the real thing, you cannot actually see a black
  hole. The only way to detect its presence is by the effect it has on things
  that surround it.</p><p>
   Take, for example, a wood grain. Using POV-Ray's normal turbulence and
  other texture modifier functions, you can get a nice, random appearance to
  the grain. But in its randomness it is regular - it is regularly random!
  Adding a black hole allows you to create a localized disturbance in a wood
  grain in either one or multiple locations. The black hole can have the effect
  of either <em>sucking</em> the surrounding texture into itself (like the real
  thing) or <em>pushing</em> it away. In the latter case, applied to a wood
  grain, it would look to the viewer as if there were a knothole in the wood.
  In this text we use a wood grain regularly as an example, because it is
  ideally suitable to explaining black holes. However, black holes may in fact
  be used with any texture or pattern. The effect that the black hole has on
  the texture can be specified. By default, it <em>sucks</em> with the
  strength calculated exponentially (inverse-square). You can change this if
  you like.</p><p>
   Black holes may be used anywhere a warp is permitted. The syntax is:</p>
<pre>
BLACK_HOLE_WARP:
    warp
    {
        black_hole &lt;Location&gt;, Radius
        [BLACK_HOLE_ITEMS...]
    }
BLACK_HOLE_ITEMS:
    strength Strength | falloff Amount | inverse | type Type | 
    repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
</pre>

  <p>The minimal requirement is the <code>black_hole</code> keyword followed by
  a vector <em><code>&lt;Location&gt;</code></em> followed by a comma and a
  float <em><code>Radius</code></em>. Black holes effect all points within the
  spherical region around the location and within the radius. This is
  optionally followed by any number of other keywords which control how the
  texture is warped.</p><p>
   The <code>falloff</code> keyword may be used with a float value to specify
  the power by which the effect of the black hole falls off. The default is
  two. The force of the black hole at any given point, before applying the
  <code>strength</code> modifier, is as follows.</p><p>
   First, convert the distance from the point to the center to a proportion (0
  to 1) that the point is from the edge of the black hole. A point on the
  perimeter of the black hole will be 0.0; a point at the center will be 1.0; a
  point exactly halfway will be 0.5, and so forth. Mentally you can consider
  this to be a closeness factor. A closeness of 1.0 is as close as you can get
  to the center (i.e. at the center), a closeness of 0.0 is as far away as you
  can get from the center and still be inside the black hole and a closeness of
  0.5 means the point is exactly halfway between the two.</p><p>
   Call this value c. Raise c to the power specified in <code>falloff</code>.
  By default Falloff is 2, so this is c^2 or c squared. The resulting value is
  the force of the black hole at that exact location and is used, after
  applying the <code>strength</code> scaling factor as described below, to
  determine how much the point is perturbed in space. For example, if c is 0.5
  the force is 0.5^2 or 0.25. If c is 0.25 the force is 0.125. But if c is
  exactly 1.0 the force is 1.0. Recall that as c gets smaller the point is
  farther from the center of the black hole. Using the default power of 2, you
  can see that as c reduces, the force reduces exponentially in an
  inverse-square relationship. Put in plain English, it means that the force is
  much stronger (by a power of two) towards the center than it is at the
  outside.</p><p>
   By increasing <code>falloff</code>, you can increase the magnitude of the
  falloff. A large value will mean points towards the perimeter will hardly be
  affected at all and points towards the center will be affected strongly. A
  value of 1.0 for <code>falloff</code> will mean that the effect is linear. A
  point that is exactly halfway to the center of the black hole will be
  affected by a force of exactly 0.5. A value of <code>falloff</code> of less
  than one but greater than zero means that as you get closer to the outside,
  the force increases rather than decreases. This can have some uses but there
  is a side effect. Recall that the effect of a black hole ceases outside its
  perimeter. This means that points just within the perimeter will be affected
  strongly and those just outside not at all. This would lead to a visible
  border, shaped as a sphere. A value for <code> falloff</code> of 0 would mean
  that the force would be 1.0 for all points within the black hole, since any
  number larger 0 raised to the power of 0 is 1.0.</p><p>
   The <code>strength</code> keyword may be specified with a float value to
  give you a bit more control over how much a point is perturbed by the black
  hole. Basically, the force of the black hole (as determined above) is
  multiplied by the value of <code>strength</code>, which defaults to 1.0. If
  you set strength to 0.5, for example, all points within the black hole will
  be moved by only half as much as they would have been. If you set it to 2.0
  they will be moved twice as much.</p><p>
   There is a rider to the latter example, though - the movement is clipped to
  a maximum of the original distance from the center. That is to say, a point
  that is 0.75 units from the center may only be moved by a maximum of 0.75
  units either towards the center or away from it, regardless of the value of
  <code> strength</code>. The result of this clipping is that you will have an
  exclusion area near the center of the black hole where all points whose final
  force value exceeded or equaled 1.0 were moved by a fixed amount.</p><p>
   If the <code>inverse</code> keyword is specified then the points <em>
  pushed</em> away from the center instead of being pulled in.</p><p>
   The <code>repeat</code> keyword followed by a vector, allows you to simulate
  the effect of many black holes without having to explicitly declare them.
  Repeat is a vector that tells POV-Ray to use this black hole at multiple
  locations. Using <code>repeat</code> logically divides your scene up into
  cubes, the first being located at &lt;0,0,0&gt; and going to <em><code>
  &lt;Repeat&gt;</code></em>. Suppose your repeat vector was &lt;1,5,2&gt;. The
  first cube would be from &lt;0,0,0&gt; to &lt; 1,5,2&gt;. This cube repeats,
  so there would be one at &lt; -1,-5,-2&gt;, &lt;1,5,2&gt;, &lt;2,10,4&gt; and
  so forth in all directions, ad infinitum.</p><p>
   When you use <code>repeat</code>, the center of the black hole does not
  specify an absolute location in your scene but an offset into each block. It
  is only possible to use positive offsets. Negative values will produce
  undefined results.</p><p>
   Suppose your center was &lt;0.5,1,0.25&gt; and the repeat vector is
  &lt;2,2,2&gt;. This gives us a block at &lt; 0,0,0&gt; and &lt;2,2,2&gt;,
  etc. The centers of the black hole's for these blocks would be
  &lt;0,0,0&gt; + &lt; 0.5,1.0,0.25&gt;, i. e. &lt;0.5,1.0,0.25&gt;, and &lt;
  2,2,2&gt; + &lt;0.5,1.0,0.25&gt;, i. e. &lt; 2,5,3.0,2.25&gt;.</p><p>
   Due to the way repeats are calculated internally, there is a restriction on
  the values you specify for the repeat vector. Basically, each black hole must
  be totally enclosed within each block (or cube), with no part crossing into a
  neighboring one. This means that, for each of the x, y and z dimensions, the
  offset of the center may not be less than the radius, and the repeat value
  for that dimension must be &gt;=the center plus the radius since any other
  values would allow the black hole to cross a boundary. Put another way, for
  each of x, y and z</p>

  <p> Radius &lt;= Offset or Center &lt;= Repeat - Radius.</p>

  <p>If the repeat vector in any dimension is too small to fit this criteria,
  it will be increased and a warning message issued. If the center is less than
  the radius it will also be moved but no message will be issued.</p><p>
   Note that none of the above should be read to mean that you can't
  overlap black holes. You most certainly can and in fact this can produce some
  most useful effects. The restriction only applies to elements of the <code>
  same</code> black hole which is repeating. You can declare a second black
  hole that also repeats and its elements can quite happily overlap the first
  and causing the appropriate interactions. It is legal for the repeat value
  for any dimension to be 0, meaning that POV-Ray will not repeat the black
  hole in that direction.</p><p>
   The <code>turbulence</code> can only be used in a black hole with <code>
  repeat</code>. It allows an element of randomness to be inserted into the way
  the black holes repeat, to cause a more natural look. A good example would be
  an array of knotholes in wood - it would look rather artificial if each
  knothole were an exact distance from the previous.</p><p>
   The <code> turbulence</code> vector is a measurement that is added to each
  individual black hole in an array, after each axis of the vector is multiplied
  by a different random amount ranging from 0 to 1. The resulting actual
  position of the black hole's center for that particular repeat element is
  random (but consistent, so renders will be repeatable) and somewhere within
  the above co-ordinates. There is a rider on the use of turbulence, which
  basically is the same as that of the repeat vector. You can't specify a
  value which would cause a black hole to potentially cross outside of its
  particular block.</p><p>
   In summary: For each of x, y and z the offset of the center must be
  &gt;=radius and the value of the repeat must be &gt;= center + radius +
  turbulence. The exception being that repeat may be 0 for any dimension, which
  means do not repeat in that direction.</p><p>
   Some examples are given by</p>
<pre>
  warp {
    black_hole &lt;0, 0, 0&gt;, 0.5
  }
  warp {
    black_hole &lt;0.15, 0.125, 0&gt;, 0.5
    falloff 7
    strength 1.0
    repeat &lt;1.25, 1.25, 0&gt;
    turbulence &lt;0.25, 0.25, 0&gt;
    inverse
  }
  warp {
    black_hole &lt;0, 0, 0&gt;, 1.0
    falloff 2
    strength 2
    inverse
  }
</pre>

</div>

<div class="divh5">
<a name="target_1161"></a>
<h5>6.7.12.6.2&nbsp;&nbsp;Repeat Warp</h5>

<a name="target_1162"></a>

  <p>The <code>repeat</code> warp causes a section of the pattern to be
  repeated over and over. It takes a slice out of the pattern and makes
  multiple copies of it side-by-side. The warp has many uses but was originally
  designed to make it easy to model wood veneer textures. Veneer is made by
  taking very thin slices from a log and placing them side-by-side on some
  other backing material. You see side-by-side nearly identical ring patterns
  but each will be a slice perhaps 1/32th of an inch deeper.</p><p>
   The syntax for a repeat warp is</p>
<pre>
REPEAT_WARP:
    warp { repeat &lt;Direction&gt; [REPEAT_ITEMS...] }
REPEAT_ITEMS:
    offset &lt;Amount&gt; | flip &lt;Axis&gt;
</pre>

  <p>The <code>repeat</code> vector specifies the direction in which the
  pattern repeats and the width of the repeated area. This vector must lie
  entirely along an axis. In other words, two of its three components must be
  0. For example</p>
<pre>
  pigment {
    wood
    warp { repeat 2*x }
  }
</pre>

<a name="target_1163"></a>

<a name="target_1164"></a>

  <p>which means that from x=0 to x=2 you get whatever the pattern usually is.
  But from x=2 to x=4 you get the same thing exactly shifted two units over in
  the x-direction. To evaluate it you simply take the x-coordinate modulo 2.
  Unfortunately you get exact duplicates which isn't very realistic. The
  optional <code>offset</code> vector tells how much to translate the pattern
  each time it repeats. For example</p>
<pre>
  pigment {
    wood
    warp {repeat x*2  offset z*0.05}
  }
</pre>

  <p>means that we slice the first copy from x=0 to x=2 at z=0 but at x=2 to
  x=4 we offset to z=0.05. In the 4 to 6 interval we slice at z=0.10. At the
  n-th copy we slice at 0.05 n z. Thus each copy is slightly different. There
  are no restrictions on the offset vector.</p><p>

<a name="target_1165"></a>

   Finally the <code>flip</code> vector causes the pattern to be flipped or
  mirrored every other copy of the pattern. The first copy of the pattern in
  the positive direction from the axis is not flipped. The next farther is, the
  next is not, etc. The flip vector is a three component x, y, z vector but
  each component is treated as a boolean value that tells if you should or
  should not flip along a given axis. For example</p>
<pre>
  pigment {
    wood
    warp {repeat 2*x  flip &lt;1,1,0&gt;}
  }
</pre>

  <p>means that every other copy of the pattern will be mirrored about the x-
  and y- axis but not the z-axis. A non-zero value means flip and zero means do
  not flip about that axis. The magnitude of the values in the flip vector
  doesn't matter.</p>

</div>

<div class="divh5">
<a name="target_1166"></a>
<h5>6.7.12.6.3&nbsp;&nbsp;Turbulence versus Turbulence Warp</h5>

<a name="target_1167"></a>

  <p>The POV-Ray language contains an ambiguity and limitation on the way you
  specify <code>turbulence</code> and transformations such as <code>
  translate</code>, <code>rotate</code>, <code>scale</code>, <code>
  matrix</code>, and <code>transform</code> transforms. Usually the turbulence
  is done first. Then all translate, rotate, scale, matrix, and transform
  operations are always done after turbulence regardless of the order in which
  you specify them. For example this</p>
<pre>
 pigment {
   wood
   scale .5
   turbulence .2
 }
</pre>

  <p>works exactly the same as</p>
<pre>
 pigment {
   wood
   turbulence .2
   scale .5
 }
</pre>

  <p>The turbulence is always first. A better example of this limitation is
  with uneven turbulence and rotations.</p>
<pre>
  pigment {
    wood
    turbulence 0.5*y
    rotate z*60
  }
  // as compared to
  pigment {
   wood
   rotate z*60
   turbulence 0.5*y
  }
</pre>

  <p>The results will be the same either way even though you'd think it
  should look different.</p><p>
   We cannot change this basic behavior in POV-Ray now because lots of scenes
  would potentially render differently if suddenly the order transformation vs.
  turbulence mattered when in the past, it didn't.</p><p>
   However, by specifying our turbulence inside warp statement you tell POV-Ray
  that the order in which turbulence, transformations and other warps are
  applied is significant. Here's an example of a turbulence warp.</p>
<pre>
  warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
</pre>

  <p>The significance is that this</p>
<pre>
 pigment {
   wood
   translate &lt;1,2,3&gt; rotate x*45 scale 2
   warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
 }
</pre>

  <p>produces <em>different results</em> than this...</p>
<pre>
 pigment {
   wood
   warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
   translate &lt;1,2,3&gt; rotate x*45 scale 2
 }
</pre>

  <p>You may specify turbulence without using a warp statement. However you
  cannot control the order in which they are evaluated unless you put them in a
  warp.</p><p>
   The evaluation rules are as follows:</p>
  <ol>
    <li>First any turbulence not inside a warp statement is applied regardless
        of the order in which it appears relative to warps or transformations.</li>
    <li>Next each warp statement, translate, rotate, scale or matrix one-by-one,
        is applied in the order the user specifies. If you want turbulence done in a
        specific order, you simply specify it inside a warp in the proper place.</li>
  </ol>

</div>

<div class="divh5">
<a name="target_1168"></a>
<h5>6.7.12.6.4&nbsp;&nbsp;Turbulence Warp</h5>
  <p>Inside the <code>warp</code> statement, the keyword <code>turbulence</code> followed by a float or vector may be
  used to stir up any <code>pigment</code>, <code>normal</code> or <code>density</code>. A number of
  optional parameters may be used with turbulence to control how it is
  computed. The syntax is:</p>
<pre>
TURBULENCE_ITEM:
    turbulence &lt;Amount&gt; | octaves Count |
    omega Amount | lambda Amount
</pre>

  <p>Typical turbulence values range from the default 0.0, which is no
  turbulence, to 1.0 or more, which is very turbulent. If a vector is specified
  different amounts of turbulence are applied in the x-, y- and z-direction.
  For example</p>
<pre>
  turbulence &lt;1.0, 0.6, 0.1&gt;
</pre>

  <p>has much turbulence in the x-direction, a moderate amount in the
  y-direction and a small amount in the z-direction.</p><p>
   Turbulence uses a random noise function called <em>DNoise</em>. This is
  similar to the noise used in the <code>bozo</code> pattern except that
  instead of giving a single value it gives a direction. You can think of it as
  the direction that the wind is blowing at that spot. Points close together
  generate almost the same value but points far apart are randomly
  different.</p><p>
   Turbulence uses <em>DNoise</em> to push a point around in several steps
  called <code>octaves</code>. We locate the point we want to evaluate, then
  push it around a bit using turbulence to get to a different point then look
  up the color or pattern of the new point.</p><p>
   It says in effect <em> &quot;Don't give me the color at this spot...
  take a few random steps in different directions and give me that
  color&quot;</em>. Each step is typically half as long as the one before. For
  example:</p>

   
<center><img src="images/turbrand.gif" alt="Turbulence random walk"><br><font size=-1><cite>Turbulence random walk</cite></font></center>


  <p>The magnitude of these steps is controlled by the turbulence value. There
  are three additional parameters which control how turbulence is computed.
  They are <code>octaves</code>, <code>lambda</code> and <code> omega</code>.
  Each is optional. Each is followed by a single float value. Each has no
  effect when there is no turbulence.</p>

</div>

<div class="divh6">
<a name="target_1169"></a>
<h5>6.7.12.6.4.1&nbsp;&nbsp;Octaves</h5>

  <p>The <code>octaves</code> keyword may be followed by an integer value to
  control the number of steps of turbulence that are computed. Legal values
  range from 1 to &lt;10. The default value of 6 is a fairly high value; you
  won't see much change by setting it to a higher value because the extra
  steps are too small. Float values are truncated to integer. Smaller numbers
  of octaves give a gentler, wavy turbulence and computes faster. Higher
  octaves create more jagged or fuzzy turbulence and takes longer to
  compute.</p>

</div>

<div class="divh6">
<a name="target_1170"></a>
<h5>6.7.12.6.4.2&nbsp;&nbsp;Lambda</h5>

  <p>The <code>lambda</code> parameter controls how statistically different the
  random move of an octave is compared to its previous octave. The default
  value is 2.0 which is quite random. Values close to lambda 1.0 will
  straighten out the randomness of the path in the diagram above. The zig-zag
  steps in the calculation are in nearly the same direction. Higher values can
  look more <em>swirly</em> under some circumstances.</p>

</div>

<div class="divh6">
<a name="target_1171"></a>
<h5>6.7.12.6.4.3&nbsp;&nbsp;Omega</h5>

  <p>The <code>omega</code> value controls how large each successive octave
  step is compared to the previous value. Each successive octave of turbulence
  is multiplied by the omega value. The default <code>omega 0.5</code> means
  that each octave is 1/2 the size of the previous one. Higher omega values
  mean that 2nd, 3rd, 4th and up octaves contribute more turbulence giving a
  sharper, <em>crinkly</em> look while smaller omegas give a fuzzy kind of
  turbulence that gets blurry in places.</p>



</div>

<div class="divh5">
<a name="target_1172"></a>
<h5>6.7.12.6.5&nbsp;&nbsp;Mapping using warps</h5>
<a name="target_1173"></a>

<a name="target_1174"></a>
<a name="target_1175"></a>
<a name="target_1176"></a>
<a name="target_1177"></a>
  <p>Syntax:</p>
  <pre>
  CYLINDRICAL_WARP:
    warp { cylindrical [CYLINDRICAL_ITEMS...]}
  CYLINDRICAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT
  SPHERICAL_WARP:
    warp { spherical [SPHERICAL_ITEMS...]}
  SPHERICAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT
  TOROIDAL_WARP:
    warp { toroidal [TOROIDAL_ITEMS...]}
  TOROIDAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT | major_radius FLOAT
  PLANAR_WARP:
    warp { planar [ VECTOR , FLOAT ]}
  </pre>
  <p>With the <code>cylindrical, spherical</code> and <code>toroidal</code> warps you can wrap checkers, 
  bricks and other patterns around cylinders, spheres, toruses and other objects. In essence, these 
  warps use the same mapping as the image maps use.</p>

  <p>However it does 3D mapping and some concession had to be made on depth. This is controllable by
  <code>dist_exp</code> (distance exponent). In the default of 0, imagine a box &lt;0,0&gt; to &lt;1,1&gt;
  (actually it is &lt;0,0&gt;, &lt;<code>dist^dist_exp,dist^dist_exp</code>&gt;) stretching to infinity
  along the orientation vector.  The warp takes its points from that box.</p>

  <p>For a sphere <code>distance</code> is distance from origin, cylinder is distance from 
  y-axis, torus is distance from major radius. (or distance is minor radius if you prefer 
  to look at it that way)</p>

  <p>Defaults:
   <code>
    orientation &lt;0,0,1&gt;<br>
    dist_exp 0<br>
    major_radius 1<br>
   </code>
   </p>

   <p>Examples:</p>
   <pre>
   torus {
     1, 0.5
     pigment {
       hexagon
       scale 0.1
       warp {
         toroidal 
         orientation y 
         dist_exp 1 
         major_radius 1
       }
     }
   }
   sphere {
     0,1
     pigment {
       hexagon
       scale &lt;0.5/pi,0.25/pi,1&gt;*0.1
       warp {
         spherical
         orientation y 
         dist_exp 1 
       }
     }
   }
   cylinder {
     -y, y, 1
     pigment {
       hexagon
       scale &lt;0.5/pi, 1, 1&gt;*0.1
       warp {
         cylindrical 
         orientation y 
         dist_exp 1 
       }
     }
   }
</pre>

  <p>The <code>planar</code> warp was made to make a pattern act like an image_map,
     of infinite size and can be usefull in combination with other mapping-warps.
     By default the pigment in the XY-plane is extruded along 
     the Z-axis. The pigment can be taken from an other plane, by specifying the
     optional vector (normal of the plane) and float (distance along the normal).
     The result, again, is extruded along the Z-axis.</p>


</div>

<div class="divh4">
<a name="target_1178"></a>
<h4>6.7.12.7&nbsp;&nbsp;Bitmap Modifiers</h4>

  <p>A bitmap modifier is a modifier used inside an <code>image_map</code>,
  <code>bump_map</code> or <code>material_map</code> to specify how the 2-D
  bitmap is to be applied to the 3-D surface. Several bitmap modifiers apply to
  specific kinds of maps and they are covered in the appropriate sections. The
  bitmap modifiers discussed in the following sections are applicable to all
  three types of bitmaps.</p>

</div>

<div class="divh5">
<a name="target_1179"></a>
<h5>6.7.12.7.1&nbsp;&nbsp;The once Option</h5>

<a name="target_1180"></a>

  <p>Normally there are an infinite number of repeating image maps, bump maps
  or material maps created over every unit square of the x-y-plane like tiles.
  By adding the <code>once</code> keyword after a file name you can eliminate
  all other copies of the map except the one at (0,0) to (1,1). In image maps,
  areas outside this unit square are treated as fully transparent. In bump
  maps, areas outside this unit square are left flat with no normal
  modification. In material maps, areas outside this unit square are textured
  with the first texture of the texture list.</p><p>
   For example:</p>
<pre>
  image_map {
    gif &quot;mypic.gif&quot;
    once
  }
</pre>

</div>

<div class="divh5">
<a name="target_1181"></a>
<h5>6.7.12.7.2&nbsp;&nbsp;The map_type Option</h5>

<a name="target_1182"></a>

  <p>The default projection of the image onto the x-y-plane is called a <em>
  planar map type</em>. This option may be changed by adding the <code>
  map_type</code> keyword followed by an integer number specifying the way to
  wrap the image around the object.</p><p>
   A <code>map_type 0</code> gives the default planar mapping already
  described.</p><p>
   A <code>map_type 1</code> gives a spherical mapping. It assumes that the
  object is a sphere of any size sitting at the origin. The y-axis is the
  north/south pole of the spherical mapping. The top and bottom edges of the
  image just touch the pole regardless of any scaling. The left edge of the
  image begins at the positive x-axis and wraps the image around the sphere
  from west to east in a -y-rotation. The image covers the sphere exactly once.
  The <code> once</code> keyword has no meaning for this mapping type.</p><p>
   With <code> map_type 2</code> you get a cylindrical mapping. It assumes that
  a cylinder of any diameter lies along the y-axis. The image wraps around the
  cylinder just like the spherical map but the image remains one unit tall from
  y=0 to y=1. This band of color is repeated at all heights unless the <code>
  once</code> keyword is applied.</p><p>
   Finally <code>map_type 5</code> is a torus or donut shaped mapping. It
  assumes that a torus of major radius one sits at the origin in the x-z-plane.
  The image is wrapped around similar to spherical or cylindrical maps. However
  the top and bottom edges of the map wrap over and under the torus where they
  meet each other on the inner rim.</p><p>
   Types 3 and 4 are still under development.</p>
   <p class="Note"><strong>Note:</strong> that the <code> map_type</code> option may also be applied to <code>
  bump_map</code> and <code>material_map</code> statements.</p><p>
   For example:</p>
<pre>
  sphere{&lt;0,0,0&gt;,1
    pigment{
      image_map {
        gif &quot;world.gif&quot;
        map_type 1
      }
    }
  }
</pre>

</div>

<div class="divh5">
<a name="target_1183"></a>
<h5>6.7.12.7.3&nbsp;&nbsp;The interpolate Option</h5>

<a name="target_1184"></a>

  <p>Adding the <code>interpolate</code> keyword can smooth the jagged look of
  a bitmap. When POV-Ray checks a color for an image map or a bump
  amount for a bump map, it often checks a point that is not directly on
  top of one pixel but sort of between several differently colored
  pixels. Interpolations return an in-between value so that the steps between
  the pixels in the map will look
  smoother.</p><p>
   Although <code>interpolate</code> is legal in material maps, the color index
  is interpolated before the texture is chosen. It does not interpolate the
  final color as you might hope it would. In general, interpolation of material
  maps serves no useful purpose but this may be fixed in future versions.</p><p>
   There are currently two types of interpolation: <code> interpolate 2</code>
  gives bilinear interpolation while <code>interpolate 4</code> gives
  normalized distance. For example:</p>
<pre>
  image_map {
    gif &quot;mypic.gif&quot;
    interpolate 2
  }
</pre>

  <p>Default is no interpolation. Normalized distance is the slightly faster of
  the two, bilinear does a better job of picking the between color. Normally
  bilinear is used.</p><p>
   If your map looks jaggy, try using interpolation instead of going to a
  higher resolution image. The results can be very good.</p>
</div>
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_216.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_218.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
