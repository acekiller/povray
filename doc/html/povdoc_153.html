<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Tracing Options</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_492"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_152.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_154.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>5.2.6&nbsp;&nbsp;Tracing Options</h3>

  <p>There is more than one way to trace a ray. Sometimes there is a trade-off
  between quality and speed. Sometimes options designed to make tracing faster
  can slow things down. This section covers options that tell POV-Ray how to
  trace rays with the appropriate speed and quality settings.</p>

</div>

<div class="divh4">
<a name="target_493"></a>
<h4>5.2.6.1&nbsp;&nbsp;Quality Settings</h4>

  <table SUMMARY="">
   <tr>
<a name="target_494"></a>

    <td><code>Quality=</code>n</td>

    <td>Set quality value to n (0 &lt;= n &lt;= 11)</td>
   </tr>

   <tr>
<a name="target_495"></a>
    <td><code>+Q</code>n</td>

    <td>Same as <code>Quality=</code>n</td>
   </tr>
  </table>

  <p>The <code>Quality=</code><em>n</em> option or <code>+Q</code><em>n</em>
  switch allows you to specify the image rendering quality. You may choose to
  lower the quality for test rendering and raise it for final renders. The
  quality adjustments are made by eliminating some of the calculations that are
  normally performed. For example settings below 4 do not render shadows.
  Settings below 8 do not use reflection or refraction. The duplicate values
  allow for future expansion. The values correspond to the following quality
  levels:</p>

  <table SUMMARY="">
   <tr>
    <td><code>0, 1</code></td>

    <td>Just show quick colors. Use full ambient lighting only. Quick colors
    are used only at 5 or below.</td>
   </tr>

   <tr>
    <td><code>2, 3</code></td>

    <td>Show specified diffuse and ambient light.</td>
   </tr>

   <tr>
    <td><code>4</code></td>

    <td>Render shadows, but no extended lights.</td>
   </tr>

   <tr>
    <td><code>5</code></td>

    <td>Render shadows, including extended lights.</td>
   </tr>

   <tr>
    <td><code>6, 7</code></td>

    <td>Compute texture patterns, compute photons</td>
   </tr>

   <tr>
    <td><code>8</code></td>

    <td>Compute reflected, refracted, and transmitted rays.</td>
   </tr>

   <tr>
    <td><code>9, 10, 11</code></td>

    <td>Compute media and radiosity</td>
   </tr>
  </table>

  <p>The default is 9 if not specified.</p>


</div>

<div class="divh4">
<a name="target_496"></a>
<h4>5.2.6.2&nbsp;&nbsp;Automatic Bounding Control</h4>

  <table SUMMARY="">
   <tr>
<a name="target_497"></a>

    <td><code>Bounding=</code>bool</td>

    <td>Turn bounding on/off</td>
   </tr>

   <tr>
<a name="target_498"></a>
    <td><code>+MB</code></td>

    <td>Turn bounding on; Set threshold to 25 or previous amount</td>
   </tr>

   <tr>
<a name="target_499"></a>
    <td><code>-MB</code></td>

    <td>Turn bounding off</td>
   </tr>

   <tr>
<a name="target_500"></a>

    <td><code>Bounding_Threshold=</code>n</td>

    <td>Set bound threshold to n</td>
   </tr>

   <tr>
    <td><code>+MB</code>n</td>

    <td>Turn bounding on; bound threshold to n</td>
   </tr>

   <tr>
    <td><code>-MB</code>n</td>

    <td>Turn bounding off; set future threshold to n</td>
   </tr>

   <tr>
<a name="target_501"></a>

    <td><code>Light_Buffer=</code>bool</td>

    <td>Turn light buffer on/off</td>
   </tr>

   <tr>
<a name="target_502"></a>
    <td><code>+UL</code></td>

    <td>Turn light buffer on</td>
   </tr>

   <tr>
<a name="target_503"></a>
    <td><code>-UL</code></td>

    <td>Turn light buffer off</td>
   </tr>

   <tr>
<a name="target_504"></a>

    <td><code>Vista_Buffer=</code>bool</td>

    <td>Turn vista buffer on/off</td>
   </tr>

   <tr>
<a name="target_505"></a>
    <td><code>+UV</code></td>

    <td>Turn vista buffer on</td>
   </tr>

   <tr>
<a name="target_506"></a>
    <td><code>-UV</code></td>

    <td>Turn vista buffer off</td>
   </tr>
  </table>

  <p>POV-Ray uses a variety of spatial sub-division systems to speed up
  ray-object intersection tests. The primary system uses a hierarchy of nested
  bounding boxes. This system compartmentalizes all finite objects in a scene
  into invisible rectangular boxes that are arranged in a tree-like hierarchy.
  Before testing the objects within the bounding boxes the tree is descended
  and only those objects are tested whose bounds are hit by a ray. This can
  greatly improve rendering speed. However for scenes with only a few objects
  the overhead of using a bounding system is not worth the effort. The <code>
  Bounding=off</code> option or <code>-MB</code> switch allows you to force
  bounding off. The default value is on.</p><p>
   The <code> Bounding_Threshold=</code><em>n</em> or <code>
  +MB</code><em>n</em> switch allows you to set the minimum number of objects
  necessary before bounding is used. The default is <code>+MB25</code> which
  means that if your scene has fewer than 25 objects POV-Ray will automatically
  turn bounding off because the overhead isn't worth it. Generally it's
  a good idea to use a much lower threshold like <code>+MB5</code>.</p><p>
   Additionally POV-Ray uses systems known as <em>vista buffers</em> and <em>
  light buffers</em> to further speed things up. These systems only work when
  bounding is on and when there are a sufficient number of objects to meet the
  bounding threshold. The vista buffer is created by projecting the bounding
  box hierarchy onto the screen and determining the rectangular areas that are
  covered by each of the elements in the hierarchy. Only those objects whose
  rectangles enclose a given pixel are tested by the primary viewing ray. The
  vista buffer can only be used with perspective and orthographic cameras
  because they rely on a fixed viewpoint and a reasonable projection (i. e.
  straight lines have to stay straight lines after the projection).</p><p>
   The light buffer is created by enclosing each light source in an imaginary
  box and projecting the bounding box hierarchy onto each of its six sides.
  Since this relies on a fixed light source, light buffers will not be used for
  area lights.</p><p>
   Reflected and transmitted rays do not take advantage of the light and vista
  buffer.</p><p>
   The default settings are <code> Vista_Buffer=on</code> or <code>+UV</code>
  and <code> Light_Buffer=on</code> or <code>+UL</code>. The option to turn
  these features off is available to demonstrate their usefulness and as
  protection against unforeseen bugs which might exist in any of these bounding
  systems.</p><p>
   In general, any finite object and many types of CSG of finite objects will
  properly respond to this bounding system. In addition blobs and meshes use an
  additional internal bounding system. These systems are not affected by the
  above switch. They can be switched off using the appropriate syntax in the
  scene file (see &quot;<a href="povdoc_187.html#target_752">Blob</a>&quot; and &quot;<a href="povdoc_188.html#target_837">Mesh</a>&quot; for details).</p><p>
   Text objects are split into individual letters that are bounded using the
  bounding box hierarchy. Some CSG combinations of finite and infinite objects
  are also automatically bound. The end result is that you will rarely need to
  add manual bounding objects as was necessary in earlier versions of POV-Ray
  unless you use many infinite objects.</p>

</div>

<div class="divh4">
<a name="target_507"></a>
<h4>5.2.6.3&nbsp;&nbsp;Removing User Bounding</h4>

  <table SUMMARY="">
   <tr>
<a name="target_508"></a>

    <td><code>Remove_Bounds=</code>bool</td>

    <td>Turn unnecessary bounds removal on/off</td>
   </tr>

   <tr>
<a name="target_509"></a>
    <td><code>+UR</code></td>

    <td>Turn unnecessary bounds removal on</td>
   </tr>

   <tr>
<a name="target_510"></a>
    <td><code>-UR</code></td>

    <td>Turn unnecessary bounds removal off</td>
   </tr>

   <tr>
<a name="target_511"></a>

    <td><code>Split_Unions=</code>bool</td>

    <td>Turn split bounded unions on/off</td>
   </tr>

   <tr>
<a name="target_512"></a>
    <td><code>+SU</code></td>

    <td>Turn split bounded unions on</td>
   </tr>

   <tr>
<a name="target_513"></a>
    <td><code>-SU</code></td>

    <td>Turn split bounded unions off</td>
   </tr>
  </table>

  <p>Early versions of POV-Ray had no system of automatic bounding or spatial
  sub-division to speed up ray-object intersection tests. Users had to manually
  create bounding boxes to speed up the rendering. Since version 3.0, POV-Ray
  has had more sophisticated automatic bounding than any previous version. In
  many cases the manual bounding on older scenes is slower than the new
  automatic systems. Therefore POV-Ray removes manual bounding when it knows it
  will help. In rare instances you may want to keep manual bounding. Some older
  scenes incorrectly used bounding when they should have used clipping. If
  POV-Ray removes the bounds in these scenes the image will not look right. To
  turn off the automatic removal of manual bounds you should specify <code>
  Remove_Bounds=off</code> or use <code> -UR</code>. The default is <code>
  Remove_Bounds=on</code>.</p><p>
   One area where the jury is still out is the splitting of manually bounded
  unions. Unbounded unions are always split into their component parts so that
  automatic bounding works better. Most users do not bound unions because they
  know that doing so is usually slower. If you do manually bound a union we
  presume you really want it bound. For safety sake we do not presume to remove
  such bounds. If you want to remove manual bounds from unions you should
  specify <code>Split_Unions=on</code> or use <code> +SU</code>. The default is
  <code>Split_Unions=off</code>.</p>

</div>

<div class="divh4">
<a name="target_514"></a>
<h4>5.2.6.4&nbsp;&nbsp;Anti-Aliasing Options</h4>

  <table SUMMARY="">
   <tr>
<a name="target_515"></a>

    <td><code>Antialias=</code>bool</td>

    <td>Turns anti-aliasing on/off</td>
   </tr>

   <tr>
<a name="target_516"></a>
    <td><code>+A</code></td>

    <td>Turns aa on with threshold 0.3 or previous amount</td>
   </tr>

   <tr>
<a name="target_517"></a>
    <td><code>-A</code></td>

    <td>Turns anti-aliasing off</td>
   </tr>

   <tr>
<a name="target_518"></a>

    <td><code>Sampling_Method=</code>n</td>

    <td>Sets aa-sampling method (only <code>1</code> or <code>2</code> are
    valid)</td>
   </tr>

   <tr>
<a name="target_519"></a>
    <td><code>+AM</code>n</td>

    <td>Same as <code>Sampling_Method=</code>n</td>
   </tr>

   <tr>
<a name="target_520"></a>

    <td><code>Antialias_Threshold=</code>n.n</td>

    <td>Sets anti-aliasing threshold</td>
   </tr>

   <tr>
    <td><code>+A</code>n.n</td>

    <td>Sets aa on with aa-threshold at n.n</td>
   </tr>

   <tr>
    <td><code>-A</code>n.n</td>

    <td>Sets aa off (aa-threshold n.n in future)</td>
   </tr>

   <tr>
<a name="target_521"></a>
    <td><code>Jitter=</code>bool</td>

    <td>Sets aa-jitter on/off</td>
   </tr>

   <tr>
<a name="target_522"></a>
    <td><code>+J</code></td>

    <td>Sets aa-jitter on with 1.0 or previous amount</td>
   </tr>

   <tr>
<a name="target_523"></a>
    <td><code>-J</code></td>

    <td>Sets aa-jitter off</td>
   </tr>

   <tr>
<a name="target_524"></a>

    <td><code>Jitter_Amount=</code>n.n</td>

    <td>Sets aa-jitter amount to n.n. If n.n &lt;= 0 aa-jitter is set off</td>
   </tr>

   <tr>
    <td><code>+J</code>n.n</td>

    <td>Sets aa-jitter on; jitter amount to n.n. If n.n &lt;= 0 aa-jitter is
    set off</td>
   </tr>

   <tr>
    <td><code>-J</code>n.n</td>

    <td>Sets aa-jitter off (jitter amount n.n in future)</td>
   </tr>

   <tr>
<a name="target_525"></a>

    <td><code>Antialias_Depth=</code>n</td>

    <td>Sets aa-depth (1 &lt;= n &lt;= 9)</td>
   </tr>

   <tr>
<a name="target_526"></a>
    <td><code>+R</code>n</td>

    <td>Same as <code>Antialias_Depth=</code>n</td>
   </tr>
  </table>

  <p>The ray-tracing process is in effect a discrete, digital sampling of the
  image with typically one sample per pixel. Such sampling can introduce a
  variety of errors. This includes a jagged, stair-step appearance in sloping
  or curved lines, a broken look for thin lines, moir&eacute; patterns of
  interference and lost detail or missing objects, which are so small they
  reside between adjacent pixels. The effect that is responsible for those
  errors is called <em>aliasing</em>.</p><p>
   Anti-aliasing is any technique used to help eliminate such errors or to
  reduce the negative impact they have on the image. In general, anti-aliasing
  makes the ray-traced image look <em> smoother</em>. The <code>
  Antialias=on</code> option or <code>+A</code> switch turns on POV-Ray's
  anti-aliasing system.</p><p>
   When anti-aliasing is turned on, POV-Ray attempts to reduce the errors by
  shooting more than one viewing ray into each pixel and averaging the results
  to determine the pixel's apparent color. This technique is called
  super-sampling and can improve the appearance of the final image but it
  drastically increases the time required to render a scene since many more
  calculations have to be done.</p><p>
   POV-Ray gives you the option to use one of two alternate super-sampling
  methods. The <code> Sampling_Method=</code><em>n</em> option or <code>
  +AM</code><em>n</em> switch selects either type <code>1</code> or type <code>
  2</code>. Selecting one of those methods does not turn anti-aliasing on. This
  has to be done by using the <code>+A</code> command line switch or <code>
  Antialias=on</code> option.</p><p>
   Type 1 is an adaptive, non-recursive, super-sampling method. It is <em>
  adaptive</em> because not every pixel is super-sampled. Type 2 is an adaptive
  and recursive super-sampling method. It is <em>recursive</em> because the
  pixel is sub-divided and sub-sub-divided recursively. The <em>adaptive</em>
  nature of type 2 is the variable depth of recursion.</p><p>
   In the default, non-recursive method (<code>+AM1</code>), POV-Ray initially
  traces one ray per pixel. If the color of a pixel differs from its neighbors
  (to the left or above) by at least the set threshold value then the pixel is
  super-sampled by shooting a given, fixed number of additional rays. The
  default threshold is 0.3 but it may be changed using the <code>
  Antialias_Threshold=</code><em>n.n</em> option. When the switches are used,
  the threshold may optionally follow the <code>+A</code>. For example <code>
  +A0.1</code> turns anti-aliasing on and sets the threshold to 0.1.</p><p>
   The threshold comparison is computed as follows. If r1, g1, b1 and r2, g2,
  b2 are the rgb components of two pixels then the difference between pixels is
  computed by</p>
<pre>
  diff = abs(r1-r2) + abs(g1-g2) + abs(b1-b2)
</pre>

  <p>If this difference is greater than the threshold then both pixels are
  super-sampled. The rgb values are in the range from 0.0 to 1.0 thus the most
  two pixels can differ is 3.0. If the anti-aliasing threshold is 0.0 then
  every pixel is super-sampled. If the threshold is 3.0 then no anti-aliasing
  is done. Lower threshold means more anti-aliasing and less speed. Use
  anti-aliasing for your final version of a picture, not the rough draft. The
  lower the contrast, the lower the threshold should be. Higher contrast
  pictures can get away with higher tolerance values. Good values seem to be
  around 0.2 to 0.4.</p><p>
   When using the non-recursive method, the default number of super-samples is
  nine per pixel, located on a 3*3 grid. The <code>
  Antialias_Depth=</code><em>n</em> option or <code> +R</code><em>n</em> switch
  controls the number of rows and columns of samples taken for a super-sampled
  pixel. For example <code>+R4</code> would give 4*4=16 samples per pixel.</p><p>
   The second, adaptive, recursive super-sampling method starts by tracing four
  rays at the corners of each pixel. If the resulting colors differ more than
  the threshold amount additional samples will be taken. This is done
  recursively, i.e. the pixel is divided into four sub-pixels that are
  separately traced and tested for further subdivision. The advantage of this
  method is the reduced number of rays that have to be traced. Samples that are
  common among adjacent pixels and sub-pixels are stored and reused to avoid
  re-tracing of rays. The recursive character of this method makes the
  super-sampling concentrate on those parts of the pixel that are more likely
  to need super-sampling (see figure below).</p>

  
<center><img src="images/recsuper.gif" alt="Example of how the recursive super-sampling works"><br><font size=-1><cite>Example of how the recursive super-sampling works</cite></font></center>


  <p>The maximum number of subdivisions is specified by the <code>
  Antialias_Depth=</code><em>n</em> option or <code>+R</code><em>n</em> switch.
  This is different from the adaptive, non-recursive method where the total
  number of super-samples is specified. A maximum number of <em>n</em>
  subdivisions results in a maximum number of samples per pixel that is given
  by the following table.</p>

  <table SUMMARY="">
   <tr>
    <td><code>+R</code>n</td>

    <td>Number of additional samples per super-sampled pixel for the non-recursive method
    <code>+AM1</code></td>

    <td>Maximum number of samples per super-sampled pixel for the recursive
    method <code>+AM2</code></td>
   </tr>

   <tr>
    <td><code>1</code></td>

    <td>1</td>

    <td>9</td>
   </tr>

   <tr>
    <td><code>2</code></td>

    <td>4</td>

    <td>25</td>
   </tr>

   <tr>
    <td><code>3</code></td>

    <td>9</td>

    <td>81</td>
   </tr>

   <tr>
    <td><code>4</code></td>

    <td>16</td>

    <td>289</td>
   </tr>

   <tr>
    <td><code>5</code></td>

    <td>25</td>

    <td>1089</td>
   </tr>

   <tr>
    <td><code>6</code></td>

    <td>36</td>

    <td>4225</td>
   </tr>

   <tr>
    <td><code>7</code></td>

    <td>49</td>

    <td>16641</td>
   </tr>

   <tr>
    <td><code>8</code></td>

    <td>64</td>

    <td>66049</td>
   </tr>

   <tr>
    <td><code>9</code></td>

    <td>81</td>

    <td>263169</td>
   </tr>
  </table>

  <p class="Note"><strong>Note:</strong> the maximum number of samples in the recursive case
  is hardly ever reached for a given pixel. If the recursive method is used
  with no anti-aliasing each pixel will be the average of the rays traced at
  its corners. In most cases a recursion level of three is sufficient.</p><p>
   Another way to reduce aliasing artefacts is to introduce noise into the
  sampling process. This is called <em>jittering</em> and works because the
  human visual system is much more forgiving to noise than it is to regular
  patterns. The location of the super-samples is jittered or wiggled a tiny
  amount when anti-aliasing is used. Jittering is used by default but it may be
  turned off with the <code>Jitter=off</code> option or <code>-J</code> switch.
  The amount of jittering can be set with the <code>
  Jitter_Amount=</code><em>n.n</em> option. When using switches the jitter
  scale may be specified after the <code>+J</code><em>n.n</em> switch. For
  example <code>+J0.5</code> uses half the normal jitter. The default amount of
  1.0 is the maximum jitter which will insure that all super-samples remain
  inside the original pixel. </p>
  <p class="Note"><strong>Note:</strong> the jittering noise is random and
  non-repeatable so you should avoid using jitter in animation sequences as the
  anti-aliased pixels will vary and flicker annoyingly from frame to frame.</p><p>
   If anti-aliasing is not used one sample per pixel is taken regardless of the
  super-sampling method specified.</p>
</div>
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_152.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_154.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
