<!------------------------------------------------------------------------------->
<!--              Generated by makedocs.pl version 1.0 rev 20                  -->
<!--              This file Copyright (c) POV-Team 1991-2002                   -->
<!-- You can override our stylesheet settings by placing a 'povray35.css' file -->
<!--    in the root directory of the disk volume that holds this help file.    -->
<!------------------------------------------------------------------------------->
<html>
<head>
<title>Tips and tricks to achieve useful things</title>
<link rel="stylesheet" type="text/css" href="../povray35.css">
<link rel="stylesheet" type="text/css" href="file:///povray35.css">
<object id=htmlhelp type="application/x-oleobject" classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"></object>
<script language=javascript src="../povray35.js"></script>
</head>
<a name="target_1630"></a>
<body>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_332.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_334.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
<div class="divh3">
<h3>9.1.1&nbsp;&nbsp;Tips and tricks to achieve useful things</h3>

<!-- ================================================================== -->

<a name="visiblelightsource" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1631"></a>
<h4>9.1.1.1&nbsp;&nbsp;How do I make a visible light source?</h4>

<p><i>&quot;How do I make a visible light source?&quot;</i> or: <i>&quot;Although I put the
camera just in front of my light source, I can't see anything. What am I
doing wrong?&quot;</i>

</p><p>A light source in POV-Ray is only a concept. When you
add a light source to the scene, you are actually saying to POV-Ray
&quot;hey, there is light coming from this point&quot;. As the name says, it's a
light <u>source</u>, not a physical light (like a light bulb or a
bright spot like a star). POV-Ray doesn't add anything to that place
where the light is coming, ie. there is nothing there, only empty
space. It's just a kind of mathematical point POV-Ray uses to make
shading calculations.

</p><p>To make the light source visible, you have
to put something there. There is a <code>looks_like</code> keyword in the
<code>light_source</code> block which allows to easily attach an object to the
light source. This object implicitly doesn't cast any shadows.  You
can make something like this:

<pre>
light_source
{ &lt;0,0,0&gt; color 1
  looks_like
  { sphere
    { &lt;0,0,0&gt;,0.1
      color { rgb 1 }
      finish { ambient 1 }
    }
  }
  translate &lt;10,20,30&gt;
}
</pre>

</p><p>It's a good idea to define both things, the light source and the looks_like
object, at the origin, and then translate them to their right place.

</p><p>Note also the '<code>finish { ambient 1 }</code>' which makes the sphere
to apparently glow (see also the next question).

</p><p>You can also get visible light sources using other techniques: Media,
lens flare (available as 3rd party include file), glow patch, etc.</p>

<!-- ================================================================== -->

<a name="brightobjects" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1632"></a>
<h4>9.1.1.2&nbsp;&nbsp;How do I make bright objects?</h4>

<p><i>&quot;How do I make bright objects, which look like they are emitting light?&quot;
</i>

</p><p>There is a simple trick to achieve this: Set the ambient value of the object
to 1 or higher. This makes POV-Ray to add a very bright illumination value to
the object so the color of the object is in practice taken as is, without
darkening it due to shadows and shading. This results in an object which seems
to glow light by itself even if it's in full darkness (useful to make visible
light sources, or small lights like leds which do not cast any considerable
light to their surroundings but can be easily seen even in the darkness).

</p><p>A more sophisticated method would be using an emitting media
inside the object (and making the object itself transparent or
semi-transparent).</p>

<!-- ================================================================== -->


<a name="camerarotation" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1633"></a>
<h4>9.1.1.3&nbsp;&nbsp;How do I move the camera in a circular path?</h4>

<p><i>&quot;How do I move the camera in a circular path while looking at the origin?&quot;
</i>

</p><p>There are two ways to make this: The easy (and limited) way, and the more
mathematical way.

</p><p>The easy way:

<pre>
camera
{ location &lt;0,0,-10&gt;
  look_at 0
  rotate &lt;0,clock*360,0&gt;
}
</pre>

</p><p>This puts the camera at 10 units in the negative Z-axis and then rotates it
around the Y-axis while looking at the origin (it makes a circle of radius
10).

</p><p>The mathematical way:

<pre>
camera
{ location &lt;10*sin(2*pi*clock),0,-10*cos(2*pi*clock)&gt;
  look_at 0
}
</pre>

</p><p>This makes exactly the same thing as the first code, but this way you
can control more precisely the path of the camera. For example you can
make the path elliptical instead of circular by changing the factors
of the sine and the cosine (for example instead of 10 and 10 you can
use 10 and 5 which makes an ellipse with the major radius 10 and minor
radius 5).

</p><p>An easier way to do the above is to use the vrotate()
function, which handles the sin() and cos() stuff for you, as well as
allowing you to use more complex rotations.

<pre>
camera
{ location vrotate(x*10, y*360*clock)
  look_at 0
}
</pre>

</p><p>To get an ellipse with this method, you can just multiply the
result from vrotate by a vector, scaling the resulting circle.  With
the last two methods you can also control the look_at vector (if you
don't want it looking just at the origin).

</p><p>You could also do more complex transformations combining translate,
scale, rotate, and matrix transforms by replacing the vrotate() call
with a call of the vtransform() function found in <code>functions.inc</code>
(new in POV-Ray 3.5).</p>

<!-- ================================================================== -->


<a name="imagemapping" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1634"></a>
<h4>9.1.1.4&nbsp;&nbsp;How do I use an image to texture my object?</h4>

<p>The answer to this question can be easily found in the POV-Ray
documentation, so I will just quote the syntax:

<pre>
pigment
{ image_map
  { gif &quot;image.gif&quot;
    map_type 1
  }
}
</pre>

</p><p>(Note that in order for the image to be aligned properly, either
the object has to be located at the origin when applying the pigment
or the pigment has to be transformed to align with the object. It is
generally easiest to create the object at the origin, apply the
texture, then move it to wherever you want it.)

</p><p>Substitute the keyword <code>gif</code> with the type of image you are
using (if it isn't a GIF): <code>tga, iff, ppm, pgm, png or sys</code>.

</p><p>A <code>map_type 0</code> gives the default planar mapping.<br>
A <code>map_type 1</code> gives a spherical mapping (maps the image onto a
sphere).<br>
With <code>map_type 2</code> you get a cylindrical mapping (maps the image
onto a cylinder).<br>
Finally <code>map_type 5</code> is a torus or donut shaped mapping (maps the
image onto a torus).

</p><p>See the documentation for more details.</p>


<!-- ================================================================== -->

<a name="splines" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1635"></a>
<h4>9.1.1.5&nbsp;&nbsp;How can I generate a spline?</h4>

<p><i>&quot;How can I generate a spline, for example for a camera path for an animation?&quot;</i>

</p><p>POV-Ray 3.5 has a splines feature that allows you to create splines. This is
covered in the documentation and there are demo files showing examples of
use. There exist also third party include files for spline generation that
have greater flexibility than the internal splines, for example
the spline macros by Chris Colefax (<a href="http://www.geocities.com/ccolefax/spline/index.html" target="new" class="ExternalLink">»http://www.geocities.com/ccolefax/spline/index.html</a>).
</p>

<!-- ================================================================== -->

<a name="motionblur" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1636"></a>
<h4>9.1.1.6&nbsp;&nbsp;How can I simulate motion blur?</h4>

<p>The official POV-Ray 3.5 doesn't support motion
blur calculations, but there are some patched versions which do.




</p><p>You can also use other tools to make this. One way to simulate motion
blur is calculating a small animation and then averaging the images together.
This averaging of several images can be made with third party programs,
such as the Targa Averager program
(<a href="http://iki.fi/warp/PovUtils/average/" target="new" class="ExternalLink">»http://iki.fi/warp/PovUtils/average/</a>).
</p>

<!-- ================================================================== -->

<a name="centertext" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1637"></a>
<h4>9.1.1.7&nbsp;&nbsp;How can I find the size of a text object?</h4>

<p><i>&quot;How can I find the size of a text object / center text / justify text?&quot;
</i>

</p><p>You can use the <code>min_extent()</code> and
<code>max_extent()</code> functions (new in POV-Ray 3.5) to get the
corners of the bounding box of any object. While this is sometimes not
the actual size of the object, for text objects this should be fairly
accurate, enough to do alignment of the text object.</p>

<!-- ================================================================== -->

<a name="extrudedtext" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1638"></a>
<h4>9.1.1.8&nbsp;&nbsp;How do I make extruded text?</h4>

<p>POV-Ray has true type font support built in that allows you to have 3D
text in your scenes (see the documentation about the 'text' object for
more details).

</p><p>There are also some outside utilities that will import true type fonts
and allow user manipulation on the text. One of these programs
is called Elefont.</p>


<!-- ================================================================== -->

<a name="hollowobjects" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1639"></a>
<h4>9.1.1.9&nbsp;&nbsp;How do I make an object hollow?</h4>

<p>This question usually means &quot;how do I make a hollow object, like a
waterglass, a jug, etc&quot;.

</p><p>Before answering that question, let me explain some things about how POV-Ray
handles objects:

</p><p>Although the POV-Ray documentation talks about &quot;solid&quot; and &quot;hollow&quot; objects,
that's not how it actually works. &quot;Solid&quot; and &quot;hollow&quot; are a bit misleading
terms to describe the objects. You can also make an object &quot;hollow&quot; with
that same keyword, but it's not that simple.

</p><p>Firstly: POV-Ray only handles surfaces, not solid 3D-objects.
When you specify a sphere, it's actually just a spherical surface. It's only
a surface and it's not filled by anything. This can easily be seen by
putting the camera inside the sphere or by clipping a hole to one side of
the sphere with the clipped_by keyword (so you can look inside).

</p><p>People often think that POV-Ray objects are solid, really 3D, with solid
material filling the entire object because they make a 'difference' CSG
object and it seems like the object is actually solid. What the 'difference'
CSG actually does is to cut away a part of the object and <u>add a new
surface</u> in the place of the hole, which completely covers the hole, so
you can't see inside the object (this new surface is actually the part of
the second object which is &quot;inside&quot; the first object). Again, if you move
the camera inside the object, you will see that actually it's hollow and
the object is just a surface.

</p><p>So what's all this &quot;solid&quot; and &quot;hollow&quot; stuff the documentation talks of,
and what's the &quot;hollow&quot; keyword used for?

</p><p>Although objects are actually surfaces, POV-Ray handles them as if they
were solid. For example, fog and media do not go inside
solid objects. If you put a glass sphere into the fog, you will see that
there's no fog inside the sphere.

</p><p>If you add the &quot;hollow&quot; keyword to the object, POV-Ray will no longer handle
it as solid, so fog and atmosphere will invade the inside of the object.
This is the reason why POV-Ray issues a warning when you put the camera inside
a non-hollow object (because, as it says, fog and other atmospheric effects
may not work as you expected).

</p><p>If your scene does not use any atmospheric effect (fog or media) there
isn't any difference between a &quot;solid&quot; or &quot;hollow&quot; object.

</p><p>So all the objects in POV-Ray are hollow. But the surface of the objects is
always infinitely thin, and there's only one surface. With real world hollow
objects you have always two surfaces: an outer surface and an inner surface.

</p><p>Usually people refer to these kind of objects when they ask for hollow
objects. This kind of objects are easily achieved with a 'difference' CSG
operation, like this:

<pre>
// A simple water glass made with a difference:
difference
{ cone { &lt;0,0,0&gt;,1,&lt;0,5,0&gt;,1.2 }
  cone { &lt;0,.1,0&gt;,.9,&lt;0,5.1,0&gt;,1.1 }
  texture { Glass }
}
</pre>

</p><p>The first cone limits the outer surface of the glass and the second cone
limits the inner surface.</p>


<!-- ================================================================== -->

<a name="filling" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1640"></a>
<h4>9.1.1.10&nbsp;&nbsp;How can I fill a glass with water or other objects?</h4>

<p>As described in the &quot;hollow objects&quot; question above, hollow objects have
always two surfaces: an outer surface and an inner surface. If we take the
same example, a simple glass would be like:

<pre>
// A simple water glass made with a difference:
#declare MyGlass=
difference
{ cone { &lt;0,0,0&gt;,1,&lt;0,5,0&gt;,1.2 }
  cone { &lt;0,.1,0&gt;,.9,&lt;0,5.1,0&gt;,1.1 }
  texture { Glass }
}
</pre>

</p><p>The first cone limits the outer surface of the glass and the second cone
limits the inner surface.

</p><p>If we want to fill the glass with water, we have to make an object which
coincides with the inner surface of the glass. Note that you have to avoid the
<a href="povdoc_334.html#target_1648">coincident surfaces problem</a>
so you should scale
the &quot;water&quot; object just a little bit smaller than the inner surface of the
glass. So we make something like this:

<pre>
#declare MyGlassWithWater=
union
{ object { MyGlass }
  cone
  { &lt;0,.1,0&gt;,.9,&lt;0,5.1,0&gt;,1.1
    scale .999
    texture { Water }
  }
}
</pre>

</p><p>Now the glass is filled with water. But there's one problem: There's too
much water. The glass should be filled only up to certain level, which should
be definable. Well, this can be easily made with a CSG operation:

<pre>
#declare MyGlassWithWater=
union
{ object { MyGlass }
  intersection
  { cone { &lt;0,.1,0&gt;,.9,&lt;0,5.1,0&gt;,1.1 }
    plane { y,4 }
    scale .999
    texture { Water }
  }
}
</pre>

</p><p>Now the water level is at a height of 4 units.
</p>

<!-- ================================================================== -->

<a name="bending" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1641"></a>
<h4>9.1.1.11&nbsp;&nbsp;How can I bend a object?</h4>

<p>There's no direct support for bending in POV-Ray, but you can achieve acceptable bending with the Object Bender by Chris Colefax
(<a href="http://www.geocities.com/SiliconValley/Lakes/1434/bend.html" target="new" class="ExternalLink">»http://www.geocities.com/SiliconValley/Lakes/1434/bend.html</a>).

</p><p>Some objects can be &quot;bent&quot; by just modelling it with other objects.
For example a bent cylinder can be more easily (and accurately) achieved
using the intersection of a torus and some limiting objects.

</p><p>It might be a bit strange why most renderers support bending but POV-Ray
doesn't. To understand this one has to know how other renderers (the
so-called &quot;scanline-renderers&quot; work):

</p><p>In the so-called &quot;scanline renders&quot; all objects are modelled with triangle
meshes (or by primitives such as NURBS or bezier patches which can be very
easily converted to triangles). The &quot;bending&quot; is, in fact, achieved by
moving the vertices of the triangles.

</p><p>In this context the term &quot;bending&quot; is a bit misleading. Strictly speaking,
bending a triangle mesh would also bend the triangles themselves, not only
move their vertices. No renderer can do this. (It can be, however, simulated
by splitting the triangles into smaller triangles, and so the &quot;bending&quot;
effect is more accurate, although not yet perfect.) What these renderers do
is not a true bending in the strict mathematical sense, but only an
approximation achieved by moving the vertices of the triangles.

</p><p>This difference might sound irrelevant, as the result of this kind of
&quot;fake&quot; bending usually looks as good as a true bending. However, it's not
irrelevant from the point of view of POV-Ray. This is because POV-Ray does
not represent the objects with triangles, but they are true mathematical
surfaces. POV-Ray can't &quot;fake&quot; a bending by moving vertices because there
are no vertices to move. In practice bending (and other non-linear
transformations) would require the calculation of the intersection of the
object surface and a curve (instead of a straight line), which is pretty
hard and many times analytically not possible.

</p><p>Note that isosurface objects can be modified with proper functions in
order to achieve all kinds of transformations (linear and non-linear) and
thus they are not really bound to this limitation. However, achieving the
desired transformation needs some knowledge of mathematics.

</p><p>See also the
<a href="povdoc_335.html#target_1656">variable ior question</a>.

</p>

<!-- ================================================================== -->
<a name="grainyfocalblur" class="ExternalLink">
</div>

<div class="divh4">
<a name="target_1642"></a>
<h4>9.1.1.12&nbsp;&nbsp;Can I get non-grainy focal blur?</h4>

<p><i>&quot;The focal blur is very grainy. Can I get rid of the graininess?&quot;</i>

</p><p>Yes. Set <code>variance</code> to 0 (or to a very small value, like
for example 1/100000) and choose a high enough
<code>blur_samples</code>. The rendering will probably slow down quite a lot,
but the result should be very good.</p>

<!-- ================================================================== -->
</div>

<p>
<center>
<table width=100% border=0>
<tr>
<td>
<table width=100% align="center" border=0 bgcolor="#ffcc99" class="NavBar">
<tr>
<td align="left">&lt;<a href="povdoc_332.html">Prev</a></td>
<script language="JavaScript">
<!--
if (navigator.userAgent.indexOf ("MSIE 3.") >= 1)
  document.write ("<td align=center><small><i>You are running <b>IE3</b>. This will likely cause problems with this help file.</i></small></td>") ;
else if (navigator.userAgent.indexOf ("MSIE 4.") >= 1)
  document.write ("<td align=center><small><i>The Microsoft HTML Help system works best with <b>IE5</b> or later. We recommend you upgrade.</i></small></td>") ;
//-->
</script>
<td align="right"><a href="povdoc_334.html">Next</a>&gt;</td></tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
