<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2009-2011  -->

<html lang="en">
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Reference Section 4</title>
<link rel="StyleSheet" href="povray37.css" type="text/css">
<link rel="shortcut icon" href="favicon.ico">

<!--  NOTE: In order to help users find information about POV-Ray using web      -->
<!--  search engines, we ask that you *not* let them index documentation         -->
<!--  mirrors because effectively, when searching, users will get hundreds of    -->
<!--  results containing the same information! For this reason, these meta tags  -->
<!--  below disable archiving of this page by search engines.                    -->

<meta name="robots" content="noarchive">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="expires" content="0">
</head>
<body>

<div class="Page">

<!-- NavPanel Begin -->
<div class="NavPanel">
<table class="NavTable">
<tr>
  <td class="FixedPanelHeading"><a title="3.4" href="#r3_4">Objects</a></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.1" href="#r3_4_1">Finite Solid Primitives</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.1" href="#r3_4_1_1">Blob</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.2" href="#r3_4_1_2">Box</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.3" href="#r3_4_1_3">Cone</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.4" href="#r3_4_1_4">Cylinder</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.5" href="#r3_4_1_5">Height Field</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.6" href="#r3_4_1_6">Isosurface</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.7" href="#r3_4_1_7">Julia Fractal</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.8" href="#r3_4_1_8">Lathe</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.9" href="#r3_4_1_9">Ovus</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.10" href="#r3_4_1_10">Parametric</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.11" href="#r3_4_1_11">Prism</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.12" href="#r3_4_1_12">Sphere</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.13" href="#r3_4_1_13">Sphere Sweep</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.14" href="#r3_4_1_14">Superquadric Ellipsoid</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.15" href="#r3_4_1_15">Surface of Revolution</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.16" href="#r3_4_1_16">Text</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.17" href="#r3_4_1_17">Torus</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.2" href="#r3_4_2">Finite Patch Primitives</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.1" href="#r3_4_2_1">Bicubic Patch</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.2" href="#r3_4_2_2">Disc</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.3" href="#r3_4_2_3">Mesh</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.3.1" href="#r3_4_2_3_1">Solid Mesh</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.4" href="#r3_4_2_4">Mesh2</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.4.1" href="#r3_4_2_4_1">Smooth and Flat triangles in the same mesh</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.4.2" href="#r3_4_2_4_2">Mesh Triangle Textures</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.5" href="#r3_4_2_5">Polygon</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.6" href="#r3_4_2_6">Triangle and Smooth Triangle</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.3" href="#r3_4_3">Infinite Solid Primitives</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.1" href="#r3_4_3_1">Plane</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.2" href="#r3_4_3_2">Poly, Cubic and Quartic</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.3" href="#r3_4_3_3">Quadric</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.4" href="#r3_4_4">Constructive Solid Geometry</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.4.1" href="#r3_4_4_1">Inside and Outside</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.4.2" href="#r3_4_4_2">Union</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.4.2.1" href="#r3_4_4_2_1">Split_Union</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.4.3" href="#r3_4_4_3">Intersection</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.4.4" href="#r3_4_4_4">Difference</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.4.5" href="#r3_4_4_5">Merge</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.5" href="#r3_4_5">Light Sources</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.1" href="#r3_4_5_1">Point Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.2" href="#r3_4_5_2">Spotlights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.3" href="#r3_4_5_3">Cylindrical Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.4" href="#r3_4_5_4">Parallel Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.5" href="#r3_4_5_5">Area Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.6" href="#r3_4_5_6">Shadowless Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.7" href="#r3_4_5_7">Looks_like</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.8" href="#r3_4_5_8">Projected_Through</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.9" href="#r3_4_5_9">Light Fading</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.10" href="#r3_4_5_10">Atmospheric Media Interaction</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.5.11" href="#r3_4_5_11">Atmospheric Attenuation</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.6" href="#r3_4_6">Light Groups</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.7" href="#r3_4_7">Object Modifiers</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.1" href="#r3_4_7_1">Bounded_By</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.2" href="#r3_4_7_2">Clipped_By</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.3" href="#r3_4_7_3">Double_Illuminate</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.4" href="#r3_4_7_4">Hollow</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.5" href="#r3_4_7_5">Inverse</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.6" href="#r3_4_7_6">Material</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.7" href="#r3_4_7_7">No_Image, No_Reflection</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.8" href="#r3_4_7_8">No Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.9" href="#r3_4_7_9">No_Shadow</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.7.10" href="#r3_4_7_10">Sturm</a></div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
</table>
</div>
<!-- NavPanel End -->

<div class="Content">
<table class="HeaderFooter" width="100%">
<tr>
  <td colspan=5 align="left" class="HeaderFooter">
    POV-Ray for Unix <strong class="HeaderFooter">version 3.7</strong>
  </td>
</tr>
<tr >
  <td colspan=5>
    <hr align="right" width="70%">
  </td>
</tr>
<tr>
  <td width="30%"></td>
  <td class="NavBar"><a href="index.html" title="The Front Door">Home</a></td>
  <td class="NavBar"><a href="u1_0.html" title="Unix Table of Contents">POV-Ray for Unix</a></td>
  <td class="NavBar"><a href="t2_0.html" title="Tutorial Table of Contents">POV-Ray Tutorial</a></td>
  <td class="NavBar"><a href="r3_0.html" title="Reference Table of Contents">POV-Ray Reference</a></td>
</tr>
</table>

<a name="r3_4"></a>
<div class="content-level-h2" contains="Objects" id="r3_4">
<h2>3.4 Objects</h2>
<p>Objects are the building blocks of your scene. There are a lot of
different types of objects supported by POV-Ray. In the sections which
follows, we describe <a href="r3_4.html#r3_4_1">Finite Solid Primitives</a>,
<a href="r3_4.html#r3_4_2">Finite Patch Primitives</a>,
<a href="r3_4.html#r3_4_3">Infinite Solid Primitives</a> and <a href="r3_4.html#r3_4_5">Light Sources</a>. These primitive shapes may be combined into complex shapes using
<a href="r3_4.html#r3_4_4">Constructive Solid Geometry</a> (also known as CSG).</p>
<p>
The basic syntax of an object is a keyword describing its type, some floats,
vectors or other parameters which further define its location and/or shape
and some optional object modifiers such as texture, interior_texture, pigment, normal, finish,
interior, bounding, clipping or transformations. Specifically the syntax
is:</p>
<pre>
OBJECT:
  FINITE_SOLID_OBJECT | FINITE_PATCH_OBJECT | 
  INFINITE_SOLID_OBJECT | CSG_OBJECT | LIGHT_SOURCE |
  object { OBJECT_IDENTIFIER [OBJECT_MODIFIERS...] }
FINITE_SOLID_OBJECT:
  BLOB | BOX | CONE | CYLINDER | HEIGHT_FIELD | ISOSURFACE | JULIA_FRACTAL |
  LATHE | OVUS | PARAMETRIC | PRISM | SPHERE | SPHERESWEEP | SUPERELLIPSOID | SOR |
  TEXT | TORUS
FINITE_PATCH_OBJECT:
  BICUBIC_PATCH | DISC | MESH | MESH2 | POLYGON | TRIANGLE |
  SMOOTH_TRIANGLE
  INFINITE_SOLID_OBJECT:
  PLANE | POLY | CUBIC | QUARTIC | QUADRIC 
CSG_OBJECT:
  UNION | INTERSECTION | DIFFERENCE | MERGE
</pre>

<p>Object identifiers may be declared to make scene files more readable and
to parameterize scenes so that changing a single declaration changes many
values. An identifier is declared as follows.</p>
<pre>
OBJECT_DECLARATION:
  #declare IDENTIFIER = OBJECT |
  #local IDENTIFIER = OBJECT
</pre>

<p>Where <em>IDENTIFIER</em> is the name of the identifier up to 40
characters long and <em>OBJECT</em> is any valid object. To invoke
an object identifier, you wrap it in an <code>object{...}</code> statement.
You use the <code>object</code> statement regardless of what type of object
it originally was. Although early versions of POV-Ray required this <code>
object</code> wrapper all of the time, now it is only used with <em>
OBJECT_IDENTIFIERS</em>.</p>
<p>
Object modifiers are covered in detail later. However here is a brief
overview.</p>
<p>
The texture describes the surface properties of the object. Complete details
are in <a href="r3_5.html#r3_5">textures</a>. Textures are combinations of pigments, normals,
and finishes. In the section <a href="r3_5.html#r3_5_1">pigment</a> you will learn how to
specify the color or pattern of colors inherent in the material. In <a href="r3_5.html#r3_5_2">normal</a>, we describe a method of simulating various patterns of bumps, dents, ripples
or waves by modifying the surface normal vector. The section on <a href="r3_5.html#r3_5_3">finish</a> describes the reflective properties of the surface. The <a href="r3_6.html#r3_6_1">Interior</a> is a feature introduced in POV-Ray 3.1. It contains information
about the interior of the object which was formerly contained in the finish
and halo parts of a texture. Interior items are no longer part of the
texture. Instead, they attach directly to the objects. The halo feature has
been discontinued and replaced with a new feature called <a href="r3_6.html#r3_6_2">Media</a> which replaces both halo and atmosphere.</p>
<p>
Bounding shapes are finite, invisible shapes which wrap around complex, slow
rendering shapes in order to speed up rendering time. Clipping shapes are
used to cut away parts of shapes to expose a hollow interior. Transformations
tell the ray-tracer how to move, size or rotate the shape and/or the texture
in the scene.</p>
</div>
<a name="r3_4_1"></a>
<div class="content-level-h3" contains="Finite Solid Primitives" id="r3_4_1">
<h3>3.4.1 Finite Solid Primitives</h3>
<p>There are fourteen different solid finite primitive shapes: blob, box,
cone, cylinder, height field, Julia fractal, lathe, prism, sphere, spheresweep,
superellipsoid, surface of revolution, text object and torus. These have a
well-defined <em>inside</em> and can be used in CSG (see section
<a href="r3_4.html#r3_4_4">Constructive Solid Geometry</a>). They are finite and respond to
automatic bounding. You may specify an interior for these objects.</p>

</div>
<a name="r3_4_1_1"></a>
<div class="content-level-h4" contains="Blob" id="r3_4_1_1">
<h4>3.4.1.1 Blob</h4>
<p>Blobs are an interesting and flexible object type. Mathematically they are
iso-surfaces of scalar fields, i.e. their surface is defined by the strength
of the field in each point. If this strength is equal to a threshold value
you are on the surface otherwise you are not.</p>
<p>
Picture each blob component as an object floating in space. This object is
<em> filled</em> with a field that has its maximum at the center of the
object and drops off to zero at the object's surface. The field strength
of all those components are added together to form the field of the blob. Now
POV-Ray looks for points where this field has a given value, the threshold
value. All these points form the surface of the blob object. Points with a
greater field value than the threshold value are considered to be inside
while points with a smaller field value are outside.</p>
<p>
There's another, simpler way of looking at blobs. They can be seen as a
union of flexible components that attract or repel each other to form a
blobby organic looking shape. The components' surfaces actually stretch
out smoothly and connect as if they were made of honey or something similar.
</p>
<p>
The syntax for <code>blob</code> is defined as follows:</p>
<pre>
BLOB:
  blob { BLOB_ITEM... [BLOB_MODIFIERS...]}
BLOB_ITEM:
  sphere{&lt;Center&gt;, Radius,
    [ strength ] Strength[COMPONENT_MODIFIER...] } |
  cylinder{&lt;End1&gt;, &lt;End2&gt;, Radius,
    [ strength ] Strength [COMPONENT_MODIFIER...] } |
  component Strength, Radius, &lt;Center&gt; |
  threshold Amount
COMPONENT_MODIFIER:
  TEXTURE | PIGMENT | NORMAL | FINISH | TRANSFORMATION
BLOB_MODIFIER:
  hierarchy [Boolean] | sturm [Boolean] | OBJECT_MODIFIER
</pre>

<p>Blob default values:</p>
<pre>
hierarchy : on
sturm     : off
threshold : 1.0
</pre>

<p>The <code>threshold</code> keyword is followed by a float value which
determines the total field strength value that POV-Ray is looking for. The
default value if none is specified is <code>threshold 1.0</code>. By
following the ray out into space and looking at how each blob component
affects the ray, POV-Ray will find the points in space where the field
strength is equal to the threshold value. The following list shows some
things you should know about the threshold value.</p>

<ol>
<li>The threshold value must be positive.</li>
<li>A component disappears if the threshold value is greater than its strength.</li>
<li>As the threshold value gets larger, the surface you see gets closer to the centers of the components.</li>
<li>As the threshold value gets smaller, the surface you see gets closer to the surface of the components.</li>
</ol>

<p>Cylindrical components are specified by a <code>cylinder</code> statement.
The center of the end-caps of the cylinder is defined by the vectors <em>
<code>&lt;End1&gt;</code></em> and <em><code> &lt;End2&gt;</code></em>. Next
is the float value of the <em>Radius</em> followed by the float <em>
Strength</em>. These vectors and floats are required and should be separated
by commas. The keyword <code> strength</code> may optionally precede the
strength value. The cylinder has hemispherical caps at each end.</p>

<p>Spherical components are specified by a <code>sphere</code> statement. The
location is defined by the vector <em> <code>&lt;Center&gt;</code></em>. Next
is the float value of the <em> Radius</em> followed by the float <em>
Strength</em>. These vector and float values are required and should be
separated by commas. The keyword <code> strength</code> may optionally
precede the strength value.</p>
<p>
You usually will apply a single texture to the entire blob object, and you
typically use transformations to change its size, location, and orientation.
However both the <code>cylinder</code> and <code>sphere</code> statements may
have individual texture, pigment, normal, finish, and transformations applied
to them. You may not apply separate <code>interior</code> statements to the
components but you may specify one for the entire blob. </p>
<p class="Note"><strong>Note:</strong> By unevenly scaling a spherical component you can create ellipsoidal components. The
tutorial section on <a href="t2_3.html#t2_3_3_1">Blob Object</a> illustrates individually textured blob components and many other blob examples.</p>

<p>The <code>component</code> keyword is an obsolete method for specifying a
spherical component and is only used for compatibility with earlier POV-Ray
versions. It may not have textures or transformations individually applied to
it.</p>

<p>The <code>strength</code> parameter of either type of blob component is a
float value specifying the field strength at the center of the object. The
strength may be positive or negative. A positive value will make that
component attract other components while a negative value will make it repel
other components. Components in different, separate blob shapes do not affect
each other.</p>
<p>You should keep the following things in mind.</p>

<ol>
<li>The strength value may be positive or negative. Zero is a bad value,
as the net result is that no field was added -- you might just as well have
not used this component.</li>
<li>If strength is positive, then POV-Ray will add the component's field
to the space around the center of the component. If this adds enough field
strength to be greater than the threshold value you will see a surface.</li>
<li>If the strength value is negative, then POV-Ray will subtract the component's
field from the space around the center of the component. This will only
do something if there happen to be positive components nearby. The surface
around any nearby positive components will be dented
away from the center of the negative component.</li>
</ol>

<p>After all components and the optional <code>threshold</code> value have
been specified you may specify zero or more blob modifiers. A blob modifier
is any regular object modifier or the <code>hierarchy</code> or <code>
sturm</code>keywords.</p>
<p>The components of each blob object are internally bounded by a spherical
bounding hierarchy to speed up blob intersection tests and other operations.
Using the optional keyword <code>hierarchy</code> followed by an optional
boolean float value will turn it off or on. By default it is on.</p>

<p>The calculations for blobs must be very accurate. If this shape renders
improperly you may add the keyword <code>sturm</code> followed by an
optional boolean float value to turn off or on POV-Ray's
slower-yet-more-accurate Sturmian root solver. By default it is off.</p>
<p>An example of a three component blob is:</p>
<pre>
BLOB:
  blob {
    threshold 0.6
      sphere { &lt;.75, 0, 0&gt;, 1, 1 }
      sphere { &lt;-.375, .64952, 0&gt;, 1, 1 }
      sphere { &lt;-.375, -.64952, 0&gt;, 1, 1 }
    scale 2
    }
</pre>

<p>If you have a single blob component then the surface you see will just
look like the object used, i.e. a sphere or a cylinder, with the surface
being somewhere inside the surface specified for the component. The exact
surface location can be determined from the blob equation listed below (you
will probably never need to know this, blobs are more for visual appeal than
for exact modeling).</p>
<p>For the more mathematically minded, here's the formula used internally
by POV-Ray to create blobs. You do not need to understand this to use
blobs. The density of the blob field of a single component is:</p>

<table class="centered" width="405x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="385px" src="images/6/69/RefImgBlobdens.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Blob Density</p>
  </td>
</tr>
</table>

<p>where <em>distance</em> is the distance of a given point from the
spherical blob's center or cylinder blob's axis. This formula has the
nice property that it is exactly equal to the strength parameter at the
center of the component and drops off to exactly 0 at a distance from the
center of the component that is equal to the radius value. The density
formula for more than one blob component is just the sum of the individual
component densities.</p>

</div>
<a name="r3_4_1_2"></a>
<div class="content-level-h4" contains="Box" id="r3_4_1_2">
<h4>3.4.1.2 Box</h4>
<p>A simple box can be defined by listing two corners of the box using the
following syntax for a <code>box</code> statement:</p>
<pre>
BOX:
  box {
    &lt;Corner_1&gt;, &lt;Corner_2&gt;
    [OBJECT_MODIFIERS...]
    }
</pre>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/9/98/RefImgBoxgeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a box.</p>
  </td>
</tr>
</table>

<p>Where <em><code>&lt;Corner_1&gt;</code></em> and <em><code>
&lt;Corner_2&gt;</code></em> are vectors defining the x, y, z coordinates of
the opposite corners of the box.</p>
<p class="Note"><strong>Note:</strong> All boxes are defined with their faces parallel to the coordinate axes. They may later be rotated to any orientation using the <code>rotate</code> keyword.</p>
<p>
Boxes are calculated efficiently and make good bounding shapes (if manually
bounding seems to be necessary).</p>

</div>
<a name="r3_4_1_3"></a>
<div class="content-level-h4" contains="Cone" id="r3_4_1_3">
<h4>3.4.1.3 Cone</h4>
<p>The <code>cone</code> statement creates a finite length cone or a <em>
frustum</em> (a cone with the point cut off). The syntax is:</p>
<pre>
CONE:
  cone {
    &lt;Base_Point&gt;, Base_Radius, &lt;Cap_Point&gt;, Cap_Radius
    [ open ][OBJECT_MODIFIERS...]
    }
</pre>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/9/93/RefImgConegeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a cone.</p>
  </td>
</tr>
</table>

<p>Where <em><code>&lt;Base_Point&gt;</code></em> and <em><code>&lt;
Cap_Point&gt;</code></em> are vectors defining the x, y, z coordinates of the
center of the cone's base and cap and <em><code> Base_Radius</code></em>
and <em><code>Cap_Radius</code></em> are float values for the corresponding
radii.</p>
<p>Normally the ends of a cone are closed by flat discs that are parallel to
each other and perpendicular to the length of the cone. Adding the optional
keyword <code>open</code> after <em><code>Cap_Radius</code></em> will remove
the end caps and results in a tapered hollow tube like a megaphone or
funnel.</p>

</div>
<a name="r3_4_1_4"></a>
<div class="content-level-h4" contains="Cylinder" id="r3_4_1_4">
<h4>3.4.1.4 Cylinder</h4>
<p>The <code>cylinder</code> statement creates a finite length cylinder with
parallel end caps The syntax is:</p>
<pre>
CYLINDER:
  cylinder {
    &lt;Base_Point&gt;, &lt;Cap_Point&gt;, Radius
    [ open ][OBJECT_MODIFIERS...]
    }
</pre>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
      <img class="center" width="640px" src="images/1/18/RefImgCylgeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a cylinder.</p>
  </td>
</tr>
</table>

<p>Where <em><code>&lt;Base_Point&gt;</code></em> and <em><code>
&lt;Cap_Point&gt;</code></em> are vectors defining the x, y, z coordinates of
the cylinder's base and cap and <em><code>Radius</code></em> is a float
value for the radius.</p>
<p>
Normally the ends of a cylinder are closed by flat discs that are parallel
to each other and perpendicular to the length of the cylinder. Adding the
optional keyword <code>open</code> after the radius will remove the end caps
and results in a hollow tube.</p>

</div>
<a name="r3_4_1_5"></a>
<div class="content-level-h4" contains="Height Field" id="r3_4_1_5">
<h4>3.4.1.5 Height Field</h4>
<p>Height fields are fast, efficient objects that are generally used to
create mountains or other raised surfaces out of hundreds of triangles in a
mesh. The <code>height_field</code> statement syntax is:</p>
<pre>
HEIGHT_FIELD:
  height_field {
    [HF_TYPE] &quot;filename&quot; [gamma GAMMA] [premultiplied BOOL] | [HF_FUNCTION]
    [HF_MODIFIER...]
    [OBJECT_MODIFIER...]
    }
HF_TYPE:
  exr | gif | hdr | iff | jpeg | pgm | png | pot | ppm | sys | tga | tiff
HF_FUNCTION:
  function FieldResolution_X, FieldResolution_Y ( UserDefined_Function )
HF_MODIFIER:
  hierarchy [Boolean]  |
  smooth               |
  water_level Level
</pre>

<p>Height_field default values:</p>
<pre>
hierarchy   : on
smooth      : off
water_level : 0.0
</pre>

<p>A height field is essentially a one unit wide by one unit long square with
a mountainous surface on top. The height of the mountain at each point is
taken from the color number or palette index of the pixels in a graphic image
file. The maximum height is one, which corresponds to the maximum possible
color or palette index value in the image file.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/0/0c/RefImgUnhfield.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The size and orientation of an unscaled height field.</p>
  </td>
</tr>
</table>

<p>The mesh of triangles corresponds directly to the pixels in the image
file. Each square formed by four neighboring pixels is divided into two
triangles. An image with a resolution of <em><code>N*M</code></em> pixels has
<em><code>(N-1)*(M-1)</code></em> squares that are divided into <em> <code>
2*(N-1)*(M-1)</code></em> triangles.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/3/3c/RefImgPixhfld.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Relationship of pixels and triangles in a height field.</p>
  </td>
</tr>
</table>

<p>The resolution of the height field is influenced by two factors: the
resolution of the image and the resolution of the color/index values. The
size of the image determines the resolution in the x- and z-direction. A
larger image uses more triangles and looks smoother. The resolution of the
color/index value determines the resolution along the y-axis. A height field
made from an 8-bit image can have 256 different height levels while one made
from a 16-bit image can have up to 65536 different height levels. Thus the
second height field will look much smoother in the y-direction if the height
field is created appropriately.</p>
<p>
The size/resolution of the image does not affect the size of the height
field. The unscaled height field size will always be 1 by 1 by 1. Higher
resolution image files will create smaller triangles, not larger height
fields.</p>

<p>The image file type used to create a height field is specified by one of the keywords <a href="r3_4.html#r3_4_1_5">listed</a> above. Specifying the file type is optional. If it is not defined the same file type will be assumed as the one that is set as the output file type. This is useful when the source for the <code>height_field</code> is also generated with POV-Ray.</p>

<p>The GIF, PNG, PGM, TIFF and possibly SYS format files are the only
ones that can be created using a standard paint program. Though there are
paint programs for creating TGA image files they will not be of much use for
creating the special 16 bit TGA files used by POV-Ray (see below and
<a href="r3_3.html#r3_3_3_4">HF_Gray_16</a> for more details).</p>
<p>
In an image file that uses a color palette, like GIF, the color number is the
palette index at a given pixel. Use a paint program to look at the palette of
a GIF image. The first color is palette index zero, the second is index one,
the third is index two and so on. The last palette entry is index 255.
Portions of the image that use low palette entries will result in lower parts
of the height field. Portions of the image that use higher palette entries
will result in higher parts of the height field.</p>
<p>
Height fields created from GIF files can only have 256 different height
levels because the maximum number of colors in a GIF file is 256.</p>
<p>
The color of the palette entry does not affect the height of the pixel.
Color entry 0 could be red, blue, black or orange but the height of any pixel
that uses color entry 0 will always be 0. Color entry 255 could be indigo,
hot pink, white or sky blue but the height of any pixel that uses color entry
255 will always be 1.</p>
<p>
You can create height field GIF images with a paint program or a fractal program like <em>Fractint</em>.</p>
<p>
A POT file is essentially a GIF file with a 16 bit palette. The maximum
number of colors in a POT file is 65536. This means a POT height field can
have up to 65536 possible height values. This makes it possible to have much
smoother height fields.</p>
<p class="Note"><strong>Note:</strong> The maximum height of the field is still 1
even though more intermediate values are possible.</p>
<p> At the time of this writing the only program that created POT files was a freeware MS-Dos/Windows program called <em>Fractint</em>. POT files generated with this fractal program create fantastic landscapes.</p>
<p>
The TGA and PPM file formats may be used as a storage device for 16 bit
numbers rather than an image file. These formats use the red and green bytes
of each pixel to store the high and low bytes of a height value. These files
are as smooth as POT files but they must be generated with special
custom-made programs. Several programs can create TGA heightfields in the
format POV uses, such as <em>Gforge</em> and <em>Terrain Maker</em>.</p>
<p>
PNG format heightfields are usually stored in the form of a grayscale image
with black corresponding to lower and white to higher parts of the height
field. Because PNG files can store up to 16 bits in grayscale images they
will be as smooth as TGA and PPM images. Since they are grayscale images you
will be able to view them with a regular image viewer. <em>Gforge</em>
can create 16-bit heightfields in PNG format. Color PNG images will be used
in the same way as TGA and PPM images.</p>
<p>
SYS format is a platform specific file format. See your platform specific
documentation for details.</p>
<p>
In addition to all the usual object modifiers, there are three additional
height field modifiers available.</p>

<p>The optional <code>water_level</code> parameter may be added after the file
name. It consists of the keyword <code>water_level</code> followed by a
float value telling the program to ignore parts of the height field below
that value. The default value is zero and legal values are between zero and
one. For example <code>water_level 0.5</code> tells POV-Ray to only render
the top half of the height field. The other half is <em>below the water</em>
and could not be seen anyway. Using <code>water_level</code> renders
faster than cutting off the lower part using CSG or clipping. This term comes
from the popular use of height fields to render landscapes. A height field
would be used to create islands and another shape would be used to simulate
water around the islands. A large portion of the height field would be
obscured by the water so the <code>water_level</code> parameter was
introduced to allow the ray-tracer to ignore the unseen parts of the height
field. <code>water_level</code> is also used to cut away unwanted lower
values in a height field. For example if you have an image of a fractal on a
solid colored background, where the background color is palette entry 0, you
can remove the background in the height field by specifying, <code>
water_level 0.001</code>.</p>

<p>Normally height fields have a rough, jagged look because they are made of
lots of flat triangles. Adding the keyword <code>smooth</code> causes
POV-Ray to modify the surface normal vectors of the triangles in such a way
that the lighting and shading of the triangles will give a smooth look. This
may allow you to use a lower resolution file for your height field than would
otherwise be needed. However, smooth triangles will take longer to render.
The default value is off.</p>

<p>In order to speed up the intersection tests a one-level bounding hierarchy
is available. By default it is always used but it can be switched off using
<code>hierarchy off</code> to improve the rendering speed for small height
fields (i.e. low resolution images). You may optionally use a boolean value
such as <code>hierarchy on</code> or <code>hierarchy off</code>.</p>
<p>While POV-Ray will normally interpret the height field input file as a container of linear data irregardless of file type, this can be overridden for any individual height field input file by specifying <code>gamma</code> GAMMA immediately after the file name. For example:</p>
<pre>
height field {
  jpeg "foobar.jpg" gamma 1.8
  }
</pre>
<p>This will cause POV-Ray to perform gamma adjustment or -decoding on the input file data before building the height field. Alternatively to a numerical value, <code>srgb</code> may be specified to denote that the file format is pre-corrected or encoded using the ''sRGB transfer function'' instead of a power-law gamma function. See the section <a href="t2_3.html#t2_3_4">Gamma Handling</a> for more information.</p>
<p>The height field object also allows for substituting a <a href="r3_5.html#r3_5_11_17">user defined function</a> instead of specifying an image. That function can either be in it's literal form, or it can be a call to a function that you have predeclared. The user supplied parameters <code>FieldResolution_X</code> and <code>FieldResolution_Y</code> are integer values that affect the resolution of the color/index values, <em>not</em> size of the unscaled height field.</p>

</div>
<a name="r3_4_1_6"></a>
<div class="content-level-h4" contains="Isosurface" id="r3_4_1_6">
<h4>3.4.1.6 Isosurface</h4>
<p>Details about many of the things that can be done with the isosurface object are 
discussed in the isosurface tutorial section. Below you will only find the syntax basics:</p>

<pre>
isosurface {
  function { FUNCTION_ITEMS }
  [contained_by { SPHERE | BOX }]
  [threshold FLOAT_VALUE]
  [accuracy FLOAT_VALUE]
  [max_gradient FLOAT_VALUE]
  [evaluate P0, P1, P2]
  [open]
  [max_trace INTEGER] | [all_intersections]
  [OBJECT_MODIFIERS...]
  }
</pre>

<p>Isosurface default values:</p>
<pre>
contained_by : box{-1,1}
threshold    : 0.0
accuracy     : 0.001
max_gradient : 1.1
</pre>

<p><code>function { ... }</code> This must be specified and be the first item of the
<code>isosurface</code> statement. Here you place all the mathematical functions that
will describe the surface.</p>

<p><code>contained_by { ... }</code> The <code>contained_by</code> <em>object</em> limits the
area where POV-Ray samples for the surface of the function. This container can either be a
sphere or a box, both of which use the standard POV-Ray syntax. If not specified a
<code>box {&lt;-1,-1,-1&gt;, &lt;1,1,1&gt;}</code> will be used as default.</p>
<pre>
contained_by { sphere { CENTER, RADIUS } }
contained_by { box { CORNER1, CORNER2 } }
</pre>

<p><code>threshold</code> This specifies how much strength, or substance to give the
<code>isosurface</code>. The surface appears where the <code>function</code> value
equals the <code>threshold</code> value. The default threshold is 0.</p>
<pre>function = threshold</pre>

<p><code>accuracy</code> The isosurface finding method is a recursive subdivision method.
This subdivision goes on until the length of the interval where POV-Ray finds a surface
point is less than the specified <code>accuracy</code>. The default value is 0.001.
<br>Smaller values produces more accurate surfaces, but it takes longer to render.</p>

<p><code>max_gradient</code> POV-Ray can find the first intersecting point between a ray and
the <code>isosurface</code> of any continuous function if the maximum gradient of the function
is known.  Therefore you can specify a <code>max_gradient</code> for the function.
The default value is 1.1.  When the <code>max_gradient</code> used to find the
intersecting point is too high, the render slows down considerably. When it is too
low, artifacts or holes may appear on the isosurface. When it is way too low, the surface
does not show at all.  While rendering the isosurface POV-Ray records the found gradient values
and prints a warning if these values are higher or much lower than the specified
<code>max_gradient</code>:</p>

<pre>
Warning: The maximum gradient found was 5.257, but max_gradient of
the isosurface was set to 5.000. The isosurface may contain holes!
Adjust max_gradient to get a proper rendering of the isosurface.
</pre>

<pre>
Warning: The maximum gradient found was 5.257, but max_gradient of
the isosurface was set to 7.000. Adjust max_gradient to
get a faster rendering of the isosurface.
</pre>

<p>For best performance you should specify a value close to the real maximum gradient.</p>
<p><code>evaluate</code> POV-Ray can also dynamically adapt the used max_gradient.
To activate this technique you have to specify the <code>evaluate</code> keyword
followed by three parameters:</p>
<ul>
<li>&nbsp;&nbsp;P0: the minimum max_gradient in the estimation process,</li>
<li>&nbsp;&nbsp;P1: an over-estimating factor. This means that the max_gradient is 
multiplied by the P1 parameter.</li>
<li>&nbsp;&nbsp;P2: an attenuation parameter (1 or less)</li>
</ul>
<p>In this case POV-Ray starts with the <code>max_gradient</code> value <code>P0</code>
and dynamically changes it during the render using <code>P1</code> and <code>P2</code>.
In the evaluation process, the P1 and P2 parameters are used in
quadratic functions. This means that over-estimation increases more
rapidly with higher values and attenuation more rapidly with lower
values. Also with dynamic <code>max_gradient</code>, there can be artifacts and holes.</p>

<p>If you are unsure what values to use, start a render without <code>evaluate</code> to get
a value for <code>max_gradient</code>. Now you can use it with <code>evaluate</code> like this:</p>
<ul>
<li>P0 : found max_gradient * min_factor<br>
<em>min_factor</em> being a float between 0 and 1 to reduce the
<code>max_gradient</code> to a <em>minimum max_gradient</em>. The ideal value for P0
would be the average of the found max_gradients, but we do not
have access to that information.<br>
A good starting point is 0.6 for the min_factor</li>
<li>P1 : sqrt(found max_gradient/(found max_gradient * min_factor))<br>
<em>min_factor</em> being the same as used in P0
this will give an over-estimation factor of more than 1, based
on your minimum max_gradient and the found max_gradient.</li>
<li>P2 : 1 or less<br>
0.7 is a good starting point.</li>
</ul>
<p>
When there are artifacts / holes in the isosurface, increase the min_factor and / or P2 a bit.
Example: when the first run gives a found max_gradient of 356, start with</p>
<pre>
#declare Min_factor= 0.6;
isosurface {
  ...
  evaluate 356*Min_factor,  sqrt(356/(356*Min_factor)),  0.7
  //evaluate 213.6, 1.29, 0.7
  ...
  }
</pre>

<p>
This method is only an approximation of what happens internally, but it
gives faster rendering speeds with the majority of isosurfaces.</p>

<p><code>open</code> When the isosurface is not fully contained within the contained_by object,
there will be a cross section. Where this happens, you will see the surface of the container.
With the <code>open</code> keyword, these cross section surfaces are removed. The inside of the isosurface
becomes visible.</p>
<p class="Note"><strong>Note:</strong> Using <code>open</code> slows down the render speed, and it is not recommended to use it with CSG operations.</p>

<p><code>max_trace</code> Isosurfaces can be used in CSG shapes since they are solid finite objects
- if not finite by themselves, they are through the cross section with the container.
<br>By default POV-Ray searches only for the first surface which the ray intersects. But when using an
<code>isosurface</code> in CSG operations, the other surfaces must also be found. Therefore, 
the keyword <code>max_trace</code> must be added to the <code>isosurface</code> statement. 
It must be followed by an integer value. To check for all surfaces, use the keyword <code>all_intersections</code> instead.
<br>With <code>all_intersections</code> POV-Ray keeps looking until all surfaces are found.
With a <code>max_trace</code> it only checks until that number is reached.</p>

</div>
<a name="r3_4_1_7"></a>
<div class="content-level-h4" contains="Julia Fractal" id="r3_4_1_7">
<h4>3.4.1.7 Julia Fractal</h4>
<p>A <em>julia fractal</em> object is a 3-D <em>slice</em> of a 4-D object
created by generalizing the process used to create the classic Julia sets.
You can make a wide variety of strange objects using the <code>
julia_fractal</code> statement including some that look like bizarre blobs of
twisted taffy. The <code>julia_fractal</code> syntax is:</p>
<pre>
JULIA_FRACTAL:
  julia_fractal {
    &lt;4D_Julia_Parameter&gt;
    [JF_ITEM...] [OBJECT_MODIFIER...]
    }
JF_ITEM:
  ALGEBRA_TYPE | FUNCTION_TYPE | max_iteration Count |
  precision Amt | slice &lt;4D_Normal&gt;, Distance
ALGEBRA_TYPE:
  quaternion | hypercomplex
FUNCTION_TYPE:
  QUATERNATION: 
    sqr | cube
  HYPERCOMPLEX:
    sqr | cube | exp | reciprocal | sin | asin | sinh |
    asinh | cos | acos | cosh | acosh | tan | atan |tanh |
    atanh | ln | pwr( X_Val, Y_Val )
</pre>

<p>Julia Fractal default values:</p>
<pre>
ALGEBRA_TYPE    : quaternion
FUNCTION_TYPE   : sqr
max_iteration   : 20
precision       : 20
slice, DISTANCE : &lt;0,0,0,1&gt;, 0.0
</pre>

<p>The required 4-D vector <em><code>&lt;4D_Julia_Parameter&gt;</code></em>
is the classic Julia parameter <em><code>p</code></em> in the iterated
formula <em><code>f(h) + p</code></em>. The julia fractal object is
calculated by using an algorithm that determines whether an arbitrary point
<em><code>h(0)</code></em> in 4-D space is inside or outside the object. The
algorithm requires generating the sequence of vectors <em><code>h(0), h(1),
...</code></em> by iterating the formula <em><code>h(n+1) = f(h(n)) + p (n =
0, 1, ..., max_iteration-1)</code></em> where <em><code> p</code></em> is the
fixed 4-D vector parameter of the julia fractal and <em><code>f()</code></em>
is one of the functions <code>sqr</code>, <code> cube</code>, ... specified
by the presence of the corresponding keyword. The point <em><code>
h(0)</code></em> that begins the sequence is considered inside the julia
fractal object if none of the vectors in the sequence escapes a hypersphere
of radius 4 about the origin before the iteration number reaches the integer
<code>max_iteration</code> value. As you increase <code>max_iteration</code>,
some points escape that did not previously escape, forming the julia fractal.
Depending on the <em><code> &lt;4D_Julia_Parameter&gt;</code></em>, the julia
fractal object is not necessarily connected; it may be scattered fractal
dust. Using a low <code> max_iteration</code> can fuse together the dust to
make a solid object. A high <code>max_iteration</code> is more accurate but
slows rendering. Even though it is not accurate, the solid shapes you get
with a low <code>max_iteration</code> value can be quite interesting. If
none is specified, the default is <code>max_iteration 20</code>.</p>

<p>Since the mathematical object described by this algorithm is four-dimensional
and POV-Ray renders three dimensional objects, there must be a way to reduce
the number of dimensions of the object from four dimensions to three. This is
accomplished by intersecting the 4-D fractal with a 3-D plane defined by the <code>slice</code> modifier and then projecting the
intersection to 3-D space. The keyword is followed by 4-D vector and a float
separated by a comma. The slice plane is the 3-D space that is perpendicular
to <em><code> &lt;4D_Normal&gt;</code></em> and is <em><code>
Distance</code></em> units from the origin. Zero length <em><code>
&lt;4D_Normal&gt;</code></em> vectors or a <em><code>
&lt;4D_Normal&gt;</code></em> vector with a zero fourth component are
illegal. If none is specified, the default is <code> slice
&lt;0,0,0,1&gt;,0</code>.</p>
<p>
You can get a good feel for the four dimensional nature of a julia fractal by
using POV-Ray's animation feature to vary a slice's <em><code>
Distance</code></em> parameter. You can make the julia fractal appear from
nothing, grow, then shrink to nothing as <em><code>
Distance</code></em> changes, much as the cross section of a 3-D object
changes as it passes through a plane.</p>

<p>The <code> precision</code> parameter is a tolerance used in the
determination of whether points are inside or outside the fractal object.
Larger values give more accurate results but slower rendering. Use as low a
value as you can without visibly degrading the fractal object's
appearance but note values less than 1.0 are clipped at 1.0. The default if
none is specified is <code>precision 20</code>.</p>

<p>The presence of the keywords <code> quaternion</code> or <code>
hypercomplex</code> determine which 4-D algebra is used to calculate the
fractal. The default is <code>quaternion</code>. Both are 4-D generalizations
of the complex numbers but neither satisfies all the field properties (all
the properties of real and complex numbers that many of us slept through in
high school). Quaternions have non-commutative multiplication and
hypercomplex numbers can fail to have a multiplicative inverse for some
non-zero elements (it has been proved that you cannot successfully generalize
complex numbers to four dimensions with all the field properties intact, so
something has to break). Both of these algebras were discovered in the 19th
century. Of the two, the quaternions are much better known, but one can argue
that hypercomplex numbers are more useful for our purposes, since complex
valued functions such as sin, cos, etc. can be generalized to work for
hypercomplex numbers in a uniform way.</p>
<p>
For the mathematically curious, the algebraic properties of these two
algebras can be derived from the multiplication properties of the unit basis
vectors 1 = &lt;1,0,0,0&gt;, i=&lt; 0,1,0,0&gt;, j=&lt;0,0,1,0&gt; and k=&lt;
0,0,0,1&gt;. In both algebras 1 x = x 1 = x for any x (1 is the
multiplicative identity). The basis vectors 1 and i behave exactly like the
familiar complex numbers 1 and i in both algebras.</p>

<table SUMMARY="Quaternion basis vector multiplication rules" width="75%">
<tr>
<td width="33%"><code>ij = k</code></td>
<td width="33%"><code>jk = i</code></td>
<td width="33%"><code>ki = j</code></td>
</tr>

<tr>
<td><code>ji = -k</code></td>
<td><code>kj = -i</code></td>
<td><code>ik = -j</code></td>
</tr>

<tr>
<td><code>ii = jj = kk = -1</code></td>
<td><code>ijk = -1</code></td>
<td>&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>

<table SUMMARY="Hypercomplex basis vector multiplication rules" width="75%">
<tr>
<td width="33%"><code>ij = k</code></td>
<td width="33%"><code>jk = -i</code></td>
<td width="33%"><code>ki = -j</code></td>
</tr>

<tr>
<td><code>ji = k</code></td>
<td><code>kj = -i</code></td>
<td><code>ik = -j</code></td>
</tr>

<tr>
<td><code>ii = jj = kk = -1</code></td>
<td><code>ijk = 1</code></td>
<td>&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>

<p>A distance estimation calculation is used with the quaternion calculations
to speed them up. The proof that this distance estimation formula works does
not generalize from two to four dimensions but the formula seems to work well
anyway, the absence of proof notwithstanding!</p>

<p>The presence of one of the function keywords <code>sqr</code>, <code>
cube</code>, etc. determines which function is used for <em><code>
f(h)</code></em> in the iteration formula <em> <code>h(n+1) = f(h(n)) +
p</code></em>. The default is <code>sqr.</code> Most of the function keywords
work only if the <code>hypercomplex</code> keyword is present. Only <code>
sqr</code> and <code>cube</code> work with <code> quaternion</code>. The
functions are all familiar complex functions generalized to four dimensions.
Function Keyword Maps 4-D value h to:</p>

<table SUMMARY="Function Keyword Maps 4-D value of h" width="75%">
<tr>
<td width="30%"><code>sqr</code></td>
<td width="70%">h*h</td>
</tr>

<tr>
<td><code>cube</code></td>
<td>h*h*h</td>
</tr>

<tr>
<td><code>exp</code></td>
<td>e raised to the power h</td>
</tr>

<tr>
<td><code>reciprocal</code></td>
<td>1/h</td>
</tr>

<tr>
<td><code>sin</code></td>
<td>sine of h</td>
</tr>

<tr>
<td><code>asin</code></td>
<td>arcsine of h</td>
</tr>

<tr>
<td><code>sinh</code></td>
<td>hyperbolic sine of h</td>
</tr>

<tr>
<td><code>asinh</code></td>
<td>inverse hyperbolic sine of h</td>
</tr>

<tr>
<td><code>cos</code></td>
<td>cosine of h</td>
</tr>

<tr>
<td><code>acos</code></td>
<td>arccosine of h</td>
</tr>

<tr>
<td><code>cosh</code></td>
<td>hyperbolic cos of h</td>
</tr>

<tr>
<td><code>acosh</code></td>
<td>inverse hyperbolic cosine of h</td>
</tr>

<tr>
<td><code>tan</code></td>
<td>tangent of h</td>
</tr>

<tr>
<td><code>atan</code></td>
<td>arctangent of h</td>
</tr>

<tr>
<td><code>tanh</code></td>
<td>hyperbolic tangent of h</td>
</tr>

<tr>
<td><code>atanh</code></td>
<td>inverse hyperbolic tangent of h</td>
</tr>

<tr>
<td><code>ln</code></td>
<td>natural logarithm of h</td>
</tr>

<tr>
<td><code>pwr(x,y)</code></td>
<td>h raised to the complex power x+iy</td>
</tr>
</table>

<p>A simple example of a julia fractal object is:</p>
<pre>
julia_fractal {
  &lt;-0.083,0.0,-0.83,-0.025&gt;
  quaternion
  sqr
  max_iteration 8
  precision 15
  }
</pre>

<p>The first renderings of julia fractals using quaternions were done by Alan
Norton and later by John Hart in the '80's. This POV-Ray
implementation follows <em>Fractint</em> in pushing beyond what is known
in the literature by using hypercomplex numbers and by generalizing the
iterating formula to use a variety of transcendental functions instead of
just the classic Mandelbrot <em>z2 + c</em> formula. With an extra two
dimensions and eighteen functions to work with, intrepid explorers should be
able to locate some new fractal beasts in hyperspace, so have at it!</p>

</div>
<a name="r3_4_1_8"></a>
<div class="content-level-h4" contains="Lathe" id="r3_4_1_8">
<h4>3.4.1.8 Lathe</h4>
<p>The <code>lathe</code> is an object generated from rotating a
two-dimensional curve about an axis. This curve is defined by a set of points
which are connected by linear, quadratic, cubic or bezier spline curves. The
syntax is:</p>
<pre>
LATHE:
  lathe {
    [SPLINE_TYPE] Number_Of_Points, &lt;Point_1&gt;
    &lt;Point_2&gt;... &lt;Point_n&gt;
    [LATHE_MODIFIER...]
    }
SPLINE_TYPE:
  linear_spline | quadratic_spline | cubic_spline | bezier_spline
LATHE_MODIFIER:
  sturm | OBJECT_MODIFIER
</pre>

<p>Lathe default values:</p>
<pre>
SPLINE_TYPE   : linear_spline
sturm         : off
</pre>

<p>The first item is a keyword specifying the type of spline. The default if
none is specified is <code>linear_spline</code>. The required integer value
<em><code>Number_Of_Points</code></em> specifies how many two-dimensional
points are used to define the curve. The points follow and are specified by
2-D vectors. The curve is not automatically closed, i.e. the first and last
points are not automatically connected. You will have to do this yourself
if you want a closed curve. The curve thus defined is rotated about the
y-axis to form the lathe object, centered at the origin.</p>
<p>
The following examples creates a simple lathe object that looks like a thick
cylinder, i.e. a cylinder with a thick wall:</p>
<pre>
lathe {
  linear_spline
  5,
  &lt;2, 0&gt;, &lt;3, 0&gt;, &lt;3, 5&gt;, &lt;2, 5&gt;, &lt;2, 0&gt;
  pigment {Red}
  }
</pre>

<p>The cylinder has an inner radius of 2 and an outer radius of 3, giving a
wall width of 1. It's height is 5 and it's located at the origin
pointing up, i.e. the rotation axis is the y-axis.</p>
<p class="Note"><strong>Note:</strong> The first and last point are equal to get a closed curve.</p>
<p>
The splines that are used by the lathe and prism objects are a little bit
difficult to understand. The basic concept of splines is to draw a curve
through a given set of points in a determined way. The default <code>
linear_spline</code> is the simplest spline because it's nothing more
than connecting consecutive points with a line. This means the curve
that is drawn between two points only depends on those two points. No
additional information is taken into account. The other splines are different
in that they do take other points into account when connecting two points.
This creates a smooth curve and, in the case of the cubic spline, produces
smoother transitions at each point.</p>

<p>The <code>quadratic_spline</code> keyword creates splines that are made of
quadratic curves. Each of them connects two consecutive points. Since those
two points (call them second and third point) are not sufficient to describe
a quadratic curve, the predecessor of the second point is taken into account
when the curve is drawn. Mathematically, the relationship (their relative locations on
the 2-D plane) between the first and second point determines the slope of the
curve at the second point. The slope of the curve at the third point is out
of control. Thus quadratic splines look much smoother than linear splines but
the transitions at each point are generally not smooth because the slopes on
both sides of the point are different.</p>

<p>The <code>cubic_spline</code> keyword creates splines which overcome the
transition problem of quadratic splines because they also take a fourth
point into account when drawing the curve between the second and third point.
The slope at the fourth point is under control now and allows a smooth
transition at each point. Thus cubic splines produce the most flexible and
smooth curves.</p>

<p>The <code>bezier_spline</code> is an alternate kind of cubic spline. Points
1 and 4 specify the end points of a segment and points 2 and 3 are control
points which specify the slope at the endpoints. Points 2 and 3 do not
actually lie on the spline. They adjust the slope of the spline. If you draw
an imaginary line between point 1 and 2, it represents the slope at point 1.
It is a line tangent to the curve at point 1. The greater the distance
between 1 and 2, the flatter the curve. With a short tangent the spline can
bend more. The same holds true for control point 3 and endpoint 4. If you
want the spline to be smooth between segments, points 3 and 4 on one segment
and points 1 and 2 on the next segment must form a straight line and point 4
of one segment must be the same as point 1 on the next segment.</p>
<p>
You should note that the number of spline segments, i. e. curves between two
points, depends on the spline type used. For linear splines you get n-1
segments connecting the points P[i], i=1,...,n. A quadratic spline gives you
n-2 segments because the last point is only used for determining the slope, as
explained above (thus you will need at least three points to define a
quadratic spline). The same holds for cubic splines where you get n-3
segments with the first and last point used only for slope calculations (thus
needing at least four points). The bezier spline requires 4 points per
segment, creating n/4 segments.</p>
<p>
If you want to get a closed quadratic and cubic spline with smooth
transitions at the end points you have to make sure that in the cubic case
P[n-1] = P[2] (to get a closed curve), P[n] = P[3] and P[n-2] = P[1] (to
smooth the transition). In the quadratic case P[n-1] = P[1] (to close the
curve) and P[n] = P[2].</p>

<p>The <code>sturm</code> keyword can be used to specify that the slower, but
more accurate, Sturmian root solver should be used. Use it, if the shape does not render properly. Since a quadratic polynomial has to be solved for the linear spline lathe, the Sturmian root solver is not needed.</p>

</div>
<a name="r3_4_1_9"></a>
<div class="content-level-h4" contains="Ovus" id="r3_4_1_9">
<h4>3.4.1.9 Ovus</h4>
<p>An <code>ovus</code> is a shape that looks like an egg. The syntax of the <code>ovus</code> object is:</p>
<pre>
OVUS:
  ovus {
    Bottom_radius, Top_radius
    [OBJECT_MODIFIERS...] 
    }
</pre>

<table class="centered" width="700px" cellpadding="0" cellspacing="10">
<tr>
  <td width="290px">
    <p>Where <em><code>Bottom_radius</code></em> is a float value giving the radius of the bottom sphere and <em><code>Top_radius</code></em> is a float specifying the radius of the top sphere. The top sphere and the bottom sphere are connected together with a suitably truncated citrus (lemon), that is automatically computed so as to provide the needed continuity to the shape.</p>
  </td>
  <td><img class="left" width="125px" src="images/1/12/RefImgOvus2D.png"></td>
  <td>
    <ul>
      <li>The center of the top sphere lies on the top of the bottom sphere.</li>
      <li>The bottom sphere of the <code>ovus</code> is centered at the origin.</li>
      <li>The top sphere of the <code>ovus</code> lies on the y-axis.</li>
    </ul>
  </td>
</tr>
<tr>
  <td></td>
    <td><p class="caption">An ovus 2D section</p></td>
  <td></td>
</tr>
</table>

<table class="centered" width="640px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="620px" src="images/7/72/RefImgOvus3D.png"></td>
</tr>
<tr>
  <td><p class="caption">The ovus and it's constituent 3D shapes</p></td>
</tr>
</table>

<p>Whenever the top radius is bigger than twice the bottom radius, the <code>ovus</code> degenerates into a <code>sphere</code> with an offset center. There are a lot of variations in the shape of the <code>ovus</code>.</p>

<p class="Note"><strong>Note:</strong> According to the ratio of the radius, the pointy part is the smallest radius, but is <em>not</em> always on top!</p>

<table class="centered" width="690px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="670px" src="images/4/46/RefImgDemoOvus.jpg"></td>
</tr>
<tr>
  <td><p class="caption">Evolution of ratio from 0 to 1.95 in 0.15 steps.</p></td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> See the following <em>MathWorld</em> references for more information about the math behind how the <code>ovus</code> object is constructed.</p>
<ul>
  <li><a href="http://mathworld.wolfram.com/Torus.html">Torus</a></li>
  <li><a href="http://mathworld.wolfram.com/Lemon.html">Lemon</a></li>
  <li><a href="http://mathworld.wolfram.com/SpindleTorus.html">SpindleTorus</a></li>
</ul>

</div>
<a name="r3_4_1_10"></a>
<div class="content-level-h4" contains="Parametric" id="r3_4_1_10">
<h4>3.4.1.10 Parametric</h4>
<p>Where the isosurface object uses implicit surface functions, F(x,y,z)=0, the parametric object
is a set of equations for a surface expressed in the form of the parameters that locate points on
the surface, x(u,v), y(u,v), z(u,v). Each pair of values for u and v gives a single point <code>&lt;x,y,z&gt;</code>
in 3d space.</p>

<p>The parametric object is not a solid object it is <em>hollow</em>, like a thin shell.</p>

<p>Syntax:</p>
<pre>
parametric {
  function { FUNCTION_ITEMS },
  function { FUNCTION_ITEMS },
  function { FUNCTION_ITEMS }
  
  &lt;u1,v1&gt;, &lt;u2,v2&gt;
  [contained_by { SPHERE | BOX }]
  [max_gradient FLOAT_VALUE]
  [accuracy FLOAT_VALUE]
  [precompute DEPTH, VarList]
  }
</pre>

<p>Parametric default values:</p>

<pre>
accuracy     : 0.001 
</pre>

<p>The first function calculates the <code>x</code> value of the surface, the second <code>y</code> and
the third the <code>z</code> value. Allowed is any function that results in a float.</p>

<p><code>&lt;u1,v1&gt;,&lt;u2,v2&gt;</code> boundaries of the <code>(u,v)</code> space, in which
the surface has to be calculated</p>

<p><code>contained_by { ... }</code> The contained_by 'object' limits the area where POV-Ray 
samples for the surface of the function. This container can either be a sphere or a box, both 
of which use the standard POV-Ray syntax. If not specified a <code>box {&lt;-1,-1,-1&gt;, &lt;1,1,1&gt;}</code>
will be used as default.</p>

<p><code>max_gradient</code>, 
It is not really the maximum gradient. It's the maximum magnitude of
all six partial derivatives over the specified ranges of u and v. 
That is, if you take <code>dx/du</code>, <code>dx/dv</code>, <code>dy/du</code>,
<code>dy/dv</code>, <code>dz/du</code>, and <code>dz/dv</code>
and calculate them over the entire range, the <code>max_gradient</code> is the
maximum of the absolute values of all of those values.
</p>

<p><code>accuracy</code> The default value is 0.001. Smaller values produces more accurate surfaces,
but take longer to render.</p>

<p><code>precompute</code> can speedup rendering of parametric surfaces. It simply divides parametric
surfaces into small ones (2^depth) and precomputes ranges of the variables(x,y,z) which you specify
after depth. The maximum depth is 20. High values of depth can produce arrays that use a lot of memory,
take longer to parse and render faster. If you declare a parametric surface with the precompute keyword
and then use it twice, all arrays are in memory only once.</p> 

<p>Example, a unit sphere:</p>
<pre>
parametric {
  function { sin(u)*cos(v) }
  function { sin(u)*sin(v) }
  function { cos(u) }

  &lt;0,0&gt;, &lt;2*pi,pi&gt;
  contained_by { sphere{0, 1.1} }
  max_gradient ??
  accuracy 0.0001
  precompute 10 x,y,z
  pigment {rgb 1}
  }
</pre>

</div>
<a name="r3_4_1_11"></a>
<div class="content-level-h4" contains="Prism" id="r3_4_1_11">
<h4>3.4.1.11 Prism</h4>
<p>The <code>prism</code> is an object generated by specifying one or more two-dimensional, closed curves in the x-z plane and sweeping them along y axis. These curves are defined by a set of points which are connected by linear, quadratic, cubic or bezier splines. The syntax for the prism is:</p>
<pre>
PRISM:
  prism {
    [PRISM_ITEMS...] Height_1, Height_2, Number_Of_Points,
    &lt;Point_1&gt;, &lt;Point_2&gt;, ... &lt;Point_n&gt;
    [ open ] [PRISM_MODIFIERS...]
    }
PRISM_ITEM:
  linear_spline | quadratic_spline | cubic_spline |
  bezier_spline | linear_sweep | conic_sweep
PRISM_MODIFIER:
  sturm | OBJECT_MODIFIER
</pre>

<p>Prism default values:</p>

<pre>
SPLINE_TYPE   : linear_spline
SWEEP_TYPE    : linear_sweep
sturm         : off
</pre>

<p>The first items specify the spline type and sweep type. The defaults if
none is specified is <code>linear_spline</code> and <code>
linear_sweep</code>. This is followed by two float values <em><code>
Height_1</code></em> and <em> <code>Height_2</code></em> which are the y
coordinates of the top and bottom of the prism. This is followed by a float
value specifying the number of 2-D points you will use to define the prism.
(This includes all control points needed for quadratic, cubic and bezier
splines). This is followed by the specified number of 2-D vectors which
define the shape in the x-z plane.</p>
<p>
The interpretation of the points depends on the spline type. The prism
object allows you to use any number of sub-prisms inside one prism statement
(they are of the same spline and sweep type). Wherever an even number of
sub-prisms overlaps a hole appears.</p>
<p class="Note"><strong>Note:</strong> You need not have multiple sub-prisms and they need not overlap as these examples do.</p>
<p>
In the <code>linear_spline</code> the first point specified is the start of
the first sub-prism. The following points are connected by straight lines. If
you specify a value identical to the first point, this closes the sub-prism
and next point starts a new one. When you specify the value of that
sub-prism's start, then it is closed. Each of the sub-prisms has to be
closed by repeating the first point of a sub-prism at the end of the
sub-prism's point sequence. In this example, there are two rectangular
sub-prisms nested inside each other to create a frame.</p>
<pre>
prism {
  linear_spline
  0, 1, 10,
  &lt;0,0&gt;, &lt;6,0&gt;, &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //outer rim
  &lt;1,1&gt;, &lt;5,1&gt;, &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;   //inner rim
  }
</pre>

<p>The last sub-prism of a linear spline prism is automatically closed - just
like the last sub-polygon in the polygon statement - if the first and last
point of the sub-polygon's point sequence are not the same. This make it
very easy to convert between polygons and prisms. Quadratic, cubic and bezier
splines are never automatically closed.</p>
<p>
In the <code> quadratic_spline</code>, each sub-prism needs an additional
control point at the beginning of each sub-prisms' point sequence to
determine the slope at the start of the curve. The first point specified is
the control point which is not actually part of the spline. The second point
is the start of the spline. The sub-prism ends when this second point is
duplicated. The next point is the control point of the next sub-prism. The
point after that is the first point of the second sub-prism. Here is an
example:</p>
<pre>
prism {
  quadratic_spline
  0, 1, 12,
  &lt;1,-1&gt;, &lt;0,0&gt;, &lt;6,0&gt;, //outer rim; &lt;1,-1&gt; is control point and 
  &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //&lt;0,0&gt; is first &amp; last point
  &lt;2,0&gt;, &lt;1,1&gt;, &lt;5,1&gt;,  //inner rim; &lt;2,0&gt; is control point and 
  &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;   //&lt;1,1&gt; is first &amp; last point
  }
</pre>

<p>In the <code>cubic_spline</code>, each sub-prism needs two additional
control points -- one at the beginning of each sub-prisms' point sequence
to determine the slope at the start of the curve and one at the end. The
first point specified is the control point which is not actually part of the
spline. The second point is the start of the spline. The sub-prism ends when
this second point is duplicated. The next point is the control point of the
end of the first sub-prism. Next is the beginning control point of the next
sub-prism. The point after that is the first point of the second
sub-prism.</p>
<p>
Here is an example:</p>
<pre>
prism {
  cubic_spline
  0, 1, 14,
  &lt;1,-1&gt;, &lt;0,0&gt;, &lt;6,0&gt;, //outer rim; First control is &lt;1,-1&gt; and
  &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //&lt;0,0&gt; is first &amp; last point.
  &lt;-1,1&gt;,                           //Last control of first spline is &lt;-1,1&gt;
  &lt;2,0&gt;, &lt;1,1&gt;, &lt;5,1&gt;,  //inner rim; First control is &lt;2,0&gt; and 
  &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;,  //&lt;1,1&gt; is first &amp; last point
  &lt;0,2&gt;                             //Last control of first spline is &lt;0,2&gt;
  }
</pre>

<p>The <code>bezier_spline</code> is an alternate kind of cubic spline.
Points 1 and 4 specify the end points of a segment and points 2 and 3 are
control points which specify the slope at the endpoints. Points 2 and 3 do
not actually lie on the spline. They adjust the slope of the spline. If you
draw an imaginary line between point 1 and 2, it represents the slope at
point 1. It is a line tangent to the curve at point 1. The greater the
distance between 1 and 2, the flatter the curve. With a short tangent the
spline can bend more. The same holds true for control point 3 and endpoint 4.
If you want the spline to be smooth between segments, point 3 and 4 on one
segment and point 1 and 2 on the next segment must form a straight line and
point 4 of one segment must be the same as point one on the next segment.</p>
<p>
By default linear sweeping is used to create the prism, i.e. the prism's
walls are perpendicular to the x-z-plane (the size of the curve does not
change during the sweep). You can also use <code>conic_sweep</code> that
leads to a prism with cone-like walls by scaling the curve down during the
sweep.</p>
<p>
Like cylinders the prism is normally closed. You can remove the caps on the
prism by using the <code>open</code> keyword. If you do so you should not
use it with CSG because the results may get wrong.</p>

<p>For an explanation of the spline concept read the description of the
<a href="r3_4.html#r3_4_1_8">Lathe</a> object. Also see the tutorials on
<a href="t2_3.html#t2_3_1_1">Lathe</a> and <a href="t2_3.html#t2_3_1_3">Prism</a> objects.</p>

<p>The <code> sturm</code> keyword specifies the slower but more accurate
Sturmian root solver which may be used with the cubic or bezier spline prisms
if the shape does not render properly. The linear and quadratic spline prisms
do not need the Sturmian root solver.</p>

</div>


<a name="r3_4_1_12"></a>
<div class="content-level-h4" contains="Sphere" id="r3_4_1_12">
<h4>3.4.1.12 Sphere</h4>
<p>The syntax of the <code>sphere</code> object is:</p>
<pre>
SPHERE:
  sphere {
    &lt;Center&gt;, Radius
    [OBJECT_MODIFIERS...] 
    }
</pre>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/b/b2/RefImgSphgeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a sphere.</p>
  </td>
</tr>
</table>

<p>Where <em><code>&lt;Center&gt;</code></em> is a vector specifying the x,
y, z coordinates of the center of the sphere and <em><code>
Radius</code></em> is a float value specifying the radius. Spheres may be
scaled unevenly giving an ellipsoid shape.</p>
<p>
Because spheres are highly optimized they make good bounding shapes (if
manual bounding seems to be necessary).</p>

</div>
<a name="r3_4_1_13"></a>
<div class="content-level-h4" contains="Sphere Sweep" id="r3_4_1_13">
<h4>3.4.1.13 Sphere Sweep</h4>
<p>The syntax of the <code>sphere_sweep</code> object is:</p>
<pre>
SPHERE_SWEEP:
  sphere_sweep {
    linear_spline | b_spline | cubic_spline
    NUM_OF_SPHERES,

    CENTER, RADIUS,
    CENTER, RADIUS,
    ...
    CENTER, RADIUS
    [tolerance DEPTH_TOLERANCE]
    [OBJECT_MODIFIERS]
    }
</pre>

<p>Sphere_sweep default values:</p>
<pre>
tolerance : 1.0e-6 (0.000001) 
</pre>

<p>A Sphere Sweep is the envelope of a moving sphere with varying radius, or, in other words, the
space a sphere occupies during its movement along a spline.
<br>Sphere Sweeps are modeled by specifying a list of single spheres which are then interpolated.
<br>Three kinds of interpolation are supported:</p><ul>
<li><code>linear_spline</code> : Interpolating the input data with a linear function, which means
that the single spheres are connected by straight tubes.</li>
<li><code>b_spline</code> : Approximating the input data using a cubic b-spline function, which
results in a curved object.</li>
<li><code>cubic_spline</code> : Approximating the input data using a cubic spline,
which results in a curved object.</li></ul>
<p>The sphere list (center and radius of each sphere) can take as many spheres as you like to describe
the object, but you will need at least two spheres for a <code>linear_spline</code>, and four spheres
for <code>b_spline</code> or <code>cubic_spline</code>.</p>

<p>Optional: The depth tolerance that should be used for the intersection calculations. This is done by
adding the <code>tolerance</code> keyword and the desired value: the default distance is
1.0e-6 (0.000001) and should do for most sphere sweep objects.
<br>You should change this when you see dark spots on the surface of the object. These are probably
caused by an effect called <em>self-shading</em>. This means that the object casts shadows onto itself at some
points because of calculation errors. A ray tracing program usually defines the minimal distance a ray
must travel before it actually hits another (or the same) object to avoid this effect. If this distance is
chosen too small, self-shading may occur.
<br>If so, specify <code>tolerance 1.0e-4</code> or higher.</p>

<p class="Note"><strong>Note:</strong> If these dark spots remain after raising the tolerance, you might get rid of these spots by
using adaptive super-sampling (method 2) for anti-aliasing. Images look better with anti-aliasing anyway.</p>
<p class="Note"><strong>Note:</strong> The merge CSG operation is not recommended with Sphere Sweeps: there could be a small gap
between the merged objects!</p>

</div>
<a name="r3_4_1_14"></a>
<div class="content-level-h4" contains="Superquadric Ellipsoid" id="r3_4_1_14">
<h4>3.4.1.14 Superquadric Ellipsoid</h4> 
<p>The <code>superellipsoid</code> object creates a shape known as a <em>
superquadric ellipsoid</em> object. It is an extension of the quadric
ellipsoid. It can be used to create boxes and cylinders with round edges and
other interesting shapes. Mathematically it is given by the equation:</p>

<table class="centered" width="465x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <!--<img src="ref_tex/sqemath.tex" alt="">---><img class="center" width="445px" src="images/5/5b/RefImgSqemath.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Superquadric Ellipsoid Formula</p>
  </td>
</tr>
</table>

<p>The values of <em><code>e</code></em> and <em><code>n</code></em>, called
the <em>east-west</em> and <em>north-south</em> exponent, determine the shape
of the superquadric ellipsoid. Both have to be greater than zero. The sphere
is given by <em>e = 1</em> and <em>n = 1</em>.</p>
<p>
The syntax of the superquadric ellipsoid is:</p>
<pre>
SUPERELLIPSOID:
  superellipsoid {
    &lt;Value_E, Value_N&gt;
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>The 2-D vector specifies the <em><code>e</code></em> and <em><code>
n</code></em> values in the equation above. The object sits at the origin and
occupies a space about the size of a <code>
box{&lt;-1,-1,-1&gt;,&lt;1,1,1&gt;}</code>.</p>
<p>
Two useful objects are the rounded box and the rounded cylinder. These are
declared in the following way.</p>
<pre>
#declare Rounded_Box = superellipsoid { &lt;Round, Round&gt; }
#declare Rounded_Cylinder = superellipsoid { &lt;1, Round&gt; }
</pre>

<p>The roundedness value <code>Round</code> determines the roundedness of the
edges and has to be greater than zero and smaller than one. The smaller you
choose the values, the smaller and sharper the edges will get.</p>
<p>
Very small values of <em><code>e</code></em> and <em><code>n</code></em>
might cause problems with the root solver (the Sturmian root solver cannot be
used).</p>

</div>
<a name="r3_4_1_15"></a>
<div class="content-level-h4" contains="Surface of Revolution" id="r3_4_1_15">
<h4>3.4.1.15 Surface of Revolution</h4>
<p>The <code>sor</code> object is a <em>surface of revolution</em> generated
by rotating the graph of a function about the y-axis. This function describes
the dependence of the radius from the position on the rotation axis. The
syntax is:</p>
<pre>
SOR:
  sor {
    Number_Of_Points, &lt;Point_1&gt;, &lt;Point_2&gt;, ... &lt;Point_n&gt;
    [ open ] [SOR_MODIFIERS...]
    }
SOR_MODIFIER:
  sturm | OBJECT_MODIFIER
</pre>

<p>SOR default values:</p>
<pre>
sturm : off
</pre>

<p>The float value <em><code>Number_Of_Points</code></em> specifies the
number of 2-D vectors which follow. The points <em><code>
&lt;Point_1&gt;</code></em> through <em><code>&lt;Point_n&gt;</code></em> are
two-dimensional vectors consisting of the radius and the corresponding
height, i.e. the position on the rotation axis. These points are smoothly
connected (the curve is passing through the specified points) and rotated
about the y-axis to form the SOR object. The first and last points are only
used to determine the slopes of the function at the start and end point. They
do not actually lie on the curve. The function used for the SOR object is
similar to the splines used for the lathe object. The difference is that the
SOR object is less flexible because it underlies the restrictions of any
mathematical function, i.e. to any given point y on the rotation axis belongs
at most one function value, i.e. one radius value. You cannot rotate
closed curves with the SOR object. Also, make sure that the curve does not cross zero (y-axis)
as this can result in 'less than perfect' bounding cylinders. POV-Ray will very likely fail to 
render large chunks of the part of the spline contained in such an interval.</p>
<p>
The optional keyword <code>open</code> allows you to remove the caps on the
SOR object. If you do this you should not use it with CSG because
the results may be wrong.</p>
<p>
The SOR object is useful for creating bottles, vases, and things like that.
A simple vase could look like this:</p>
<pre>
#declare Vase = sor {
  7,
  &lt;0.000000, 0.000000&gt;
  &lt;0.118143, 0.000000&gt;
  &lt;0.620253, 0.540084&gt;
  &lt;0.210970, 0.827004&gt;
  &lt;0.194093, 0.962025&gt;
  &lt;0.286920, 1.000000&gt;
  &lt;0.468354, 1.033755&gt;
  open
  }
</pre>

<p>One might ask why there is any need for a SOR object if there is already a
lathe object which is much more flexible. The reason is quite simple. The
intersection test with a SOR object involves solving a cubic polynomial while
the test with a lathe object requires to solve a 6th order polynomial (you
need a cubic spline for the same smoothness). Since most SOR and lathe
objects will have several segments this will make a great difference in
speed. The roots of the 3rd order polynomial will also be more accurate and
easier to find.</p>

<p>The <code>sturm</code> keyword may be added to specify the slower but more
accurate Sturmian root solver. It may be used with the surface of revolution
object if the shape does not render properly.</p>
<p>
The following explanations are for the mathematically interested reader who
wants to know how the surface of revolution is calculated. Though it is not
necessary to read on it might help in understanding the SOR object.</p>
<p>
The function that is rotated about the y-axis to get the final SOR object is
given by</p>

<table class="centered" width="380x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <!--<img src="ref_tex/sormath.tex" alt="">---><img class="center" width="360px" src="images/a/af/RefImgSormath.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Surface of Revolution Formula</p>
  </td>
</tr>
</table>

<p>with radius <em><code>r</code></em> and height <em><code>h</code></em>.
Since this is a cubic function in h it has enough flexibility to allow smooth
curves.</p>
<p>
The curve itself is defined by a set of n points P(i), i=0...n-1, which are
interpolated using one function for every segment of the curve. A segment j,
j=1...n-3, goes from point P(j) to point P(j+1) and uses points P(j-1) and
P(j+2) to determine the slopes at the endpoints. If there are n points we
will have n-3 segments. This means that we need at least four points to get a
proper curve. The coefficients A(j), B(j), C(j) and D(j) are calculated for
every segment using the equation</p>

<table class="centered" width="470x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <!--<img src="ref_tex/curvmath.tex" alt="">---><img class="center" width="450px" src="images/a/af/RefImgCurvmath.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Curve Math</p>
  </td>
</tr>
</table>

<p>where r(j) is the radius and h(j) is the height of point P(j).</p>
<p>
The figure below shows the configuration of the points P(i), the location of
segment j, and the curve that is defined by this segment.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/e/e7/RefImgSegmpts.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Points on a surface of revolution.</p>
  </td>
</tr>
</table>

</div>
<a name="r3_4_1_16"></a>
<div class="content-level-h4" contains="Text" id="r3_4_1_16">
<h4>3.4.1.16 Text</h4>
<p>A <code>text</code> object creates 3-D text as an extruded block letter.
Currently only TrueType fonts (ttf) and TrueType Collections (ttc) are supported
but the syntax allows for other font types to be added in the future. If TrueType Collections
are used, the first font found in the collection will be used. The syntax is:</p>
<pre>
TEXT_OBECT:
  text {
    ttf &quot;fontname.ttf/ttc&quot; &quot;String_of_Text&quot;
    Thickness, &lt;Offset&gt;
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>Where <code>fontname.ttf</code> or <code>fontname.ttc</code> is the name of the TrueType font file. It
is a quoted string literal or string expression. The string expression which
follows is the actual text of the string object. It too may be a quoted
string literal or string expression. See section <a href="r3_2.html#r3_2_1_7">Strings</a> for more
on string expressions.</p>
<p>
The text will start with the origin at the lower left, front of the first
character and will extend in the +x-direction. The baseline of the text
follows the x-axis and descender drop into the -y-direction. The front of the
character sits in the x-y-plane and the text is extruded in the +z-direction.
The front-to-back thickness is specified by the required value <em><code>
Thickness</code></em>.</p>
<p>
Characters are generally sized so that 1 unit of vertical spacing is
correct. The characters are about 0.5 to 0.75 units tall.</p>
<p>
The horizontal spacing is handled by POV-Ray internally including any kerning
information stored in the font. The required vector <em><code>
&lt;Offset&gt;</code></em> defines any extra translation between each
character. Normally you should specify a zero for this value. Specifying
<code>0.1*x</code> would put additional 0.1 units of space between each
character. Here is an example:</p>
<pre>
text {
  ttf &quot;timrom.ttf&quot; &quot;POV-Ray&quot; 1, 0
  pigment { Red }
  }
</pre>

<p>Only printable characters are allowed in text objects. Characters such as
return, line feed, tabs, backspace etc. are not supported.</p>

<p>For easy access to your fonts, set the <a href="r3_1.html#r3_1_2_5_4">Library_Path</a>
to the directory that contains your font collection.</p>

</div>
<a name="r3_4_1_17"></a>
<div class="content-level-h4" contains="Torus" id="r3_4_1_17">
<h4>3.4.1.17 Torus</h4>
<p>A <code>torus</code> is a 4th order quartic polynomial shape that looks
like a donut or inner tube. Because this shape is so useful and quartics are
difficult to define, POV-Ray lets you take a short-cut and define a torus
by:</p>
<pre>
TORUS:
  torus {
    Major, Minor
    [TORUS_MODIFIER...]
    }
TORUS_MODIFIER:
  sturm | OBJECT_MODIFIER
</pre>

<p>Torus default values:</p>
<pre>
sturm : off
</pre>

<p>where <em><code>Major</code></em> is a float value giving the major radius
and <em><code>Minor</code></em> is a float specifying the minor radius. The
major radius extends from the center of the hole to the mid-line of the rim
while the minor radius is the radius of the cross-section of the rim. The
torus is centered at the origin and lies in the x-z-plane with the y-axis
sticking through the hole.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/2/29/RefImgMimxrtor.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Major and minor radius of a torus.</p>
  </td>
</tr>
</table>

<p>The torus is internally bounded by two cylinders and two rings forming a
thick cylinder. With this bounding cylinder the performance of the torus
intersection test is vastly increased. The test for a valid torus
intersection, i.e. solving a 4th order polynomial, is only performed if the
bounding cylinder is hit. Thus a lot of slow root solving calculations are
avoided.</p>

<p>Calculations for all higher order polynomials must be very accurate. If the
torus renders improperly you may add the keyword <code>sturm</code> to use
POV-Ray's slower-yet-more-accurate Sturmian root solver.</p>

</div>
<a name="r3_4_2"></a>
<div class="content-level-h3" contains="Finite Patch Primitives" id="r3_4_2">
<h3>3.4.2 Finite Patch Primitives</h3>
<p>There are six totally thin, finite objects which have no well-defined inside. They are bicubic patch, disc, smooth triangle, triangle, polygon, mesh, and mesh2. They may be combined in CSG union, but cannot be used inside a <code>clipped_by</code> statement.</p>
<p class="Note"><strong>Note:</strong> Patch objects <em>may</em> give unexpected results when used in differences and intersections.</p>
<p>These conditions apply:</p>
<ol>
<li>Solids may be differenced from bicubic patches with the expected results.</li>
<li>Differencing a bicubic patch from a solid <em>may</em> give unexpected results.</li>
<ul>
<li>Especially if the inverse keyword is used!</li>
</ul>
<li>Intersecting a solid and a bicubic patch will give the expected results.</li>
<ul>
<li>The parts of the patch that intersect the solid object will be visible.</li>
</ul>
<li>Merging a solid and a bicubic patch will remove the parts of the bicubic patch that intersect the solid.</li>
</ol>

<p>Because these types are finite POV-Ray can use automatic bounding on them to speed up rendering time. As with all shapes they can be translated, rotated and scaled.</p>

</div>
<a name="r3_4_2_1"></a>
<div class="content-level-h4" contains="Bicubic Patch" id="r3_4_2_1">
<h4>3.4.2.1 Bicubic Patch</h4>
<p>A <code>bicubic_patch</code> is a 3D curved surface created from a mesh of
triangles. POV-Ray supports a type of bicubic patch called a <em>Bezier
patch</em>. A bicubic patch is defined as follows:</p>
<pre>
BICUBIC_PATCH:
  bicubic_patch {
    PATCH_ITEMS...
    &lt;Point_1&gt;,&lt;Point_2&gt;,&lt;Point_3&gt;,&lt;Point_4&gt;,
    &lt;Point_5&gt;,&lt;Point_6&gt;,&lt;Point_7&gt;,&lt;Point_8&gt;,
    &lt;Point_9&gt;,&lt;Point_10&gt;,&lt;Point_11&gt;,&lt;Point_12&gt;,
    &lt;Point_13&gt;,&lt;Point_14&gt;,&lt;Point_15&gt;,&lt;Point_16&gt;
    [OBJECT_MODIFIERS...]
    }
PATCH_ITEMS:
  type Patch_Type | u_steps Num_U_Steps | v_steps Num_V_Steps |
  flatness Flatness
</pre>

<p>Bicubic patch default values:</p>
<pre>
flatness : 0.0
u_steps  : 0
v_steps  : 0
</pre>

<p>The keyword <code>type</code> is followed by a float <em><code>
Patch_Type</code></em> which currently must be either 0 or 1. For type 0 only
the control points are retained within POV-Ray. This means that a minimal
amount of memory is needed but POV-Ray will need to perform many extra
calculations when trying to render the patch. Type 1 preprocesses the patch
into many subpatches. This results in a significant speedup in rendering at
the cost of memory.</p>

<p>The four parameters <code>type</code>, <code>flatness</code>, <code>
u_steps</code> and <code>v_steps</code> may appear in any order. Only
<code>type</code> is required. They are followed by 16 vectors (4 rows
of 4) that define the x, y, z coordinates of the 16 control points which
define the patch. The patch touches the four corner points <em><code>
&lt;Point_1&gt;</code></em>, <em><code>&lt;Point_4&gt;</code></em>, <em>
<code>&lt;Point_13&gt;</code></em> and <em> <code>
&lt;Point_16&gt;</code></em> while the other 12 points pull and stretch the
patch into shape. The Bezier surface is enclosed by the convex hull formed by
the 16 control points, this is known as the <em>convex hull property</em>.</p>

<p>The keywords <code>u_steps</code> and <code>v_steps</code> are each followed
by integer values which tell how many rows and columns of triangles are the
minimum to use to create the surface, both default to 0. The maximum number of individual pieces
of the patch that are tested by POV-Ray can be calculated from the following:
<em>pieces = 2^u_steps * 2^v_steps</em>.</p>

<p>This means that you really should keep <code>u_steps</code> and <code>
v_steps</code> under 4. Most patches look just fine with <code>u_steps
3</code> and <code>v_steps 3</code>, which translates to 64 sub-patches (128
smooth triangles).</p>

<p>As POV-Ray processes the Bezier patch it makes a test of the current piece
of the patch to see if it is flat enough to just pretend it is a rectangle.
The statement that controls this test is specified with the <code>
flatness</code> keyword followed by a float. Typical flatness values range
from 0 to 1 (the lower the slower). The default if none is specified is
0.0.</p>

<p>If the value for flatness is 0 POV-Ray will always subdivide the patch to
the extend specified by <code>u_steps</code> and <code>v_steps</code>. If
flatness is greater than 0 then every time the patch is split, POV-Ray will
check to see if there is any need to split further.</p>

<p>There are both advantages and disadvantages to using a non-zero flatness.
The advantages include:</p>

<p>- If the patch is not very curved, then this will be detected and
POV-Ray will not waste a lot of time looking at the wrong pieces.</p>

<p>- If the patch is only highly curved in a couple of places, POV-Ray will keep
subdividing there and concentrate its efforts on the hard part.</p>

<p>The biggest disadvantage is that if POV-Ray stops subdividing at a
particular level on one part of the patch and at a different level on an
adjacent part of the patch there is the potential for cracking. This is
typically visible as spots within the patch where you can see through. How
bad this appears depends very highly on the angle at which you are viewing
the patch.</p>

<p>
Like triangles, the bicubic patch is not meant to be generated by hand. These
shapes should be created by a special utility. You may be able to acquire
utilities to generate these shapes from the same source from which you
obtained POV-Ray. Here is an example:</p>
<pre>
bicubic_patch {
  type 0
  flatness 0.01
  u_steps 4
  v_steps 4
  &lt;0, 0, 2&gt;, &lt;1, 0, 0&gt;, &lt;2, 0, 0&gt;, &lt;3, 0,-2&gt;,
  &lt;0, 1  0&gt;, &lt;1, 1, 0&gt;, &lt;2, 1, 0&gt;, &lt;3, 1, 0&gt;,
  &lt;0, 2, 0&gt;, &lt;1, 2, 0&gt;, &lt;2, 2, 0&gt;, &lt;3, 2, 0&gt;,
  &lt;0, 3, 2&gt;, &lt;1, 3, 0&gt;, &lt;2, 3, 0&gt;, &lt;3, 3, -2&gt;
  }
</pre>

<p>The triangles in a POV-Ray <code>bicubic_patch</code> are automatically
smoothed using normal interpolation but it is up to the user (or the
user's utility program) to create control points which smoothly stitch
together groups of patches.</p>

</div>
<a name="r3_4_2_2"></a>
<div class="content-level-h4" contains="Disc" id="r3_4_2_2">
<h4>3.4.2.2 Disc</h4>
<p>Another flat, finite object available with POV-Ray is the <code>
disc</code>. The disc is infinitely thin, it has no thickness. If you want a
disc with true thickness you should use a very short cylinder. A disc shape
may be defined by:</p>
<pre>
DISC:
  disc {
    &lt;Center&gt;, &lt;Normal&gt;, Radius [, Hole_Radius]
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>Disc default values:</p>
<pre>
HOLE RADIUS : 0.0
</pre>

<p>The vector <em><code>&lt;Center&gt;</code></em> defines the x, y, z
coordinates of the center of the disc. The <em><code>
&lt;Normal&gt;</code></em> vector describes its orientation by describing its
surface normal vector. This is followed by a float specifying the <em> <code>
Radius</code></em>. This may be optionally followed by another float
specifying the radius of a hole to be cut from the center of the disc.</p>

<p class="Note"><strong>Note:</strong> The inside of a disc is the inside of the plane that contains
the disc.  Also note that it is not constrained by the radius of the disc.</p>

</div>
<a name="r3_4_2_3"></a>
<div class="content-level-h4" contains="Mesh" id="r3_4_2_3">
<h4>3.4.2.3 Mesh</h4>
<p>The <code>mesh</code> object can be used to efficiently store large
numbers of triangles. Its syntax is:</p>
<pre>
MESH:
  mesh {
    MESH_TRIANGLE...
    [MESH_MODIFIER...]
    }
MESH_TRIANGLE:
  triangle {
    &lt;Corner_1&gt;, &lt;Corner_2&gt;, &lt;Corner_3&gt;
    [uv_vectors &lt;uv_Corner_1&gt;, &lt;uv_Corner_2&gt;, &lt;uv_Corner_3&gt;]
    [MESH_TEXTURE]
    } |

  smooth_triangle {
    &lt;Corner_1&gt;, &lt;Normal_1&gt;,
    &lt;Corner_2&gt;, &lt;Normal_2&gt;,
    &lt;Corner_3&gt;, &lt;Normal_3&gt;
    [uv_vectors &lt;uv_Corner_1&gt;, &lt;uv_Corner_2&gt;, &lt;uv_Corner_3&gt;]
    [MESH_TEXTURE]
    }
MESH_TEXTURE:
  texture { TEXTURE_IDENTIFIER }
  texture_list {
    TEXTURE_IDENTIFIER TEXTURE_IDENTIFIER TEXTURE_IDENTIFIER
    }

MESH_MODIFIER:
  inside_vector &lt;direction&gt; | hierarchy [ Boolean ] |
  OBJECT_MODIFIER
</pre>

<p>Mesh default values:</p>
<pre>
hierarchy : on
</pre>

<p>Any number of <code>triangle</code> and/or <code>smooth_triangle</code>
statements can be used and each of those triangles can be individually
textured by assigning a texture identifier to it. The texture has to be
declared before the mesh is parsed. It is not possible to use texture
definitions inside the triangle or smooth triangle statements. This is a
restriction that is necessary for an efficient storage of the assigned
textures. See <a href="r3_4.html#r3_4_2_6">Triangle and Smooth Triangle</a> for more information on triangles.</p>
<p>The <code>mesh</code> object can support <code>uv_mapping</code>. For this, per triangle the keyword
<code>uv_vectors</code> has to be given, together with three 2D uv-vectors. Each vector specifies a location
in the xy-plane from which the texture has to be mapped to the matching points of the triangle.
Also see the section <a href="r3_5.html#r3_5_7">uv_mapping</a>.</p>

<p>The mesh's components are internally bounded by a bounding box hierarchy
to speed up intersection testing. The bounding hierarchy can be turned off
with the <code>hierarchy off</code> keyword. This should only be done if
memory is short or the mesh consists of only a few triangles. The default is
<code>hierarchy on</code>.</p>

<p>Copies of a mesh object refer to the same triangle data and thus consume
very little memory. You can easily trace a hundred copies of a 10000 triangle
mesh without running out of memory (assuming the first mesh fits into
memory). The mesh object has two advantages over a union of triangles: it
needs less memory and it is transformed faster. The memory requirements are
reduced by efficiently storing the triangles vertices and normals. The
parsing time for transformed meshes is reduced because only the mesh object
has to be transformed and not every single triangle as it is necessary for
unions.</p>

<p>The mesh object can currently only include triangle and smooth triangle
components. That restriction may change, allowing polygonal components, at
some point in the future.</p>

</div>



<a name="r3_4_2_3_1"></a>
<div class="content-level-h5" contains="Solid Mesh" id="r3_4_2_3_1">
<h5>3.4.2.3.1 Solid Mesh</h5>
<p>The triangle mesh objects <code>mesh</code> and <code>mesh2</code> can now be used in CSG objects such as difference and intersect. Adding the <code>inside_vector</code> they do have a defined <em>inside</em>. This will only work for well-behaved meshes, which are completely closed volumes. If meshes have any holes in them, this might work, but the results are not guaranteed.</p>

<p>To determine if a point is inside a triangle mesh, POV-Ray shoots a ray from the point in some arbitrary direction. If this vector intersects an odd number of triangles, the point is inside the mesh. If it intersects an even number of triangles, the point is outside of the mesh. You can specify the direction of this vector. For example, to use <code>+z</code> as the direction, you would add the following line to the triangle mesh description (following all other mesh data, but before the object modifiers).</p>
<pre>
inside_vector &lt;0, 0, 1&gt;
</pre>
<p>This change does not have any effect on unions of triangles, these will still be always hollow.</p>

</div>
<a name="r3_4_2_4"></a>
<div class="content-level-h4" contains="Mesh2" id="r3_4_2_4">
<h4>3.4.2.4 Mesh2</h4>
<p>The new mesh syntax is designed for use in conversion from other file formats.</p>

<pre>
MESH2 :
  mesh2{
    VECTORS...
    LISTS...   |
    INDICES... |
    MESH_MODIFIERS
    }
VECTORS :
  vertex_vectors {
  number_of_vertices,
  &lt;vertex1&gt;, &lt;vertex2&gt;, ...
  }|
  normal_vectors {
    number_of_normals,
    &lt;normal1&gt;, &lt;normal2&gt;, ...
    }|
  uv_vectors {
    number_of_uv_vectors,
    &lt;uv_vect1&gt;, &lt;uv_vect2&gt;, ...
    }
LISTS :
  texture_list {
    number_of_textures,
    texture { Texture1 },
    texture { Texture2 }, ...
    }|
INDICES :
  face_indices {
    number_of_faces,
      &lt;index_a, index_b, index_c&gt; [,texture_index [,
    texture_index, texture_index]],
      &lt;index_d, index_e, index_f&gt; [,texture_index [,
      texture_index, texture_index]],
      ...
      }|
  normal_indices {
    number_of_faces,
      &lt;index_a, index_b, index_c&gt;,
      &lt;index_d, index_e, index_f&gt;,
      ...
      }|
  uv_indices {
    number_of_faces,
      &lt;index_a, index_b, index_c&gt;,
      &lt;index_d, index_e, index_f&gt;,
      ...
      }
MESH_MODIFIER :
  inside_vector &lt;direction&gt; | OBJECT_MODIFIERS
</pre>


<p>The <code>mesh2</code> object definition <em>MUST</em> be specified in the following order:</p>
<ul>
<li>VECTORS</li>
<li>LISTS</li>
<li>INDICES</li>
</ul>

<p>The <code>normal_vectors</code>, <code>uv_vectors</code>, and <code>texture_list</code> sections are optional. 
If the number of normals equals the number of vertices then the normal_indices section is optional and the indexes from the <code>face_indices</code> section are used instead. Likewise for the <code>uv_indices</code> section.</p>
<p class="Note"><strong>Note:</strong> The <code>texture_list</code> section is optional <em>only</em> if <code>face_indices</code> doesn't contain any texture index values.</p>
<p>For example:</p>
<pre>
face_indices {
  number_of_faces,
  &lt;index_a, index_b, index_c&gt;,
  &lt;index_d, index_e, index_f&gt;,
  ...
  }
</pre>
<p class="Note"><strong>Note:</strong> The numbers of <code>uv_indices</code> must equal number of faces.</p>
<p>The indexes are <em>zero based</em>, so the first item in each list has an index of zero.</p>

</div>
<a name="r3_4_2_4_1"></a>
<div class="content-level-h5" contains="Smooth and Flat triangles in the same mesh" id="r3_4_2_4_1">
<h5>3.4.2.4.1 Smooth and Flat triangles in the same mesh</h5>
<p>You can specify both flat and smooth triangles in the same mesh. To do this, specify
the smooth triangles first in the <code>face_indices</code>
section, followed by the flat triangles. Then, specify normal indices (in the 
<code>normal_indices</code> section) for only the
smooth triangles. Any remaining triangles that do not have normal indices associated with
them will be assumed to be flat triangles.</p>

</div>
<a name="r3_4_2_4_2"></a>
<div class="content-level-h5" contains="Mesh Triangle Textures" id="r3_4_2_4_2">
<h5>3.4.2.4.2 Mesh Triangle Textures</h5>
<p>To specify a texture for an individual mesh triangle, specify a single integer texture
index following the face-index vector for that triangle.</p>

<p>To specify three textures for vertex-texture interpolation, specify three integer
texture indices (separated by commas) following the face-index vector for that triangle.</p>


<p>Vertex-texture interpolation and textures for an individual triangle can be mixed in the same mesh</p>

</div>
<a name="r3_4_2_5"></a>
<div class="content-level-h4" contains="Polygon" id="r3_4_2_5">
<h4>3.4.2.5 Polygon</h4>
<p>The <code>polygon</code> object is useful for creating rectangles, squares
and other planar shapes with more than three edges. Their syntax is:</p>
<pre>
POLYGON:
  polygon {
    Number_Of_Points, &lt;Point_1&gt; &lt;Point_2&gt;... &lt;Point_n&gt;
    [OBJECT_MODIFIER...]
    }
</pre>

<p>The float <em><code>Number_Of_Points</code></em> tells how many points are
used to define the polygon. The points <em><code>&lt;Point_1&gt;</code></em>
through <em><code>&lt;Point_n&gt;</code></em> describe the polygon or
polygons. A polygon can contain any number of sub-polygons, either
overlapping or not. In places where an even number of polygons overlaps a
hole appears. When you repeat the first point of a sub-polygon, it closes it
and starts a new sub-polygon's point sequence. This means that all points
of a sub-polygon are different.</p>
<p>
If the last sub-polygon is not closed a warning is issued and the program
automatically closes the polygon. This is useful because polygons imported
from other programs may not be closed, i.e. their first and last point are
not the same.</p>
<p>
All points of a polygon are three-dimensional vectors that have to lay on
the same plane. If this is not the case an error occurs. It is common to use
two-dimensional vectors to describe the polygon. POV-Ray assumes that the z
value is zero in this case.</p>
<p>
A square polygon that matches the default planar image map is simply:</p>
<pre>
polygon {
  4,
  &lt;0, 0&gt;, &lt;0, 1&gt;, &lt;1, 1&gt;, &lt;1, 0&gt;
  texture {
    finish { ambient 1 diffuse 0 }
    pigment { image_map { gif &quot;test.gif&quot;  } }
    }
  //scale and rotate as needed here
  }
</pre>

<p>The sub-polygon feature can be used to generate complex shapes like the
letter &quot;P&quot;, where a hole is cut into another polygon:</p>
<pre>
#declare P = polygon {
  12,
  &lt;0, 0&gt;, &lt;0, 6&gt;, &lt;4, 6&gt;, &lt;4, 3&gt;, &lt;1, 3&gt;, &lt;1,0&gt;, &lt;0, 0&gt;, 
  &lt;1, 4&gt;, &lt;1, 5&gt;, &lt;3, 5&gt;, &lt;3, 4&gt;, &lt;1, 4&gt;
  }
</pre>

<p>The first sub-polygon (on the first line) describes the outer shape of the
letter &quot;P&quot;. The second sub-polygon (on the second line) describes
the rectangular hole that is cut in the top of the letter &quot;P&quot;. Both
rectangles are closed, i.e. their first and last points are the same.</p>
<p>
The feature of cutting holes into a polygon is based on the polygon
inside/outside test used. A point is considered to be inside a polygon if a
straight line drawn from this point in an arbitrary direction crosses an odd
number of edges, this is known as <em>Jordan's curve theorem</em>.</p>
<p>
Another very complex example showing one large triangle with three small
holes and three separate, small triangles is given below:</p>
<pre>
polygon {
  28,
  &lt;0, 0&gt; &lt;1, 0&gt; &lt;0, 1&gt; &lt;0, 0&gt;          // large outer triangle
  &lt;.3, .7&gt; &lt;.4, .7&gt; &lt;.3, .8&gt; &lt;.3, .7&gt;  // small outer triangle #1
  &lt;.5, .5&gt; &lt;.6, .5&gt; &lt;.5, .6&gt; &lt;.5, .5&gt;  // small outer triangle #2
  &lt;.7, .3&gt; &lt;.8, .3&gt; &lt;.7, .4&gt; &lt;.7, .3&gt;  // small outer triangle #3
  &lt;.5, .2&gt; &lt;.6, .2&gt; &lt;.5, .3&gt; &lt;.5, .2&gt;  // inner triangle #1
  &lt;.2, .5&gt; &lt;.3, .5&gt; &lt;.2, .6&gt; &lt;.2, .5&gt;  // inner triangle #2
  &lt;.1, .1&gt; &lt;.2, .1&gt; &lt;.1, .2&gt; &lt;.1, .1&gt;  // inner triangle #3
  }
</pre>

</div>
<a name="r3_4_2_6"></a>
<div class="content-level-h4" contains="Triangle and Smooth Triangle" id="r3_4_2_6">
<h4>3.4.2.6 Triangle and Smooth Triangle</h4>
<p>The <code>triangle</code> primitive is available in order to make more
complex objects than the built-in shapes will permit. Triangles are usually
not created by hand but are converted from other files or generated by
utilities. A triangle is defined by</p>
<pre>
TRIANGLE:
  triangle {
    &lt;Corner_1&gt;, &lt;Corner_2&gt;, &lt;Corner_3&gt;
    [OBJECT_MODIFIER...]
    }
</pre>

<p>where <em><code>&lt;Corner_n&gt;</code></em> is a vector defining the x,
y, z coordinates of each corner of the triangle.</p>
<p>
Because triangles are perfectly flat surfaces it would require extremely
large numbers of very small triangles to approximate a smooth, curved
surface. However much of our perception of smooth surfaces is dependent upon
the way light and shading is done. By artificially modifying the surface
normals we can simulate a smooth surface and hide the sharp-edged seams
between individual triangles.</p>

<p>The <code>smooth_triangle</code> primitive is used for just such purposes.
The smooth triangles use a formula called Phong normal interpolation to
calculate the surface normal for any point on the triangle based on normal
vectors which you define for the three corners. This makes the triangle
appear to be a smooth curved surface. A smooth triangle is defined by</p>
<pre>
SMOOTH_TRIANGLE:
  smooth_triangle {
  &lt;Corner_1&gt;, &lt;Normal_1&gt;, &lt;Corner_2&gt;,
  &lt;Normal_2&gt;, &lt;Corner_3&gt;, &lt;Normal_3&gt;
  [OBJECT_MODIFIER...]
  }
</pre>

<p>where the corners are defined as in regular triangles and <em><code>
&lt;Normal_n&gt;</code></em> is a vector describing the direction of the
surface normal at each corner.</p>
<p>
These normal vectors are prohibitively difficult to compute by hand.
Therefore smooth triangles are almost always generated by utility programs.
To achieve smooth results, any triangles which share a common vertex should
have the same normal vector at that vertex. Generally the smoothed normal
should be the average of all the actual normals of the triangles which share
that point.</p>
<p>
The <code>mesh</code> object is a way to combine many <code>triangle</code>
and <code>smooth_triangle</code> objects together in a very efficient way.
See <a href="r3_4.html#r3_4_2_3">Mesh</a> for details.</p>

</div>
<a name="r3_4_3"></a>
<div class="content-level-h3" contains="Infinite Solid Primitives" id="r3_4_3">
<h3>3.4.3 Infinite Solid Primitives</h3>
<p>There are five polynomial primitive shapes that are possibly infinite and
do not respond to automatic bounding. They are plane, cubic, poly, quadric
and quartic. They do have a well defined inside and may be used in CSG and
inside a <code>clipped_by</code> statement. As with all shapes they can be
translated, rotated and scaled.</p>

</div>
<a name="r3_4_3_1"></a>
<div class="content-level-h4" contains="Plane" id="r3_4_3_1">
<h4>3.4.3.1 Plane</h4>
<p>The <code>plane</code> primitive is a simple way to define an infinite
flat surface. The plane is not a thin boundary or can be compared to a sheet
of paper. A plane is a solid object of infinite size that divides POV-space
in two parts, inside and outside the plane. The plane is specified as follows:</p>
<pre>
PLANE:
  plane {
    &lt;Normal&gt;, Distance
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>The <em><code>&lt;Normal&gt;</code></em> vector defines the surface normal
of the plane. A surface normal is a vector which points up from the surface
at a 90 degree angle. This is followed by a float value that gives the
distance along the normal that the plane is from the origin (that is only
true if the normal vector has unit length; see below). For example:</p>
<pre>
plane { &lt;0, 1, 0&gt;, 4 }
</pre>

<p>This is a plane where straight up is defined in the positive y-direction.
The plane is 4 units in that direction away from the origin. Because most
planes are defined with surface normals in the direction of an axis you will
often see planes defined using the <code>x</code>, <code>y</code> or <code>
z</code> built-in vector identifiers. The example above could be specified
as:</p>
<pre>
plane { y, 4 }
</pre>

<p>The plane extends infinitely in the x- and z-directions. It effectively
divides the world into two pieces. By definition the normal vector points to
the outside of the plane while any points away from the vector are defined as
inside. This inside/outside distinction is important when using planes in CSG
and <code>clipped_by</code>. It is also important when using fog or
atmospheric media. If you place a camera on the &quot;inside&quot; half of
the world, then the fog or media will not appear. Such issues arise in any
solid object but it is more common with planes. Users typically know when
they have accidentally placed a camera inside a sphere or box but
&quot;inside a plane&quot; is an unusual concept. In general you can reverse the
inside/outside properties of an object by adding the object modifier <code>
inverse</code>. See <a href="r3_4.html#r3_4_7_5">Inverse</a> and <a href="r3_6.html#r3_6_1_2">Empty and Solid Objects</a> for details.</p>
<p>
A plane is called a <em>polynomial</em> shape because it is defined by a
first order polynomial equation. Given a plane:</p>
<pre>
plane { &lt;A, B, C&gt;, D }
</pre>

<p>it can be represented by the equation <em><code>A*x + B*y + C*z - D*sqrt(A^2 + B^2 + C^2) = 0</code></em>.</p>
<p>
Therefore our example <code>plane{y,4}</code> is actually the polynomial
equation y=4. You can think of this as a set of all x, y, z points where all
have y values equal to 4, regardless of the x or z values.</p>
<p>
This equation is a first order polynomial because each term contains only
single powers of x, y or z. A second order equation has terms like x^2, y^2,
z^2, xy, xz and yz. Another name for a 2nd order equation is a quadric
equation. Third order polys are called cubics. A 4th order equation is a
quartic. Such shapes are described in the sections below.</p>

</div>
<a name="r3_4_3_2"></a>
<div class="content-level-h4" contains="Poly, Cubic and Quartic" id="r3_4_3_2">
<h4>3.4.3.2 Poly, Cubic and Quartic</h4>
<p>Higher order polynomial surfaces may be defined by the use of a <code>
poly</code> shape. The syntax is</p>
<pre>
POLY:
  poly {
    Order, &lt;A1, A2, A3,... An&gt;
    [POLY_MODIFIERS...]
    }
POLY_MODIFIERS:
  sturm | OBJECT_MODIFIER
</pre>

<p>Poly default values:</p>
<pre>
sturm : off
</pre>

<p>where <em><code>Order</code></em> is an integer number from 2 to 35
inclusively that specifies the order of the equation. <em><code>A1, A2, ...
An</code></em> are float values for the coefficients of the equation. There
are <em><code>n</code></em> such terms where <em><code>n = ((Order+1)*(Order+2)*(Order+3))/6.</code></em></p>

<p>The <code>cubic</code> object
is an alternate way to specify 3rd order polys. Its syntax is:</p>
<pre>
CUBIC:
  cubic {
    &lt;A1, A2, A3,... A20&gt;
    [POLY_MODIFIERS...]
    }
</pre>

<p>Also 4th order equations may be specified with the <code>quartic</code>
object. Its syntax is:</p>
<pre>
QUARTIC:
  quartic {
    &lt;A1, A2, A3,... A35&gt;
    [POLY_MODIFIERS...]
    }
</pre>

<p>The following table shows which polynomial terms correspond to which x,y,z
factors for the orders 2 to 7. Remember <code>cubic</code> is actually a 3rd order polynomial and
<code>quartic</code> is 4th order.</p>

<table class="matte" SUMMARY="Cubic and quartic polynomial terms" width="700px">
<tr>
<!-- That this is only 99% is intentional! [trf] -->
<th width="5%"> </th>
<th width="5%">2<sup>nd</sup></th>
<th width="6%">3<sup>rd</sup></th>
<th width="7%">4<sup>th</sup></th>
<th width="8%">5<sup>th</sup></th>
<th width="9%">6<sup>th</sup></th>
<th width="10%">7<sup>th</sup></th>
<th width="6%"> </th>
<th width="8%">5<sup>th</sup></th>
<th width="9%">6<sup>th</sup></th>
<th width="10%">7<sup>th</sup></th>
<th width="6%"> </th>
<th width="5%">6<sup>th</sup></th>
<th width="5%">7<sup>th</sup></th>
</tr>
<tr>
<td>A<sub>1</sub></td>
<td>x<sup>2</sup></td>
<td>x<sup>3</sup></td>
<td>x<sup>4</sup></td>
<td>x<sup>5</sup></td>
<td>x<sup>6</sup></td>
<td>x<sup>7</sup></td>
<td>A<sub>41</sub></td>
<td>y<sup>3</sup></td>
<td>xy<sup>3</sup></td>
<td>x<sup>2</sup>y<sup>3</sup></td>
<td>A<sub>81</sub></td>
<td>z<sup>3</sup></td>
<td>xz<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>2</sub></td>
<td>xy</td>
<td>x<sup>2</sup>y</td>
<td>x<sup>3</sup>y</td>
<td>x<sup>4</sup>y</td>
<td>x<sup>5</sup>y</td>
<td>x<sup>6</sup>y</td>
<td>A<sub>42</sub></td>
<td>y<sup>2</sup>z<sup>3</sup></td>
<td>xy<sup>2</sup>z<sup>3</sup></td>
<td>x<sup>2</sup>y<sup>2</sup>z<sup>3</sup></td>
<td>A<sub>82</sub></td>
<td>z<sup>2</sup></td>
<td>xz<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>3</sub></td>
<td>xz</td>
<td>x<sup>2</sup>z</td>
<td>x<sup>3</sup>z</td>
<td>x<sup>4</sup>z</td>
<td>x<sup>5</sup>z</td>
<td>x<sup>6</sup>z</td>
<td>A<sub>43</sub></td>
<td>y<sup>2</sup>z<sup>2</sup></td>
<td>xy<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup>z<sup>2</sup></td>
<td>A<sub>83</sub></td>
<td>z</td>
<td>xz</td>
</tr>
<tr>
<td>A<sub>4</sub></td>
<td>x</td>
<td>x<sup>2</sup></td>
<td>x<sup>3</sup></td>
<td>x<sup>4</sup></td>
<td>x<sup>5</sup></td>
<td>x<sup>6</sup></td>
<td>A<sub>44</sub></td>
<td>y<sup>2</sup>z</td>
<td>xy<sup>2</sup>z</td>
<td>x<sup>2</sup>y<sup>2</sup>z</td>
<td>A<sub>84</sub></td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>A<sub>5</sub></td>
<td>y<sup>2</sup></td>
<td>xy<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup></td>
<td>x<sup>3</sup>y<sup>2</sup></td>
<td>x<sup>4</sup>y<sup>2</sup></td>
<td>x<sup>5</sup>y<sup>2</sup></td>
<td>A<sub>45</sub></td>
<td>y<sup>2</sup></td>
<td>xy<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup></td>
<td>A<sub>85</sub></td>
<td> </td>
<td>y<sup>7</sup></td>
</tr>
<tr>
<td>A<sub>6</sub></td>
<td>yz</td>
<td>xyz</td>
<td>x<sup>2</sup>yz</td>
<td>x<sup>3</sup>yz</td>
<td>x<sup>4</sup>yz</td>
<td>x<sup>5</sup>yz</td>
<td>A<sub>46</sub></td>
<td>yz<sup>4</sup></td>
<td>xyz<sup>4</sup></td>
<td>x<sup>2</sup>yz<sup>4</sup></td>
<td>A<sub>86</sub></td>
<td> </td>
<td>y<sup>6</sup>z</td>
</tr>
<tr>
<td>A<sub>7</sub></td>
<td>y</td>
<td>xy</td>
<td>x<sup>2</sup>y</td>
<td>x<sup>3</sup>y</td>
<td>x<sup>4</sup>y</td>
<td>x<sup>5</sup>y</td>
<td>A<sub>47</sub></td>
<td>yz<sup>3</sup></td>
<td>xyz<sup>3</sup></td>
<td>x<sup>2</sup>yz<sup>3</sup></td>
<td>A<sub>87</sub></td>
<td> </td>
<td>y<sup>6</sup></td>
</tr>
<tr>
<td>A<sub>8</sub></td>
<td>z<sup>2</sup></td>
<td>xz<sup>2</sup></td>
<td>x<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>3</sup>z<sup>2</sup></td>
<td>x<sup>4</sup>z<sup>2</sup></td>
<td>x<sup>5</sup>z<sup>2</sup></td>
<td>A<sub>48</sub></td>
<td>yz<sup>2</sup></td>
<td>xyz<sup>2</sup></td>
<td>x<sup>2</sup>yz<sup>2</sup></td>
<td>A<sub>88</sub></td>
<td> </td>
<td>y<sup>5</sup>z<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>9</sub></td>
<td>z</td>
<td>xz</td>
<td>x<sup>2</sup>z</td>
<td>x<sup>3</sup>z</td>
<td>x<sup>4</sup>z</td>
<td>x<sup>5</sup>z</td>
<td>A<sub>49</sub></td>
<td>yz</td>
<td>xyz</td>
<td>x<sup>2</sup>yz</td>
<td>A<sub>89</sub></td>
<td> </td>
<td>y<sup>5</sup>z</td>
</tr>
<tr>
<td>A<sub>10</sub></td>
<td>1</td>
<td>x</td>
<td>x<sup>2</sup></td>
<td>x<sup>3</sup></td>
<td>x<sup>4</sup></td>
<td>x<sup>5</sup></td>
<td>A<sub>50</sub></td>
<td>y</td>
<td>xy</td>
<td>x<sup>2</sup>y</td>
<td>A<sub>90</sub></td>
<td> </td>
<td>y<sup>5</sup></td>
</tr>
<tr>
<td>A<sub>11</sub></td>
<td> </td>
<td>y<sup>3</sup></td>
<td>xy<sup>3</sup></td>
<td>x<sup>2</sup>y<sup>3</sup></td>
<td>x<sup>3</sup>y<sup>3</sup></td>
<td>x<sup>4</sup>y<sup>3</sup></td>
<td>A<sub>51</sub></td>
<td>z<sup>5</sup></td>
<td>xz<sup>5</sup></td>
<td>x<sup>2</sup>z<sup>5</sup></td>
<td>A<sub>91</sub></td>
<td> </td>
<td>y<sup>4</sup>z<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>12</sub></td>
<td> </td>
<td>y<sup>2</sup>z</td>
<td>xy<sup>2</sup>z</td>
<td>x<sup>2</sup>y<sup>2</sup>z</td>
<td>x<sup>3</sup>y<sup>2</sup>z</td>
<td>x<sup>4</sup>y<sup>2</sup>z</td>
<td>A<sub>52</sub></td>
<td>z<sup>4</sup></td>
<td>xz<sup>4</sup></td>
<td>x<sup>2</sup>z<sup>4</sup></td>
<td>A<sub>92</sub></td>
<td> </td>
<td>y<sup>4</sup>z<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>13</sub></td>
<td> </td>
<td>y<sup>2</sup></td>
<td>xy<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup></td>
<td>x<sup>3</sup>y<sup>2</sup></td>
<td>x<sup>4</sup>y<sup>2</sup></td>
<td>A<sub>53</sub></td>
<td>z<sup>3</sup></td>
<td>xz<sup>3</sup></td>
<td>x<sup>2</sup>z<sup>3</sup></td>
<td>A<sub>93</sub></td>
<td> </td>
<td>y<sup>4</sup>z</td>
</tr>
<tr>
<td>A<sub>14</sub></td>
<td> </td>
<td>yz<sup>2</sup></td>
<td>xyz<sup>2</sup></td>
<td>x<sup>2</sup>yz<sup>2</sup></td>
<td>x<sup>3</sup>yz<sup>2</sup></td>
<td>x<sup>4</sup>yz<sup>2</sup></td>
<td>A<sub>54</sub></td>
<td>z<sup>2</sup></td>
<td>xz<sup>2</sup></td>
<td>x<sup>2</sup>z<sup>2</sup></td>
<td>A<sub>94</sub></td>
<td> </td>
<td>y<sup>4</sup></td>
</tr>
<tr>
<td>A<sub>15</sub></td>
<td> </td>
<td>yz</td>
<td>xyz</td>
<td>x<sup>2</sup>yz</td>
<td>x<sup>3</sup>yz</td>
<td>x<sup>4</sup>yz</td>
<td>A<sub>55</sub></td>
<td>z</td>
<td>xz</td>
<td>x<sup>2</sup>z</td>
<td>A<sub>95</sub></td>
<td> </td>
<td>y<sup>3</sup>z<sup>4</sup></td>
</tr>
<tr>
<td>A<sub>16</sub></td>
<td> </td>
<td>y</td>
<td>xy</td>
<td>x<sup>2</sup>y</td>
<td>x<sup>3</sup>y</td>
<td>x<sup>4</sup>y</td>
<td>A<sub>56</sub></td>
<td>1</td>
<td>x</td>
<td>x<sup>2</sup></td>
<td>A<sub>96</sub></td>
<td> </td>
<td>y<sup>3</sup>z<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>17</sub></td>
<td> </td>
<td>z<sup>3</sup></td>
<td>xz<sup>3</sup></td>
<td>x<sup>2</sup>z<sup>3</sup></td>
<td>x<sup>3</sup>z<sup>3</sup></td>
<td>x<sup>4</sup>z<sup>3</sup></td>
<td>A<sub>57</sub></td>
<td>&nbsp;</td>
<td>y<sup>6</sup></td>
<td>xy<sup>6</sup></td>
<td>A<sub>97</sub></td>
<td> </td>
<td>y<sup>3</sup>z<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>18</sub></td>
<td> </td>
<td>z<sup>2</sup></td>
<td>xz<sup>2</sup></td>
<td>x<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>3</sup>z<sup>2</sup></td>
<td>x<sup>4</sup>z<sup>2</sup></td>
<td>A<sub>58</sub></td>
<td> </td>
<td>y<sup>5</sup>z</td>
<td>xy<sup>5</sup>z</td>
<td>A<sub>98</sub></td>
<td> </td>
<td>y<sup>3</sup>z</td>
</tr>
<tr>
<td>A<sub>19</sub></td>
<td> </td>
<td>z</td>
<td>xz</td>
<td>x<sup>2</sup>z</td>
<td>x<sup>3</sup>z</td>
<td>x<sup>4</sup>z</td>
<td>A<sub>59</sub></td>
<td> </td>
<td>y<sup>5</sup></td>
<td>xy<sup>5</sup></td>
<td>A<sub>99</sub></td>
<td> </td>
<td>y<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>20</sub></td>
<td> </td>
<td>1</td>
<td>x</td>
<td>x<sup>2</sup></td>
<td>x<sup>3</sup></td>
<td>x<sup>4</sup></td>
<td>A<sub>60</sub></td>
<td> </td>
<td>y<sup>4</sup>z<sup>2</sup></td>
<td>xy<sup>4</sup>z<sup>2</sup></td>
<td>A<sub>100</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>5</sup></td>
</tr>
<tr>
<td>A<sub>21</sub></td>
<td> </td>
<td> </td>
<td>y<sup>4</sup></td>
<td>xy<sup>4</sup></td>
<td>x<sup>2</sup>y<sup>4</sup></td>
<td>x<sup>3</sup>y<sup>4</sup></td>
<td>A<sub>61</sub></td>
<td> </td>
<td>y<sup>4</sup>z</td>
<td>xy<sup>4</sup>z</td>
<td>A<sub>101</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>4</sup></td>
</tr>
<tr>
<td>A<sub>22</sub></td>
<td> </td>
<td> </td>
<td>y<sup>3</sup>z</td>
<td>xy<sup>3</sup>z</td>
<td>x<sup>2</sup>y<sup>3</sup>z</td>
<td>x<sup>3</sup>y<sup>3</sup>z</td>
<td>A<sub>62</sub></td>
<td> </td>
<td>y<sup>4</sup></td>
<td>xy<sup>4</sup></td>
<td>A<sub>102</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>23</sub></td>
<td> </td>
<td> </td>
<td>y<sup>3</sup></td>
<td>xy<sup>3</sup></td>
<td>x<sup>2</sup>y<sup>3</sup></td>
<td>x<sup>3</sup>y<sup>3</sup></td>
<td>A<sub>63</sub></td>
<td> </td>
<td>y<sup>3</sup>z<sup>3</sup></td>
<td>xy<sup>3</sup>z<sup>3</sup></td>
<td>A<sub>103</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>24</sub></td>
<td> </td>
<td> </td>
<td>y<sup>2</sup>z<sup>2</sup></td>
<td>xy<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>3</sup>y<sup>2</sup>z<sup>2</sup></td>
<td>A<sub>64</sub></td>
<td> </td>
<td>y<sup>3</sup>z<sup>2</sup></td>
<td>xy<sup>3</sup>z<sup>2</sup></td>
<td>A<sub>104</sub></td>
<td> </td>
<td>y<sup>2</sup>z</td>
</tr>
<tr>
<td>A<sub>25</sub></td>
<td> </td>
<td> </td>
<td>y<sup>2</sup>z</td>
<td>xy<sup>2</sup>z</td>
<td>x<sup>2</sup>y<sup>2</sup>z</td>
<td>x<sup>3</sup>y<sup>2</sup>z</td>
<td>A<sub>65</sub></td>
<td> </td>
<td>y<sup>3</sup>z</td>
<td>xy<sup>3</sup>z</td>
<td>A<sub>105</sub></td>
<td> </td>
<td>y<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>26</sub></td>
<td> </td>
<td> </td>
<td>y<sup>2</sup></td>
<td>xy<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>2</sup></td>
<td>x<sup>3</sup>y<sup>2</sup></td>
<td>A<sub>66</sub></td>
<td> </td>
<td>y<sup>3</sup></td>
<td>xy<sup>3</sup></td>
<td>A<sub>106</sub></td>
<td> </td>
<td>yz<sup>6</sup></td>
</tr>
<tr>
<td>A<sub>27</sub></td>
<td> </td>
<td> </td>
<td>yz<sup>3</sup></td>
<td>xyz<sup>3</sup></td>
<td>x<sup>2</sup>yz<sup>3</sup></td>
<td>x<sup>3</sup>yz<sup>3</sup></td>
<td>A<sub>67</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>4</sup></td>
<td>xy<sup>2</sup>z<sup>4</sup></td>
<td>A<sub>107</sub></td>
<td> </td>
<td>yz<sup>5</sup></td>
</tr>
<tr>
<td>A<sub>28</sub></td>
<td> </td>
<td> </td>
<td>yz<sup>2</sup></td>
<td>xyz<sup>2</sup></td>
<td>x<sup>2</sup>yz<sup>2</sup></td>
<td>x<sup>3</sup>yz<sup>2</sup></td>
<td>A<sub>68</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>3</sup></td>
<td>xy<sup>2</sup>z<sup>3</sup></td>
<td>A<sub>108</sub></td>
<td> </td>
<td>yz<sup>4</sup></td>
</tr>
<tr>
<td>A<sub>29</sub></td>
<td> </td>
<td> </td>
<td>yz</td>
<td>xyz</td>
<td>x<sup>2</sup>yz</td>
<td>x<sup>3</sup>yz</td>
<td>A<sub>69</sub></td>
<td> </td>
<td>y<sup>2</sup>z<sup>2</sup></td>
<td>xy<sup>2</sup>z<sup>2</sup></td>
<td>A<sub>109</sub></td>
<td> </td>
<td>yz<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>30</sub></td>
<td> </td>
<td> </td>
<td>y</td>
<td>xy</td>
<td>x<sup>2</sup>y</td>
<td>x<sup>3</sup>y</td>
<td>A<sub>70</sub></td>
<td> </td>
<td>y<sup>2</sup>z</td>
<td>xy<sup>2</sup>z</td>
<td>A<sub>110</sub></td>
<td> </td>
<td>yz<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>31</sub></td>
<td> </td>
<td> </td>
<td>z<sup>4</sup></td>
<td>xz<sup>4</sup></td>
<td>x<sup>2</sup>z<sup>4</sup></td>
<td>x<sup>3</sup>z<sup>4</sup></td>
<td>A<sub>71</sub></td>
<td> </td>
<td>y<sup>2</sup></td>
<td>xy<sup>2</sup></td>
<td>A<sub>111</sub></td>
<td> </td>
<td>yz</td>
</tr>
<tr>
<td>A<sub>32</sub></td>
<td> </td>
<td> </td>
<td>z<sup>3</sup></td>
<td>xz<sup>3</sup></td>
<td>x<sup>2</sup>z<sup>3</sup></td>
<td>x<sup>3</sup>z<sup>3</sup></td>
<td>A<sub>72</sub></td>
<td> </td>
<td>yz<sup>5</sup></td>
<td>xyz<sup>5</sup></td>
<td>A<sub>112</sub></td>
<td> </td>
<td>y</td>
</tr>
<tr>
<td>A<sub>33</sub></td>
<td> </td>
<td> </td>
<td>z<sup>2</sup></td>
<td>xz<sup>2</sup></td>
<td>x<sup>2</sup>z<sup>2</sup></td>
<td>x<sup>3</sup>z<sup>2</sup></td>
<td>A<sub>73</sub></td>
<td> </td>
<td>yz<sup>4</sup></td>
<td>xyz<sup>4</sup></td>
<td>A<sub>113</sub></td>
<td> </td>
<td>z<sup>7</sup></td>
</tr>
<tr>
<td>A<sub>34</sub></td>
<td> </td>
<td> </td>
<td>z</td>
<td>xz</td>
<td>x<sup>2</sup>z</td>
<td>x<sup>3</sup>z</td>
<td>A<sub>74</sub></td>
<td> </td>
<td>yz<sup>3</sup></td>
<td>xyz<sup>3</sup></td>
<td>A<sub>114</sub></td>
<td> </td>
<td>z<sup>6</sup></td>
</tr>
<tr>
<td>A<sub>35</sub></td>
<td> </td>
<td> </td>
<td>1</td>
<td>x</td>
<td>x<sup>2</sup></td>
<td>x<sup>3</sup></td>
<td>A<sub>75</sub></td>
<td> </td>
<td>yz<sup>2</sup></td>
<td>xyz<sup>2</sup></td>
<td>A<sub>115</sub></td>
<td> </td>
<td>z<sup>5</sup></td>
</tr>
<tr>
<td>A<sub>36</sub></td>
<td> </td>
<td> </td>
<td> </td>
<td>y<sup>5</sup></td>
<td>xy<sup>5</sup></td>
<td>x<sup>2</sup>y<sup>5</sup></td>
<td>A<sub>76</sub></td>
<td> </td>
<td>yz</td>
<td>xyz</td>
<td>A<sub>116</sub></td>
<td> </td>
<td>z<sup>4</sup></td>
</tr>
<tr>
<td>A<sub>37</sub></td>
<td> </td>
<td> </td>
<td> </td>
<td>y<sup>4</sup>z</td>
<td>xy<sup>4</sup>z</td>
<td>x<sup>2</sup>y<sup>4</sup>z</td>
<td>A<sub>77</sub></td>
<td> </td>
<td>y</td>
<td>xy</td>
<td>A<sub>117</sub></td>
<td> </td>
<td>z<sup>3</sup></td>
</tr>
<tr>
<td>A<sub>38</sub></td>
<td> </td>
<td> </td>
<td> </td>
<td>y<sup>4</sup></td>
<td>xy<sup>4</sup></td>
<td>x<sup>2</sup>y<sup>4</sup></td>
<td>A<sub>78</sub></td>
<td> </td>
<td>z<sup>6</sup></td>
<td>xz<sup>6</sup></td>
<td>A<sub>118</sub></td>
<td> </td>
<td>z<sup>2</sup></td>
</tr>
<tr>
<td>A<sub>39</sub></td>
<td> </td>
<td> </td>
<td> </td>
<td>y<sup>3</sup>z<sup>2</sup></td>
<td>xy<sup>3</sup>z<sup>2</sup></td>
<td>x<sup>2</sup>y<sup>3</sup>z<sup>2</sup></td>
<td>A<sub>79</sub></td>
<td> </td>
<td>z<sup>5</sup></td>
<td>xz<sup>5</sup></td>
<td>A<sub>119</sub></td>
<td> </td>
<td>z</td>
</tr>
<tr>
<td>A<sub>40</sub></td>
<td> </td>
<td> </td>
<td> </td>
<td>y<sup>3</sup>z</td>
<td>xy<sup>3</sup>z</td>
<td>x<sup>2</sup>y<sup>3</sup>z</td>
<td>A<sub>80</sub></td>
<td> </td>
<td>z<sup>4</sup></td>
<td>xz<sup>4</sup></td>
<td>A<sub>120</sub></td>
<td> </td>
<td>1</td>
</tr>
</table>

<p>Polynomial shapes can be used to describe a large class of shapes
including the torus, the lemniscate, etc. For example, to declare a quartic
surface requires that each of the coefficients (<em><code>A1 ...
A35</code></em>) be placed in order into a single long vector of 35 terms. As an example let's define a torus the hard way. A Torus can be represented by the equation: <code>x<sup>4</sup> + y<sup>4</sup> + z<sup>4</sup> + 2 x<sup>2</sup> y<sup>2</sup> + 2 x<sup>2</sup> z<sup>2</sup> + 2 y<sup>2</sup> z<sup>2</sup> - 2 (r_02 + r_12)
x<sup>2</sup> + 2 (r_02 - r_12) y<sup>2</sup> - 2 (r_02 + r_12) z<sup>2</sup> + (r_02 - r_12)<sup>2</sup> = 0</code></p>

<p>Where r_0 is the major radius of the torus, the distance from the hole of
the donut to the middle of the ring of the donut, and r_1 is the minor radius
of the torus, the distance from the middle of the ring of the donut to the
outer surface. The following object declaration is for a torus having major
radius 6.3 minor radius 3.5 (Making the maximum width just under 20).</p>
<pre>
// Torus having major radius sqrt(40), minor radius sqrt(12)
quartic {
  &lt; 1,   0,   0,   0,   2,   0,   0,   2,   0,
  -104,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   1,   0,   0,   2,   0,  56,   0,
  0,   0,   0,   1,   0, -104,  0, 784 &gt;
  sturm
  }
</pre>

<p>For convenience an alternate syntax is available as <code>polynomial</code>. It doesn't care about the order of the coefficients, as long as you do not define them more than once, otherwise only the value of the last definition is kept. Additionally the default with all coefficients is 0, which can be especially useful typing shortcut.</p>
<p>See the <a href="t2_3.html#t2_3_3_4_3">tutorial</a> section for more examples of the simplified syntax.</p>
<pre>
POLYNOMIAL:
  polynomial {
    Order, [COEFFICIENTS...]
    [POLY_MODIFIERS...]
    }
COEFFICIENTS:
  xyz(&lt;x_power&gt;,&lt;y_power&gt;,&lt;z_power&gt;):&lt;value&gt;[,]
POLY_MODIFIERS:
  sturm | OBJECT_MODIFIER
</pre>
<p>Same as the torus above, but with the polynomial syntax:</p>
<pre>
// Torus having major radius sqrt(40), minor radius sqrt(12)
polynomial { 4,
  xyz(4,0,0):1,   
  xyz(2,2,0):2,  
  xyz(2,0,2):2,
  xyz(2,0,0):-104,  
  xyz(0,4,0):1,
  xyz(0,2,2):2,
  xyz(0,2,0):56,
  xyz(0,0,4):1,
  xyz(0,0,2):-104, 
  xyz(0,0,0):784
  sturm
  }
</pre>

<p>Poly, cubic and quartics are just like quadrics in that you do not have
to understand one to use one. The file <code>shapesq.inc</code> has
plenty of pre-defined quartics for you to play with.</p>
<p>
Polys use highly complex computations and will not always render perfectly.
If the surface is not smooth, has dropouts, or extra random pixels, try using
the optional keyword <code>sturm</code> in the definition. This will cause a
slower but more accurate calculation method to be used. Usually, but not
always, this will solve the problem. If sturm does not work, try rotating
or translating the shape by some small amount.</p>
<p>
There are really so many different polynomial shapes, we cannot even
begin to list or describe them all. We suggest you find a good reference
or text book if you want to investigate the subject further.</p>

</div>
<a name="r3_4_3_3"></a>
<div class="content-level-h4" contains="Quadric" id="r3_4_3_3">
<h4>3.4.3.3 Quadric</h4>
<p>The <code>quadric</code> object can produce shapes like paraboloids (dish
shapes) and hyperboloids (saddle or hourglass shapes). It can also produce
ellipsoids, spheres, cones, and cylinders but you should use the <code>
sphere</code>, <code>cone</code>, and <code>cylinder</code> objects built
into POV-Ray because they are faster than the quadric version.</p>
<p class="Note"><strong>Note:</strong> Do not confuse &quot;quaDRic&quot; with
&quot;quaRTic&quot;. A quadric is a 2nd order polynomial while a quartic
is 4th order.</p>
<p>
Quadrics render much
faster and are less error-prone but produce less complex objects. The syntax
is:</p>
<pre>
QUADRIC:
  quadric {
    &lt;A,B,C&gt;,&lt;D,E,F&gt;,&lt;G,H,I&gt;,J
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>Although the syntax actually will parse 3 vector expressions followed by a
float, we traditionally have written the syntax as above where <em><code>
A</code></em> through <em><code>J</code></em> are float expressions. These 10
float that define a surface of x, y, z points which satisfy the equation A x<sup>2</sup>
+ B y<sup>2</sup> + C z<sup>2</sup> + D xy + E xz + F yz + G x + H y + I z + J = 0</p>

<p>Different values of <em><code>A, B, C, ... J</code></em> will give
different shapes. If you take any three dimensional point and use its x, y
and z coordinates in the above equation the answer will be 0 if the point is
on the surface of the object. The answer will be negative if the point is
inside the object and positive if the point is outside the object. Here are
some examples:</p>

<table SUMMARY="Some quartic shapes" width="100%">
<tr>
<td width="30%">X<sup>2</sup> + Y<sup>2</sup> + Z<sup>2</sup> - 1 = 0</td>

<td width="70%">Sphere</td>
</tr>

<tr>
<td>X<sup>2</sup> + Y<sup>2</sup> - 1 = 0</td>

<td>Infinite cylinder along the Z axis</td>
</tr>

<tr>
<td>X<sup>2</sup> + Y<sup>2</sup> - Z<sup>2</sup> = 0</td>

<td>Infinite cone along the Z axis</td>
</tr>
</table>

<p>The easiest way to use these shapes is to include the standard file <code>
shapes.inc</code> into your program. It contains several pre-defined quadrics
and you can transform these pre-defined shapes (using translate, rotate and
scale) into the ones you want. For a complete list, see the file <code>
shapes.inc</code>.</p>


</div>

<a name="r3_4_4"></a>
<div class="content-level-h3" contains="Constructive Solid Geometry" id="r3_4_4">
<h3>3.4.4 Constructive Solid Geometry</h3>
<p>In addition to all of the primitive shapes POV-Ray supports, you can also
combine multiple simple shapes into complex shapes using <em> Constructive
Solid Geometry</em> (CSG). There are four basic types of CSG operations:
union, intersection, difference, and merge. CSG objects can be composed of
primitives or other CSG objects to create more, and more complex shapes.</p>

</div>
<a name="r3_4_4_1"></a>
<div class="content-level-h4" contains="Inside and Outside" id="r3_4_4_1">
<h4>3.4.4.1 Inside and Outside</h4>
<p>Most shape primitives, like spheres, boxes and blobs divide the world into
two regions. One region is inside the object and one is outside. Given any
point in space you can say it is either inside or outside any particular
primitive object. Well, it could be exactly on the surface but this case is
rather hard to determine due to numerical problems.</p>
<p>
Even planes have an inside and an outside. By definition, the surface normal
of the plane points towards the outside of the plane. You should note that
triangles cannot be used as solid objects in CSG
since they have no well defined inside and outside. Triangle-based shapes (<code>mesh</code> and <code>mesh2</code>) can only be used in CSG when they are closed objects and have an inside vector specified. </p>
<p class="Note"><strong>Note:</strong> Although the <code>triangle</code>, the <code>bicubic_patch</code> and some other shapes have no well defined inside and outside, they have a front- and backside which makes it possible to use a texture on the front side and an <code>interior_texture</code> on the back side.</p>
<p>
CSG uses the concepts of inside and outside to combine shapes together as
explained in the following sections.</p>
<p>
Imagine you have two objects that partially overlap like shown in the figure
below. Four different areas of points can be distinguished: points that are
neither in object <code>A</code> nor in object <code>B</code>, points that
are in object <code>A</code> but not in object <code>B</code>, points that
are not in object <code>A</code> but in object <code>B</code> and last not
least points that are in object <code>A</code> and object <code>B</code>.
</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/8/8f/RefImgObjoverl.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Two overlapping objects.</p>
  </td>
</tr>
</table>

<p>Keeping this in mind it will be quite easy to understand how the CSG
operations work.</p>
<p>
When using CSG it is often useful to invert an object so that it will be
inside-out. The appearance of the object is not changed, just the way that
POV-Ray perceives it. When the <code>inverse</code> keyword is used the <em>
inside</em> of the shape is flipped to become the <em> outside</em> and vice
versa.</p>
<p>
The inside/outside distinction is not important for a <code>union</code>, but is important for <code>intersection</code>, <code>difference</code>, and <code>merge</code>. Therefore any objects may be combined using <code>union</code> but only solid objects, i.e. objects that have a well-defined interior can be used in the other kinds of CSG. The objects described in
<a href="r3_4.html#r3_4_2">Finite Patch Primitives</a> have no well defined inside/outside. All
objects described in the sections <a href="r3_4.html#r3_4_1">Finite Solid Primitives</a> and
<a href="r3_4.html#r3_4_3">Infinite Solid Primitives</a>.</p>

</div>
<a name="r3_4_4_2"></a>
<div class="content-level-h4" contains="Union" id="r3_4_4_2">
<h4>3.4.4.2 Union</h4>
<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/0/0d/RefImgUnionobj.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The union of two objects.</p>
  </td>
</tr>
</table>

<p>The simplest kind of CSG is the <code>union</code>. The syntax is:</p>
<pre>
UNION:
  union {
    OBJECTS...
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>Unions are simply glue used to bind two or more shapes into a single
entity that can be manipulated as a single object. The image above shows the
union of <code>A</code> and <code>B</code>. The new object created by the
union operation can be scaled, translated and rotated as a single shape. The
entire union can share a single texture but each object contained in the
union may also have its own texture, which will override any texture
statements in the parent object.</p>
<p>
You should be aware that the surfaces inside the union will not be removed.
As you can see from the figure this may be a problem for transparent unions.
If you want those surfaces to be removed you will have to use the <code>
merge</code> operations explained in a later section.</p>
<p>
The following union will contain a box and a sphere.</p>
<pre>
union {
  box { &lt;-1.5, -1, -1&gt;, &lt;0.5, 1, 1&gt; }
  cylinder { &lt;0.5, 0, -1&gt;, &lt;0.5, 0, 1&gt;, 1 }
  }
</pre>

<p>Earlier versions of POV-Ray placed restrictions on unions so you often had
to combine objects with <code>composite</code> statements. Those earlier
restrictions have been lifted so <code>composite</code> is no longer needed.
It is still supported for backwards compatibility.</p>

</div>
<a name="r3_4_4_2_1"></a>
<div class="content-level-h5" contains="Split_Union" id="r3_4_4_2_1">
<h5>3.4.4.2.1 Split_Union</h5>
<p><code>split_union</code> is a boolean keyword that can be added to a union.
It has two states <code>on</code>/<code>off</code>, its default is <code>on</code>.</p>

<p><code>split_union</code> is used when <a href="r3_6.html#r3_6_3_2_2">photons</a> are shot 
at the CSG-object. The object is split up in its compound parts, photons are shot at 
each part separately. This is to prevent photons from being shot at 'empty spaces' in the object,
for example the holes in a grid. With compact objects, without 'empty spaces'
<code>split_union off</code> can improve photon 
gathering.</p>
<pre>
union {
  object {...}
  object {...}
  split_union off
  }
</pre>

</div>
<a name="r3_4_4_3"></a>
<div class="content-level-h4" contains="Intersection" id="r3_4_4_3">
<h4>3.4.4.3 Intersection</h4>
<p>The <code>intersection</code> object creates a shape containing only those
areas where all components overlap. A point is part of an intersection if it is
inside both objects, <code>A</code> and <code>B</code>, as show in the figure
below.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/7/75/RefImgIsectobj.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The intersection of two objects.</p>
  </td>
</tr>
</table>

<p>The syntax is:</p>
<pre>
INTERSECTION:
  intersection {
    SOLID_OBJECTS...
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>The component objects must have well defined inside/outside properties.
Patch objects are not allowed.</p>
<p class="Note"><strong>Note:</strong> If all components do not overlap, the intersection object disappears.</p>
<p>
Here is an example that overlaps:</p>
<pre>
intersection {
  box { &lt;-1.5, -1, -1&gt;, &lt;0.5, 1, 1&gt; }
  cylinder { &lt;0.5, 0, -1&gt;, &lt;0.5, 0, 1&gt;, 1 }
  }
</pre>

</div>
<a name="r3_4_4_4"></a>
<div class="content-level-h4" contains="Difference" id="r3_4_4_4">
<h4>3.4.4.4 Difference</h4>
<p>The CSG <code>difference</code> operation takes the intersection between
the first object and the inverse of all subsequent objects. Thus only points
inside object <code>A</code> and outside object <code>B</code> belong to the
difference of both objects.</p>
<p>
The result is a subtraction of the 2nd shape from the first shape as shown
in the figure below.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/3/3b/RefImgDiffobj.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The difference between two objects.</p>
  </td>
</tr>
</table>

<p>The syntax is:</p>
<pre>
DIFFERENCE:
  difference {
    SOLID_OBJECTS...
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>The component objects must have well defined inside/outside properties.
Patch objects are not allowed. </p>
<p class="Note"><strong>Note:</strong> If the first object is entirely inside the subtracted objects, the difference object disappears.</p>
<p>
Here is an example of a properly formed difference:</p>
<pre>
difference {
  box { &lt;-1.5, -1, -1&gt;, &lt;0.5, 1, 1&gt; }
  cylinder { &lt;0.5, 0, -1&gt;, &lt;0.5, 0, 1&gt;, 1 }
  }
</pre>

<p class="Note"><strong>Note:</strong> Internally, POV-Ray simply adds the <code>inverse</code> keyword
to the second (and subsequent) objects and then performs an intersection.</p>
<p> The
example above is equivalent to:</p>
<pre>
intersection {
  box { &lt;-1.5, -1, -1&gt;, &lt;0.5, 1, 1&gt; }
  cylinder { &lt;0.5, 0, -1&gt;, &lt;0.5, 0, 1&gt;, 1 inverse }
  }
</pre>

</div>
<a name="r3_4_4_5"></a>
<div class="content-level-h4" contains="Merge" id="r3_4_4_5">
<h4>3.4.4.5 Merge</h4>
<p>The <code>union</code> operation just glues objects together, it does not
remove the objects' surfaces inside the <code>union</code>. Under most
circumstances this does not matter. However if a transparent <code>
union</code> is used, those interior surfaces will be visible. The <code>
merge</code> operations can be used to avoid this problem. It works just like
<code>union</code> but it eliminates the inner surfaces like shown in the
figure below.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/2/25/RefImgMergeobj.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Merge removes inner surfaces.</p>
  </td>
</tr>
</table>

<p>The syntax is:</p>
<pre>
MERGE:
  merge {
    SOLID_OBJECTS...
    [OBJECT_MODIFIERS...]
    }
</pre>

<p>The component objects must have well defined inside/outside properties.
Patch objects are not allowed. </p>
<p class="Note"><strong>Note:</strong> In general <code>merge</code> is slower rendering than <code>union</code> when used with non transparent objects. A small test may be needed to determine what is the optimal solution regarding speed and visual result.</p>

</div>

<a name="r3_4_5"></a>
<div class="content-level-h3" contains="Light Sources" id="r3_4_5">
<h3>3.4.5 Light Sources</h3>
<p>The <code>light_source</code> is not really an object. Light sources have no visible shape of their own. They are just points or areas which emit light. They are categorized as objects so that they can be combined with regular objects using <code>union</code>.</p>
<p class="Note"><strong>Note:</strong> Due to a hard-coded limit the number of light sources should not exceed 127. Since the class of the variable that governs this limit is <em>not exclusive</em> to light sources, a value had to be chosen that provides the best balance between performance, memory use and flexibility. See the following <a href="http://news.povray.org/povray.beta-test/thread/web.4d18ce518224b54c231f2b0b0@news.povray.org/">news-group&nbsp;discussion</a> for more details and information about ways to overcome this limitation.</p>
 
<p>The syntax is as follows:</p>
<pre>
LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  LIGHT_TYPE | SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS |
  GENERAL_LIGHT_MODIFIERS
LIGHT_TYPE:
  spotlight | shadowless | cylinder | parallel
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
PARALLEL_ITEM:
  point_at &lt;Spot&gt;
AREA_LIGHT_ITEM:
  area_light &lt;Axis_1&gt;, &lt;Axis_2&gt;, Size_1, Size_2 |
  adaptive Adaptive | area_illumination [Bool] |
  jitter | circular | orient
GENERAL_LIGHT_MODIFIERS:
  looks_like { OBJECT } |
  TRANSFORMATION fade_distance Fade_Distance |
  fade_power Fade_Power | media_attenuation [Bool] |
  media_interaction [Bool] | projected_through
</pre>

<p>Light source default values:</p>
<pre>
LIGHT_TYPE        : pointlight
falloff           : 70
media_interaction : on
media_attenuation : off
point_at          : &lt;0,0,0&gt;
radius            : 70
tightness         : 10
</pre>

<p>The different types of light sources and the optional modifiers are
described in the following sections.</p>
<p>
The first two items are common to all light sources. The <em><code>&lt;Location&gt;</code></em>
vector gives the location of the light. The <em>COLOR</em> gives the color 
of the light. Only the red, green, and blue components are significant. Any 
transmit or filter values are ignored. </p>
<p class="Note"><strong>Note:</strong> You vary the intensity of the light as well as the color using this parameter. A color such as 
<code>rgb &lt;0.5,0.5,0.5&gt;</code> gives a white light that is half the normal intensity.</p>
<p> All of the keywords or items in the syntax 
specification above may appear in any order. Some keywords only have effect 
if specified with other keywords. The keywords are grouped into functional 
categories to make it clear which keywords work together. The 
<em>GENERAL_LIGHT_MODIFIERS</em> work with all types of lights and all 
options. </p>
<p class="Note"><strong>Note:</strong> <em>TRANSFORMATIONS</em> such as <code><a href="r3_8.html#r3_8_5">translate</a></code>,
<code><a href="r3_8.html#r3_8_5">rotate</a></code> etc. may be applied but no  other <em>OBJECT_MODIFIERS</em>
may be used.</p>
<p>
There are three mutually exclusive light types. If no <em>LIGHT_TYPE</em> is
specified it is a point light. The other choices are <code>spotlight</code>
and <code>cylinder</code>.</p>

</div>
<a name="r3_4_5_1"></a>
<div class="content-level-h4" contains="Point Lights" id="r3_4_5_1">
<h4>3.4.5.1 Point Lights</h4>
<p>The simplest kind of light is a point light. A point light source sends
light of the specified color uniformly in all directions. The default light
type is a point source. The <em><code>&lt;Location&gt;</code></em> and <em>
COLOR</em> is all that is required. For example:</p>
<pre>
light_source {
  &lt;1000,1000,-1000&gt;, rgb &lt;1,0.75,0&gt; //an orange light
  }
</pre>
</div>
<a name="r3_4_5_2"></a>
<div class="content-level-h4" contains="Spotlights" id="r3_4_5_2">
<h4>3.4.5.2 Spotlights</h4>
<p>Normally light radiates outward equally in all directions from the source.
However the <code>spotlight</code> keyword can be used to create a cone of
light that is bright in the center and falls of to darkness in a soft fringe
effect at the edge.</p>
<p>
Although the cone of light fades to soft edges, objects illuminated by
spotlights still cast hard shadows. The syntax is:</p>
<pre>
SPOTLIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR spotlight
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
</pre>
<p>
Default values:
</p>
<pre>
radius:    30 degrees
falloff:   45 degrees
tightness:  0
</pre>

<p>The <code>point_at</code> keyword tells the spotlight to point at a
particular 3D coordinate. A line from the location of the spotlight to the
<code>point_at</code> coordinate forms the center line of the cone of light.
The following illustration will be helpful in understanding how these values
relate to each other.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/4/45/RefImgSpotgeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a spotlight.</p>
  </td>
</tr>
</table>
<p>The <code>falloff</code>, <code>radius</code>, and <code>tightness</code>
keywords control the way that light tapers off at the edges of the cone.
These four keywords apply only when the <code>spotlight</code> or <code>
cylinder</code> keywords are used.</p>
<p>
The <code>falloff</code> keyword specifies the overall size of the cone of
light. This is the point where the light falls off to zero intensity. The
float value you specify is the angle, in degrees, between the edge of the
cone and center line. The <code>radius</code> keyword specifies the size of
the <em>hot-spot</em> at the center of the cone of light. The
<em>hot-spot</em> is a brighter cone of light inside the spotlight cone
and has the same center line. The <code>radius</code> value specifies the
angle, in degrees, between the edge of this bright, inner cone and the center
line. The light inside the inner cone is of uniform intensity. The light
between the inner and outer cones tapers off to zero.</p>
<p>
For example, assuming a <code>tightness 0</code>, with <code>radius 10</code> and <code>falloff 20</code> the light
from the center line out to 10 degrees is full intensity. From 10 to 20
degrees from the center line the light falls off to zero intensity. At 20
degrees or greater there is no light.</p>
<p class="Note"><strong>Note:</strong> If the radius and falloff
values are close or equal the light intensity drops rapidly and the spotlight
has a sharp edge.</p>
<p>
The values for the <code>radius</code>, and <code>tightness</code> parameters are half the opening angles of the
corresponding cones, both angles have to be smaller than 90 degrees. The
light smoothly falls off between the radius and the falloff angle like shown
in the figures below (as long as the radius angle is not negative).</p>

<table class="matte" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/0/0b/RefImgFixfallo.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a fixed falloff angle of 45 degrees.</p>
  </td>
</tr>
</table>
<p>&nbsp;</p>
<table class="matte" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/c/c8/RefImgFixedrad.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a fixed radius angle of 45 degrees.</p>
  </td>
</tr>
</table>

<p>The <code>tightness</code> keyword is used to specify an <em>
additional</em> exponential softening of the edges. A value other than 0, will
affect light within the radius cone as well as light in the falloff cone. 
The intensity of light at an angle from the center line is given by: 
<em><code>intensity * cos(angle)tightness</code></em>.
The default value for tightness is 0. Lower
tightness values will make the spotlight brighter, making the spot wider and
the edges sharper. Higher values will dim the spotlight, making the spot
tighter and the edges softer. Values from 0 to 100 are acceptable.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/1/14/RefImgDiftight.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with fixed angle and falloff angles of 30 and 60 degrees respectively and different tightness values.</p>
  </td>
</tr>
</table>

<p>You should note from the figures that the radius and falloff angles
interact with the tightness parameter. To give the tightness value full control
over the spotlight's appearance use radius 0 falloff 90. As you
can see from the figure below. In that case the falloff angle has no effect
and the lit area is only determined by the tightness parameter.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/e/e2/RefImgNegradli.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a negative radius angle and different tightness values.</p>
  </td>
</tr>
</table>

<p>Spotlights may be used any place that a normal light source is used. Like
any light sources, they are invisible. They may also be used in conjunction
with area lights.</p>

</div>
<a name="r3_4_5_3"></a>
<div class="content-level-h4" contains="Cylindrical Lights" id="r3_4_5_3">
<h4>3.4.5.3 Cylindrical Lights</h4>
<p>The <code>cylinder</code> keyword specifies a cylindrical light source
that is great for simulating laser beams. Cylindrical light sources work
pretty much like spotlights except that the light rays are constrained by a
cylinder and not a cone. The syntax is:</p>
<pre>
CYLINDER_LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR cylinder
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
</pre>
<p>
Default values:
</p>
<pre>
radius:     0.75 degrees
falloff:    1    degrees
tightness:  0
</pre>

<p>The <code>point_at</code>, <code>radius</code>, <code>falloff</code> and
<code>tightness</code> keywords control the same features as with the
spotlight. See <a href="r3_4.html#r3_4_5_2">Spotlights</a> for details.</p>

<p>You should keep in mind that the cylindrical light source is still a point
light source. The rays are emitted from one point and are only constraint by
a cylinder. The light rays are not parallel.</p>

</div>
<a name="r3_4_5_4"></a>
<div class="content-level-h4" contains="Parallel Lights" id="r3_4_5_4">
<h4>3.4.5.4 Parallel Lights</h4>
<pre>
syntax:

light_source {
  LOCATION_VECTOR, COLOR
  [LIGHT_SOURCE_ITEMS...]
  parallel
  point_at VECTOR
  }
</pre>

<p>The <code>parallel</code> keyword can be used with any type of light source.</p>
<p class="Note"><strong>Note:</strong> For normal point lights, <code>point_at</code> must come after
<code>parallel</code>.</p>

<p>Parallel lights are useful for simulating very distant light sources, such as
sunlight. As the name suggests, it makes the light rays parallel.</p>
<p>Technically this is done by shooting rays from the closest point on a plane to the
object intersection point. The plane is determined by a perpendicular defined by the
light <code>location</code> and the <code>point_at</code> vector.</p>

<p>Two things must be considered when choosing the light location
(specifically, its distance):</p><ol>
<li>Any parts of an object <em>above</em> the light plane still get illuminated according to
the light direction, but they will not cast or receive shadows.</li>
<li><code>fade_distance</code> and <code>fade_power</code> use the light
<code>location</code> to determine distance for light attenuation, so the attenuation
still looks like that of a point source.
<br>Area light also uses the light location in its calculations.</li></ol>

</div>
<a name="r3_4_5_5"></a>
<div class="content-level-h4" contains="Area Lights" id="r3_4_5_5">
<h4>3.4.5.5 Area Lights</h4>
<p>Area light sources occupy a finite, one or two-dimensional area of space. They can cast soft shadows because an object can partially block their light. Point sources are either totally blocked or not blocked.</p>
<p>The <code>area_light</code> keyword in POV-Ray creates sources that are rectangular in shape, sort of like a flat panel light. Rather than performing the complex calculations that would be required to model a true area light, it is approximated as an array of point light sources spread out over the area occupied by the light. The array-effect applies to shadows only, however with the addition of the <code>area_illumination</code> keyword,  full area light diffuse and specular illumination can be achieved. The object's illumination is still that of a point source. The intensity of each individual point light in the array is dimmed so that the total amount of light emitted by the light is equal to the light color specified in the declaration. The syntax is:</p>
<pre>
AREA_LIGHT_SOURCE:
  light_source {
    LOCATION_VECTOR, COLOR
    area_light
    AXIS_1_VECTOR, AXIS_2_VECTOR, Size_1, Size_2
    [ adaptive Adaptive ] [ area_illumination on/off ]
    [ jitter ] [ circular ] [ orient ]
    [ [LIGHT_MODIFIERS...]
    }
</pre>

<p>Any type of light source may be an area light. </p>

<p>The <code>area_light</code> keyword defines the location, the size and orientation of the area light as well as the number of lights in the light source array. The location vector is the centre of a rectangle defined by the two vectors <em><code>&lt;Axis_1&gt;</code></em> and <em><code>&lt;Axis_2&gt;</code></em>. These specify the lengths and directions of the edges of the light.</p>

<table class="centered" width="340x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="320px" src="images/a/a8/RefImgAreal.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">4x4 Area light, location and vectors.</p>
  </td>
</tr>
</table>

<p>Since the area lights are rectangular in shape these vectors should be perpendicular to each other. The larger the size of the light the thicker the soft part of shadows will be. The integers Size_1 and Size_2 specify the number of rows and columns of point sources of the. The more lights you use the smoother your shadows will be but the longer they will take to render.</p>

<p class="Note"><strong>Note:</strong> It is possible to specify spotlight parameters along with the area light parameters to create area spotlights. Using area spotlights is a good way to speed up scenes that use area lights since you can confine the lengthy soft shadow calculations to only the parts of your scene that need them.</p>
<p>An interesting effect can be created using a linear light source. Rather than having a rectangular shape, a linear light stretches along a line sort of like a thin fluorescent tube. To create a linear light just create an area light with one of the array dimensions set to 1.</p>

<p class="Note"><strong>Note:</strong> In version 3.7 experimental support for full area light diffuse and specular illumination was added. </p>
<p>This feature is off by default, so area lights will work as previously expected, and can be turned on by specifying the <code>area_illumination</code> keyword, followed by the optional on/off keyword, in the light source definition. As with area lights, the Size_1 and Size_2 parameters determine the quality of the lighting, as well as the quality of the shadows.</p>

<p>The <code>jitter</code> keyword is optional. When used it causes the positions of the point lights in the array to be randomly jittered to eliminate any shadow banding that may occur. The jittering is completely random from render to render and should not be used when generating animations.</p>

<p>The <code>adaptive</code> keyword is used to enable adaptive sampling of the light source. By default POV-Ray calculates the amount of light that reaches a surface from an area light by shooting a test ray at every point light within the array. As you can imagine this is very slow. Adaptive sampling on the other hand attempts to approximate the same calculation by using a minimum number of test rays. The number specified after the keyword controls how much adaptive sampling is used. The higher the number the more accurate your shadows will be but the longer they will take to render. If you are not sure what value to use a good starting point is <code>adaptive 1</code>. The <code>adaptive</code> keyword only accepts integer values and cannot be set lower than 0.</p>

<p>When performing adaptive sampling POV-Ray starts by shooting a test ray at each of the four corners of the area light. If the amount of light received from all four corners is approximately the same then the area light is assumed to be either fully in view or fully blocked. The light intensity is then calculated as the average intensity of the light received from the four corners. However, if the light intensity from the four corners differs significantly then the area light is partially blocked. The area light is split into four quarters and each section is sampled as described above. This allows POV-Ray to rapidly approximate how much of the area light is in view
without having to shoot a test ray at every light in the array. Visually the sampling goes like shown below.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/1/18/RefImgArealigh.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light adaptive samples.</p>
  </td>
</tr>
</table>

<p>While the adaptive sampling method is fast (relatively speaking) it can sometimes produce inaccurate shadows. The solution is to reduce the amount of adaptive sampling without completely turning it off. The number after the adaptive keyword adjusts the number of times that the area light will be split before the adaptive phase begins. For example if you use <code>adaptive 0</code> a minimum of 4 rays will be shot at the light. If you use <code>adaptive 1</code> a minimum of 9 rays will be shot (<code>adaptive
2</code> gives 25 rays, <code>adaptive 3</code> gives 81 rays, etc). Obviously the more shadow rays you shoot the slower the rendering will be so you should use the lowest value that gives acceptable results.</p>
<p>The number of rays never exceeds the values you specify for rows and columns of points. For example <code>area_light x,y,4,4</code> specifies a 4 by 4 array of lights. If you specify <code>adaptive 3</code> it would mean that you should start with a 9 by 9 array. In this case no adaptive sampling is done. The 4 by 4 array is used.</p>

<p>The <code>circular</code> keyword has been added to area lights in order to better create circular soft shadows. With ordinary area lights the pseudo-lights are arranged in a rectangular grid and thus project partly rectangular shadows around all objects, including circular objects. By including the <code>circular</code> tag in an area light, the light is stretched and squashed so that it looks like a circle: this way, circular or spherical light sources are better simulated.</p>
<p>A few things to remember:</p>
<ul>
<li>Circular area lights can be ellipses: the AXIS_1_VECTOR and AXIS_2_VECTOR
define the shape and orientation of the circle; if the vectors are not equal, the light
source is elliptical in shape.</li>
<li>Rectangular artefacts may still show up with very large area grids.</li>
<li>There is no point in using <code>circular</code> with linear area lights or area lights which have a  2x2 size.</li>
<li>The area of a circular light is roughly 78.5 per cent of a similar size rectangular area light.  Increase your axis vectors accordingly if you wish to keep the light source area constant.</li>
</ul>

<p>The <code>orient</code> keyword has been added to area lights in order to better create soft shadows. Without this modifier, you have to take care when choosing the axis vectors of an area_light, since they define both its area and orientation. Area lights are two dimensional: shadows facing the area light receive light from a larger surface area than shadows at the sides of the area light.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/6/63/RefImgArea2.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light facing object.</p>
  </td>
</tr>
</table>

<p>Actually, the area from which light is emitted at the sides of the area light is reduced to a single line, only casting soft shadows in one direction.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/6/65/RefImgArea1.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light not facing object.</p>
  </td>
</tr>
</table>

<p>Between these two extremes the surface area emitting light progresses gradually. By including the <code>orient</code> modifier in an area light, the light is rotated so that for every shadow test, it always faces the point being tested. The initial orientation is no longer important, so you only have to consider the desired dimensions (area) of the light source when specifying the axis vectors. In effect, this makes the area light source appear 3-dimensional (e.g. an area_light with perpendicular axis vectors of the same size and dimensions using <code>circular</code> <em>and</em> <code>orient</code> simulates a spherical light source).</p>

<p>Orient has a few restrictions:</p>

<ol>
<li>It can be used with <em>circular</em> lights only.</li>
<li>The two axes of the area light must be of equal length.</li>
<li>The two axes of the area light should use an equal number of samples, and that number should be greater than one</li>
</ol>
<p>These three rules exist because without them, you can get unpredictable results from the orient feature.</p>

<p>If one of the first two rules is broken, POV-Ray will issue a warning and correct the problem. If the third rule is broken, you will only get the error message, and POV-Ray will not automatically correct the problem.</p>

</div>
<a name="r3_4_5_6"></a>
<div class="content-level-h4" contains="Shadowless Lights" id="r3_4_5_6">
<h4>3.4.5.6 Shadowless Lights</h4>
<p>Using the <code>shadowless</code> keyword you can stop a light source from
casting shadows. These lights are sometimes called <em>fill lights</em>.
They are another way to simulate ambient light however shadowless lights have
a definite source. The syntax is:</p>
<pre>
SHADOWLESS_LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR shadowless
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
</pre>

<p><code>shadowless</code> may be used with all types of light sources.
The only restriction is that <code>shadowless</code> should be before or
after <em>all</em> spotlight or cylinder option keywords. Do not mix or you get
the message <em>Keyword 'the one following shadowless' cannot be used with
standard light source</em>. Also note that shadowless lights will not cause
highlights on the illuminated objects.</p>

</div>
<a name="r3_4_5_7"></a>
<div class="content-level-h4" contains="Looks_like" id="r3_4_5_7">
<h4>3.4.5.7 Looks_like</h4>
<p>Normally the light source itself has no visible shape. The light simply
radiates from an invisible point or area. You may give a light source any
shape by adding a <code>looks_like {</code><em> OBJECT</em> <code>}</code>
statement.</p>

<p>There is an implied <code>no_shadow</code> attached to the <code>
looks_like</code> object so that light is not blocked by the object. Without
the automatic <code>no_shadow</code> the light inside the object would not
escape. The object would, in effect, cast a shadow over everything.</p>

<p>If you want the attached object to block light then you should attach it
with a <code>union</code> and not a <code>looks_like</code> as follows:</p>
<pre>
union {
  light_source { &lt;100, 200, -300&gt; color White }
  object { My_Lamp_Shape }
  }
</pre>

<p>Presumably parts of the lamp shade are transparent to let some light out.</p>

</div>
<a name="r3_4_5_8"></a>
<div class="content-level-h4" contains="Projected_Through" id="r3_4_5_8">
<h4>3.4.5.8 Projected_Through</h4>
<p>Syntax:</p>
<pre>
light_source {
  LOCATION_VECTOR, COLOR
  [LIGHT_SOURCE_ITEMS...]
  projected_through { OBJECT }
  }
</pre>

<p>Projected_through can be used with any type of light source. Any object can be
used, provided it has been declared before.
<br>Projecting a light through an object can be thought of as the opposite of
shadowing: only the light rays that hit the projected_through object
will contribute to the scene.
<br>This also works with area_lights, producing spots of light with soft edges.
<br>Any objects between the light and the projected through object will not cast
shadows for this light. Also any surface within the projected through object
will not cast shadows.
<br>Any textures or interiors on the object will be stripped and the object will not
show up in the scene.</p>

</div>
<a name="r3_4_5_9"></a>
<div class="content-level-h4" contains="Light Fading" id="r3_4_5_9">
<h4>3.4.5.9 Light Fading</h4>
<p>By default POV-Ray does not diminish light from any light source as it
travels through space. In order to get a more realistic effect <code>
fade_distance</code> and <code>fade_power</code> keywords followed by float
values can be used to model the distance based falloff in light
intensity.</p>

<p>The <code>fade_distance</code> is used to specify the distance at which the full light intensity arrives, i.e.: the intensity which was given by the <code>color</code> attribute. The actual attenuation is described by the <code>fade_power</code> keyword, which determines the falloff rate. For example linear or quadratic falloff can be used by setting the <code>fade_power</code> to 1 or 2 respectively.</p>

<p>The complete formula to calculate the factor by which the light is attenuated is:</p>

<table class="centered" width="415px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <!--<img src="ref_tex/lattenua.tex" alt="">---><img class="center" width="395px" src="images/6/69/RefImgLattenua.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The attenuation of light fading formula</p>
  </td>
</tr>
</table>

<p>Where <em><code>d</code></em> is the distance the light has traveled.</p>

<table class="centered" width="660px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/4/4d/RefImgLfadefx.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Light fading functions for different fading powers</p>
  </td>
</tr>
</table>

<p>With any given value for <code>fade_distance</code>, either larger <em>OR</em> smaller than one, the light intensity at distances smaller than that given value actually increases. The internal calculation used to determine the <em>attenuation</em> factor is set up in a way so that one could set the fade distance and know that for any given fade distance, the light value would equal the set intensity. Lastly, only light coming directly from light sources is attenuated, and that reflected or refracted light is not attenuated by distance.</p>

<p>However, further investigation does reveal certain short comings with this method, as it doesn't follow a very good inverse-squared relationship over the fade distance and somewhat beyond.  In other words, the function does break down to be very close to inverse squared as the distance from the given value for <code>fade_distance</code> gets significantly larger.</p>

<p>To that end consider the following:</p>

<p>A value for the light source intensity can be easily calculated when you take into account the distance from the light source to the scene center, or the object to be illuminated, and you set a relatively small value for <code>fade_distance</code> e.g.: the size of the light itself, relative to the scene dimensions.</p>

<p>The following example, that takes the inverse of the above formula that was used to calculate the factor by which the light is attenuated.</p>

<pre>
// setup the function
#declare Intensity_Factor = function (LD,FD,FP) {pow(1+(LD/FD),FP)/2};

// the translated position of the light source
#declare Light_Position = &lt;0,0,-2400&gt;;

// determine the light distance
#declare Light_Distance = vlength(Light_Position-&lt;0,0,0&gt;);

// scaled size of the light source
#declare Fade_Distance = 4.5;

// linear (1) or quadratic (2) falloff 
#declare Fade_Power = 2;
</pre>

<p class="Note"><strong>Note:</strong> The above example calculates <em>Light_Distance</em> to the scene center, but you could have just as easily used the location of an object.</p>

<p>Now all you have to do is setup the light source. The <code>#debug</code> statements make it easy to see whats going on while tuning the light source.</p>

<pre>
#debug concat ("\nFade Distance: ", str(Fade_Distance,2,4))
#debug concat ("\nLight Distance: ", str(Light_Distance,5,4)," \n")
#debug concat ("Intensity Factor: ", str(Intensity_Factor (Light_Distance, Fade_Distance, Fade_Power),6,4)
#debug concat ("\n\n")

light_source {
  0, rgb &lt;0.9,0.9,1&gt; * Intensity_Factor (Light_Distance, Fade_Distance, Fade_Power)
  fade_distance Fade_Distance
  fade_power Fade_Power
  translate Light_Position
  }
</pre>

<p>At first glance this may seem counter-intuitive but it works out well given the small value used for <em>Fade_Distance</em>. You should be aware that this method is meant to give a light strength value of <em>ONE</em> at the point of interest <em>ONLY</em>. In other words, the point represented by the calculated value <em>Light_Distance</em> in the above example. Naturally objects closer to the light source will get a stronger illumination, while objects further away will receive less.</p>

</div>
<a name="r3_4_5_10"></a>
<div class="content-level-h4" contains="Atmospheric Media Interaction" id="r3_4_5_10">
<h4>3.4.5.10 Atmospheric Media Interaction</h4>
<p>By default light sources will interact with an atmosphere added to the
scene. This behavior can be switched off by using <code>media_interaction off</code>
inside the light source statement. </p>
<p class="Note"><strong>Note:</strong> In POV-Ray 3.0 this feature was turned off
and on with the <code>atmosphere</code> keyword.</p>

</div>
<a name="r3_4_5_11"></a>
<div class="content-level-h4" contains="Atmospheric Attenuation" id="r3_4_5_11">
<h4>3.4.5.11 Atmospheric Attenuation</h4>
<p>Normally light coming from light sources is not influenced by fog or
atmospheric media. This can be changed by turning the <code>media_attenuation on</code>
for a given light source on. All light coming from this light source will now
be diminished as it travels through the fog or media. This results in an
distance-based, exponential intensity falloff ruled by the used fog or media.
If there is no fog or media no change will be seen.</p>
<p class="Note"><strong>Note:</strong> In POV-Ray 3.0 this
feature was turned off and on with the <code>atmospheric_attenuation</code> keyword.</p>

</div>
<a name="r3_4_6"></a>
<div class="content-level-h3" contains="Light Groups" id="r3_4_6">
<h3>3.4.6 Light Groups</h3>
<p>Light groups make it possible to create a <code>union</code> of light sources and objects, where the objects in the group are illuminated by the lights in the group or, if so desired, by the global light sources as well. The light sources in the group can <em>only</em> illuminate the objects that are in the group, this also applies to <code>scattering</code> media, and it <em>must</em> be included in the light group as well. Keep in mind that if the scattering media also has an <code>absorption</code> component, it <em>will</em> be affected by light sources that are <em>not</em> in the light group definition.</p>

<p>Light groups are for example useful when creating scenes in which some objects turn out to be too dark but the average light is exactly how it should be, as the light sources in the group do not contribute to the global lighting.</p>

<p>Syntax :</p>
<pre>
light_group {
  LIGHT_GROUP LIGHT  |
  LIGHT_GROUP OBJECT |
  LIGHT_GROUP
  [LIGHT_GROUP MODIFIER]
  }

LIGHT_GROUP LIGHT:
  light_source | light_source IDENTIFIER
LIGHT_GROUP OBJECT: 
  OBJECT | OBJECT IDENTIFIER
LIGHT_GROUP MODIFIER: 
  global_lights BOOL | TRANSFORMATION
</pre>

<ul>
  <li>To illuminate objects in the group with the light from global light sources, add <code>global_lights on</code> to the light group definition.</li>
  <li>Light groups may be nested. In this case light groups inherit the light sources of the light group in which they are contained.</li>
  <li>Light groups can be seen as a <code>union</code> of an object with a <code>light_source</code> and can be used with CSG.</li>
</ul>

<p>Some examples of a simple light group:</p>

<pre>
#declare RedLight = 
light_source {
  &lt;-500,500,-500&gt;
  rgb &lt;1,0,0&gt;
  }

light_group {
  light_source {RedLight}
  sphere {0,1 pigment {rgb 1}}
  global_lights off
  }
</pre>

<p>A nested light group:</p>

<pre>
#declare L1 = 
light_group {
  light_source {&lt;10,10,0&gt;, rgb &lt;1,0,0&gt;}
  light_source {&lt;0,0,-100&gt;, rgb &lt;0,0,1&gt;}
  sphere {0,1 pigment {rgb 1}}
  }

light_group {
  light_source {&lt;0,100,0&gt;, rgb 0.5}
  light_group {L1}
  }
</pre>

<p>Light groups with CSG:</p>
<pre>
difference {
  light_group {
    sphere {0,1 pigment {rgb 1}}
    light_source {&lt;-100,0,-100&gt; rgb &lt;1,0,0&gt;}
    global_lights off
    }
  light_group {
    sphere {&lt;0,1,0&gt;,1 pigment {rgb 1}}
    light_source {&lt;100,100,0&gt; rgb &lt;0,0,1&gt;}
    global_lights off
    }
  rotate &lt;-45,0,0&gt;
  }
</pre>
<p>In the last example the result will be a sphere illuminated red, where the part that is differenced away is illuminated blue. The end result is comparable to the difference between two spheres with a different pigment.</p>

</div>

<a name="r3_4_7"></a>
<div class="content-level-h3" contains="Object Modifiers" id="r3_4_7">
<h3>3.4.7 Object Modifiers</h3>
<p>A variety of modifiers may be attached to objects. The following items may
be applied to any object:</p>
<pre>
OBJECT_MODIFIER:
  clipped_by { UNTEXTURED_SOLID_OBJECT... } |
  clipped_by { bounded_by }                 |
  bounded_by { UNTEXTURED_SOLID_OBJECT... } |
  bounded_by { clipped_by }                 |
  no_shadow                  |
  no_image [ Bool ]          |
  no_radiosity [ Bool ]     |
  no_reflection [ Bool ]     |
  inverse                    |
  sturm [ Bool ]             |
  hierarchy [ Bool ]         |
  double_illuminate [ Bool ] |
  hollow  [ Bool ]           |
  interior { INTERIOR_ITEMS... }                        |
  material { [MATERIAL_IDENTIFIER][MATERIAL_ITEMS...] } |
  texture { TEXTURE_BODY }   |
  interior_texture { TEXTURE_BODY } |
  pigment { PIGMENT_BODY }   |
  normal { NORMAL_BODY }     |
  finish { FINISH_ITEMS... } |
  photons { PHOTON_ITEMS...}
  radiosity { RADIOSITY_ITEMS...}
  TRANSFORMATION
</pre>

<p>Transformations such as translate, rotate and scale have already been
discussed. The modifiers <em>Textures</em> and its parts
<em>Pigment</em>, <em>Normal</em>, and <em>Finish</em> as well as
<em>Interior</em>, and <em>Media</em> (which is part of interior) are
each in major chapters of their own below. In the sub-sections below we cover
several other important modifiers: <code>clipped_by</code>,
<code>bounded_by</code>, <code>material</code>, <code>inverse</code>, 
<code>hollow</code>, <code>no_shadow</code>, <code>no_image</code>,
<code>no_reflection</code>, <code>double_illuminate</code> and
<code>sturm</code>. Although the examples below use object statements and
object identifiers, these modifiers may be used on any type of object such as
sphere, box etc.</p>

</div>
<a name="r3_4_7_1"></a>
<div class="content-level-h4" contains="Bounded_By" id="r3_4_7_1">
<h4>3.4.7.1 Bounded_By</h4>
<p>The calculations necessary to test if a ray hits an object can be quite
time consuming. Each ray has to be tested against every object in the scene.
POV-Ray attempts to speed up the process by building a set of invisible
boxes, called bounding boxes, which cluster the objects together. This way a
ray that travels in one part of the scene does not have to be tested
against objects in another, far away part of the scene. When a large number
of objects are present the boxes are nested inside each other. POV-Ray can
use bounding boxes on any finite object and even some clipped or bounded
quadrics. However infinite objects (such as a planes, quartic, cubic and
poly) cannot be automatically bound. CSG objects are automatically bound if
they contain finite (and in some cases even infinite) objects. This works by
applying the CSG set operations to the bounding boxes of all objects used
inside the CSG object. For difference and intersection operations this will
hardly ever lead to an optimal bounding box. It is sometimes better
(depending on the complexity of the CSG object) to have you place a bounding
shape yourself using a <code>bounded_by</code> statement.</p>
<p>
Normally bounding shapes are not necessary but there are cases where they
can be used to speed up the rendering of complex objects. Bounding shapes
tell the ray-tracer that the object is totally enclosed by a simple shape.
When tracing rays, the ray is first tested against the simple bounding shape.
If it strikes the bounding shape the ray is further tested against the more
complicated object inside. Otherwise the entire complex shape is skipped,
which greatly speeds rendering. The syntax is:</p>
<pre>
BOUNDED_BY:
  bounded_by { UNTEXTURED_SOLID_OBJECT... } |
  bounded_by { clipped_by }
</pre>

<p>Where <em>UNTEXTURED_SOLID_OBJECT</em> is one or more solid objects which
have had no texture applied. For example:</p>
<pre>
intersection {
  sphere { &lt;0,0,0&gt;, 2 }
  plane  { &lt;0,1,0&gt;, 0 }
  plane  { &lt;1,0,0&gt;, 0 }
  bounded_by { sphere { &lt;0,0,0&gt;, 2 } }
  }
</pre>

<p>The best bounding shape is a sphere or a box since these shapes are highly
optimized, although, any shape may be used. If the bounding shape is itself a
finite shape which responds to bounding slabs then the object which it
encloses will also be used in the slab system.</p>
<p>
While it may a good idea to manually add a <code>bounded_by</code> to
intersection, difference and merge, it is best to <em>never</em> bound a
union. If a union has no <code>bounded_by</code> POV-Ray can internally
split apart the components of a union and apply automatic bounding slabs to
any of its finite parts. Note that some utilities such as <code>
raw2pov</code> may be able to generate bounds more efficiently than
POV-Ray's current system. However most unions you create yourself can be
easily bounded by the automatic system. For technical reasons POV-Ray cannot
split a merge object. It is maybe best to hand bound a merge, especially if
it is very complex.</p>
<p class="Note"><strong>Note:</strong> If bounding shape is too small or positioned incorrectly it may
clip the object in undefined ways or the object may not appear at all. To do
true clipping, use <code>clipped_by</code> as explained in the previous
section. Occasionally you will want to use the <code>clipped_by</code> and
<code>bounded_by</code> options with the same object. The following shortcut
saves typing and uses less memory.</p>
<pre>
object {
  My_Thing
  clipped_by{ box { &lt;0,0,0&gt;,&lt;1,1,1 &gt; }}
  bounded_by{ clipped_by }
  }
</pre>

<p>This tells POV-Ray to use the same box as a bound that was used as a
clip.</p>

</div>
<a name="r3_4_7_2"></a>
<div class="content-level-h4" contains="Clipped_By" id="r3_4_7_2">
<h4>3.4.7.2 Clipped_By</h4>
<p>The <code>clipped_by</code> statement is technically an object modifier
but it provides a type of CSG similar to CSG intersection. The syntax is:</p>
<pre>
CLIPPED_BY:
  clipped_by { UNTEXTURED_SOLID_OBJECT... } |
  clipped_by { bounded_by }
</pre>

<p>Where <em>UNTEXTURED_SOLID_OBJECT</em> is one or more solid objects which
have had no texture applied. For example:</p>
<pre>
object {
  My_Thing
  clipped_by{plane{y,0}}
  }
</pre>

<p>Every part of the object <code>My_Thing</code> that is inside the plane is
retained while the remaining part is clipped off and discarded. In an <code>
intersection</code> object the hole is closed off. With <code>
clipped_by</code> it leaves an opening. For example the following figure
shows object <code>A</code> being clipped by object <code>B</code>.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/c/c6/RefImgClipobj.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">An object clipped by another object.</p>
  </td>
</tr>
</table>

<p>You may use <code>clipped_by</code> to slice off portions of any shape. In
many cases it will also result in faster rendering times than other methods
of altering a shape. Occasionally you will want to use the <code>
clipped_by</code> and <code>bounded_by</code> options with the same object.
The following shortcut saves typing and uses less memory.</p>
<pre>
object {
  My_Thing
  bounded_by { box { &lt;0,0,0&gt;, &lt;1,1,1&gt; } }
  clipped_by { bounded_by }
  }
</pre>

<p>This tells POV-Ray to use the same box as a clip that was used as a
bound.</p>

</div>
<a name="r3_4_7_3"></a>
<div class="content-level-h4" contains="Double_Illuminate" id="r3_4_7_3">
<h4>3.4.7.3 Double_Illuminate</h4>
<p>Syntax:</p>
<pre>
OBJECT {
  [OBJECT_ITEMS...]
  double_illuminate
  }
</pre>

<p>A surface has two sides; usually, only the side facing the light source is illuminated,
the other side remains in shadow. When <code>double_illuminate</code> is used,
the other side is also illuminated.
<br>This is useful for simulating effects like translucency (as in a lamp shade, sheet of paper, etc).</p>

<p class="Note"><strong>Note:</strong> Using <code>double_illuminate</code> only illuminates both sides of the same
surface, so on a sphere, for example, you will not see the effect unless the
sphere is either partially transparent, or if the camera is inside and the light source
outside of the sphere (or vise versa).</p>

</div>
<a name="r3_4_7_4"></a>
<div class="content-level-h4" contains="Hollow" id="r3_4_7_4">
<h4>3.4.7.4 Hollow</h4>
<p>POV-Ray by default assumes that objects are made of a solid material that
completely fills the interior of an object. By adding the <code>
hollow</code> keyword to the object you can make it hollow, also see the 
<a href="r3_6.html#r3_6_1_2">Empty and Solid Objects</a> chapter. That is very
useful if you want atmospheric effects to exist inside an object. It is even
required for objects containing an interior media. The keyword may optionally
be followed by a float expression which is interpreted as a boolean value.
For example <code>hollow off</code> may be used to force it off. When the
keyword is specified alone, it is the same as <code>hollow on</code>. 
By default <code>hollow</code> is <code>off</code> when not specified.</p>
<p>
In order to get a hollow CSG object you just have to make the top level
object hollow. All children will assume the same <code>hollow</code> state
except when their state is explicitly set. The following example will set both
spheres inside the union hollow</p>
<pre>
union {
  sphere { -0.5*x, 1 }
  sphere {  0.5*x, 1 }
  hollow
  }
</pre>

<p>while the next example will only set the second sphere hollow because the
first sphere was explicitly set to be not hollow.</p>
<pre>
union {
  sphere { -0.5*x, 1 hollow off }
  sphere {  0.5*x, 1 }
  hollow on
  }
</pre>

</div>
<a name="r3_4_7_5"></a>
<div class="content-level-h4" contains="Inverse" id="r3_4_7_5">
<h4>3.4.7.5 Inverse</h4>
<p>When using <a href="r3_4.html#r3_4_4">CSG</a> it is often useful to invert an object so that it will be
inside-out. The appearance of the object is not changed, just the way that
POV-Ray perceives it. When the <code>inverse</code> keyword is used the <em>
inside</em> of the shape is flipped to become the <em>outside</em> and vice
versa. For example:</p>
<pre>
object { MyObject inverse }
</pre>

<p>The inside/outside distinction is also important when attaching
<code><a href="r3_6.html#r3_6_1">interior</a></code> to an object especially if
<code><a href="r3_3.html#r3_3_2_1">media</a></code> is also used. Atmospheric media 
and fog also do not work as expected if your camera is inside an object. 
Using <code>inverse</code> is useful to correct that problem.</p>

</div>
<a name="r3_4_7_6"></a>
<div class="content-level-h4" contains="Material" id="r3_4_7_6">
<h4>3.4.7.6 Material</h4>
<p>One of the changes in POV-Ray 3.1 was the removal of several items from <code>
texture { finish{</code>...<code>} }</code> and to move them to the new <code>
interior</code> statement. The <code><a href="r3_5.html#r3_5_4">halo</a></code> statement, formerly part of
<code><a href="r3_5.html#r3_5">texture</a></code>, is now renamed <code><a href="r3_6.html#r3_6_2">media</a></code> and made a part of
the <code><a href="r3_6.html#r3_6_1">interior</a></code>.</p>
<p>
This split was deliberate and purposeful (see
<a href="r3_6.html#r3_6_1_1">Why are Interior and Media Necessary?</a>)
however beta testers pointed out that it made it difficult to 
entirely describe the surface properties and interior of an object in one 
statement that can be referenced by a single identifier in a texture 
library.</p>
<p>
The result is that we created a <em>wrapper</em> around <code>texture</code> and <code>interior</code> which we call <code>material</code>.</p>
<p>
The syntax is:</p>
<pre>
MATERIAL:
  material { [MATERIAL_IDENTIFIER][MATERIAL_ITEMS...] }
MATERIAL_ITEMS:
  TEXTURE | INTERIOR_TEXTURE | INTERIOR | TRANSFORMATIONS
</pre>

<p>For example:</p>
<pre>
#declare MyGlass=material{ texture{ Glass_T } interior{ Glass_I }}
object { MyObject material{ MyGlass}}
</pre>

<p>Internally, the <em>material</em> is not attached to the object. The
material is just a container that brings the texture and interior to the
object. It is the texture and interior itself that is attached to the object.
Users should still consider texture and interior as separate items attached
to the object.</p>
<p>
The material is just a <em>bucket</em> to carry them. If the object
already has a texture, then the material texture is layered over it. If the object
already has an interior, the material interior fully replaces it and the old
interior is destroyed. Transformations inside the material affect only the
textures and interiors which are inside the <code>material{}</code> wrapper
and only those textures or interiors specified are affected. For example:</p>
<pre>
object {
  MyObject
    material {
      texture { MyTexture }
      scale 4         //affects texture but not object or interior
      interior { MyInterior }
      translate 5*x   //affects texture and interior, not object
      }
  }
</pre>

<p class="Note"><strong>Note:</strong> The <code>material</code> statement has nothing to do with the
<code><a href="r3_5.html#r3_5_5_3">material_map</a></code> statement. A <code>material_map</code> is <em>
not</em> a way to create patterned material. See <a href="r3_5.html#r3_5_5_3">Material Maps</a>
for explanation of this unrelated, yet similarly named, older feature.</p>

</div>
<a name="r3_4_7_7"></a>
<div class="content-level-h4" contains="No_Image, No_Reflection" id="r3_4_7_7">
<h4>3.4.7.7 No_Image, No_Reflection</h4>
<p>Syntax:</p>
<pre>
OBJECT {
  [OBJECT_ITEMS...]
  no_image
  no_reflection
  }
</pre>
<p>These two keywords are very similar in usage and function to the
<code>no_shadow</code> keyword, and control an object's visibility.
<br>You can use any combination of the three with your object.</p>
<p>When <code>no_image</code> is used, the object will not be seen by
the camera, either directly or through transparent/refractive objects. However,
it will still cast shadows, and show up in reflections (unless <code>no_reflection
</code> and/or <code>no_shadow</code> is used also).</p>

<p>When <code>no_reflection</code> is used, the object will not show up in
reflections. It will be seen by the camera (and through transparent/refractive objects)
and cast shadows, unless <code>no_image</code> and/or <code>no_shadow
</code> is used.</p>

<p>Using these three keywords you can produce interesting effects like a sphere
casting a rectangular shadow, a cube that shows up as a cone in mirrors,
etc.</p>

</div>
<a name="r3_4_7_8"></a>
<div class="content-level-h4" contains="No Radiosity" id="r3_4_7_8">
<h4>3.4.7.8 No Radiosity</h4>
<p>Specifying <code>no_radiosity</code> in an object block makes that object invisible to radiosity rays, in the same way as <code>no_image</code>, <code>no_reflection</code> and <code>no_shadow</code> make an object invisible to primary, reflected and shadow test rays, respectively.</p>

</div>
<a name="r3_4_7_9"></a>
<div class="content-level-h4" contains="No_Shadow" id="r3_4_7_9">
<h4>3.4.7.9 No_Shadow</h4>
<p>You may specify the <code>no_shadow</code> keyword in an object to make
that object cast no shadow. This is useful for special effects and for
creating the illusion that a light source actually is visible. This keyword
was necessary in earlier versions of POV-Ray which did not have the <code>
looks_like</code> statement. Now it is useful for creating things like laser
beams or other unreal effects. During test rendering it speeds things up if
<code>no_shadow</code> is applied.</p>
<p>
Simply attach the keyword as follows:</p>
<pre>
object {
  My_Thing
  no_shadow
  }
</pre>

</div>
<a name="r3_4_7_10"></a>
<div class="content-level-h4" contains="Sturm" id="r3_4_7_10">
<h4>3.4.7.10 Sturm</h4>
<p>Some of POV-Ray's objects allow you to choose between a fast but
sometimes inaccurate root solver and a slower but more accurate one. This is
the case for all objects that involve the solution of a cubic or quartic
polynomial. There are analytic mathematical solutions for those polynomials
that can be used.</p>
<p>
Lower order polynomials are trivial to solve while higher order polynomials
require iterative algorithms to solve them. One of those algorithms is the
Sturmian root solver. For example:</p>
<pre>
blob {
  threshold .65
  sphere { &lt;.5,0,0&gt;, .8, 1 }
  sphere { &lt;-.5,0,0&gt;,.8, 1 }
  sturm
  }
</pre>

<p>The keyword may optionally be followed by a float expression which is
interpreted as a boolean value. For example <code>sturm off</code> may be
used to force it off. When the keyword is specified alone, it is the same as
<code>sturm on</code>. By default <code>sturm</code> is <code>off</code> when not specified.</p>
<p>
The following list shows all objects for which the Sturmian root solver can
be used.</p>
<ul>
<li>blob</li>
<li>cubic</li>
<li>lathe (only with quadratic splines)</li>
<li>poly</li>
<li>prism (only with cubic splines)</li>
<li>quartic</li>
<li>sor</li>
<li>torus</li>
</ul>

</div>

</div>

</div>
</body>
</html>
